#Введение в tidyverse {#tidy_intro}

## Вселенная tidyverse {#tidy_verse}

tidyverse - это не один, а целое множество пакетов. Есть ключевые пакеты (ядро тайдиверса), а есть побочные - в основном для работы со специфическими видами данных.

[_tidyverse_](https://www.tidyverse.org) --- это набор пакетов:

* _ggplot2_, для визуализации
* _tibble_, для работы с тибблами, продвинутый вариант датафрейма
* _tidyr_, для формата tidy data
* _readr_, для чтения файлов в R
* _purrr_, для функционального программирования (замена семейства функций *apply())
* _dplyr_, для преобразованиия данных
* _stringr_, для работы со строковыми переменными
* _forcats_, для работы с переменными-факторами

Полезно также знать о следующих пакетах, не включенных в ядро, но также считающихся частью тайдиверса:

* _readxl_, для чтения .xls и .xlsx
* _jsonlite_, для работы с JSON
* _rvest_, для веб-скреппинга
* _lubridate_, для работы с временем
* _tidytext_, для работы с текстами и корпусами
* _broom_, для перевода в tidy формат статистические модели

Все эти пакеты объединены tidy философией и взаимосовместимым синтаксисом. Это означает, что, во многих случаях даже не нужно думать о том, из какого именно пакета тайдиверса пришла функция. Можно просто установить и загрузить пакет `tidyverse`.

```{r, eval = FALSE}
install.packages("tidyverse")
```

```{r, message = TRUE}
library("tidyverse")
```


## Загрузка данных: readr, readxl

Стандартной функцией для чтения `.csv` файлов в R является функция `read.csv()`, но мы будем использовать функцию `read_csv()` из пакета `readr`. `read_csv()` 

```{r, message = TRUE}
heroes <- read_csv("data/heroes_information.csv",
                   na = c("-", "-99"))
```

Если же нужно прочитать файл Excel (форматы `.xls`, `.xlsx`), то можно воспользоваться специальным пакетом `readxl`:

```{r, eval = FALSE}
library("readxl")
read_excel("Название_Excel_таблицы.xlsx")
```

##tibble

Когда мы загрузили данные с помощью `read_csv()`, то мы получили `tibble`, а не `data.frame`:

```{r}
class(heroes)
```

Тиббл (`tibble`) - это такой "усовершенствованный" `data.frame`. [Почти](https://www.jumpingrivers.com/blog/the-trouble-with-tibbles/) все, что работает с `data.frame`, работает и с тибблами. Однако у тибблов есть свои дополнительные фишки. Самая очевидная из них - более аккуратный вывод в консоль:

```{r}
heroes
```

Выводятся только первые 10 строк, если какие-то колонки не влезают на экран, то они просто перечислены внизу. Ну а тип данных написан прямо под названием колонки.

Функции различных пакетов tidyverse сами конвертируют в тиббл при необходимости. Если же нужно это сделать самостоятельно, то можно это сделать так:

```{r}
heroes_df <- as.data.frame(heroes) #создаем простой датафрейм
class(heroes_df)
as_tibble(heroes_df) #превращаем обратно в тиббл
```

> В дальнейшем мы будем работать только с tidyverse, а это значит, что только с тибблами, а не обычными датафреймами. Тем не менее, тибблы и датафреймы будут в дальнейшем использоваться как синонимы.

Можно создавать тибблы вручную с помощью функции `tibble()`, которая работает аналогично функции `data.frame()`:

```{r}
tibble(
  a = 1:3,
  b = letters[1:3]
)
```

## magrittr::`%>%` {#pipe}

Оператор `%>%` называется “пайпом” (pipe), т.е. “трубой”. Он означает, что следующая функция (справа от пайпа) принимает на вход в качестве первого аргумента результат выполнения предыдущей функции (той, что слева). Фактически, это примерно то же самое, что и вставлять результат выполнения функции в качестве первого аргумента в другую функцию. Просто выглядит это красивее и читабельнее. Как будто данные пропускаются через трубы функций или конвеерную ленту на заводе, если хотите. А то, что первый параметр функции - это почти всегда данные, работает нам здесь на руку. Этот оператор взят из пакета `magrittr`[^pipes_everywhere]. Возможно, даже если вы не захотите пользоваться tidyverse, использование пайпов Вам понравится.

[^pipes_everywhere]: Если быть точным, то оператор `%>%` был импортирован во все основные пакеты tidyverse, а сам пакет `magrittr` не входит в базовый набор tidyverse. Тем не менее, в самом `magrittr` есть еще несколько интересных операторов.

Важно понимать, что пайп не дает какой-то дополнительной функциональности или дополнительной скорости работы[^pipe_speed]. Он создан исключительно для читабельности и комфорта.

[^pipe_speed]: Даже наоборот, использование пайпов незначительно снижает скорость выполнения команды.

С помощью пайпов вот эту команду...

```{r}
sum(sqrt(abs(sin(1:22))))
```

...можно переписать вот так:

```{r}
1:22 %>% 
  sin() %>% 
  abs() %>% 
  sqrt() %>% 
  sum()
```

В очень редких случаях результат выполнения функции нужно вставить не на первую позицию (или же мы хотим использовать его несколько раз). В этих случаях можно использовать `.`, чтобы обозначить, куда мы хотим вставить результат выполнения выражения слева от `%>%`.

```{r}
"Всем привет!" %>%
  c("--", ., "--")
```

## Выбор строк: `dplyr::slice()` и `dplyr::filter()` {#tidy_filter}

`dplyr`[^2] - это самая основа всего `tidyverse`. Этот пакет предоставляет основные функции для манипуляции с тибблами.

[^2]: [Есть споры о том, как это правильно читать](https://community.rstudio.com/t/pronunciations-of-common-r-terms/1810). Используемые варианты: *диплаер*, *диплюр*, *диплир*.

Начнем с выбора строк. Функция `dplyr::slice()` выбирает строчки по их числовому индексу.

```{r}
heroes %>%
  slice(3:10)
```

Функция `dplyr::filter()` делает то же самое, но уже по условию. Причем для условий нужно использовать не векторы из тиббла, а название колонок (без кавычек) как будто бы они были переменными в окружении.

```{r}
heroes %>% 
  filter(Publisher == "DC Comics")
```

## dplyr::select() {#tidy_select}

Функция `dplyr::select()` позволяет выбирать колонки по номеру или имени (кавычки не нужны).

```{r}
heroes %>%
  select(1,5)
```

```{r}
heroes %>%
  select(name, Race, Publisher, `Hair color`)
```

Возможности выбора колонок с использованием `dplyr::select()` очень широкие. Можно использовать оператор `:` для выбора нескольких соседних колонок (по аналогии с созданием числового вектора с шагом 1).

```{r}
heroes %>%
  select(name:Publisher)
```

```{r}
heroes %>%
  select(name:`Eye color`, Publisher:Weight)
```

Используя `!` можно вырезать ненужные колонки.

```{r}
heroes %>%
  select(!X1)
heroes %>%
  select(!(Gender:Height))
```

Можно даже выбирать колонки по их названию. Например, с помощью `ends_with()` можно выбрать все колонки, заканчивающиеся одинаковым суффиксом[^tidyselect].

[^tidyselect]: Функция `ends_with()` является одним из селекторов - функций специального мини-языка для выбора переменных, которые содержатся в пакете `tidyselect`. Как и в случае с `magrittr`, эти функции не содержатся в базовом tidyverse, но импортируются основыми пакетами tidyverse.

```{r}
heroes %>%
  select(ends_with("color"))
```

## Сортировка строк: `dplyr::arrange()` {#tidy_arrange}

Функция `dplyr::arrange()` сортирует строчки от меньшего к большему (или по алфавиту - для текстовых значений) по выбранной колонке. 

```{r}
heroes %>%
  select(name, Weight) %>%
  arrange(Weight)
```

Чтобы отсортировать в обратном порядке, воспользуйтесь функцией `desc()`.

```{r}
heroes %>%
  select(name, Weight) %>%
  arrange(desc(Weight))
```

Можно сортировать по нескольким колонкам сразу:

```{r}
heroes %>%
  select(name, Gender, Weight) %>%
  arrange(Gender, desc(Weight))
```

## Уникальные значения: `dplyr::distinct()` {#tidy_distinct}

`dplyr::distinct()` - это более быстрый аналог `unique()`, позволяет извлекать уникальные значения для одной или нескольких колонок.

```{r}
heroes %>%
  distinct(Gender)
```

```{r}
heroes %>%
  distinct(Gender, Race)
```

## Создание колонок: `dplyr::mutate()` и `dplyr::transmute()` {#tidy_mutate}

Функция `dplyr::mutate()` позволяет создавать новые колонки в тиббле.

```{r}
heroes %>%
  mutate(imt = Weight/(Height/100)^2) %>%
  select(name, imt) %>%
  arrange(desc(imt))
```

`dplyr::transmute()` - это аналог `dplyr::mutate()`, который не только создает новые колонки, но и сразу же выкидывает все старые:

```{r}
heroes %>%
  transmute(imt = Weight/(Height/100)^2)
```

## Агрегация: `dplyr::group_by() %>% dplyr::summarise()` {#tidy_group_by}

Функция `dplyr::summarise()`[^summarize] позволяет аггрегировать данные в тиббле. Работает она очень похоже на `dplyr::mutate()`, но если внутри `mutate()` используются векторизованные функции, возвращающие вектор такой же длины, что и колонки, использовавшиеся для расчетов, то в `summarise()` используются функции, которые возвращают вектор длиной 1. Например, `min()`, `mean()`, `max()` и т.д. Можно создавать несколько колонок через запятую (это работает и для `mutate()`).

[^summarize]: У функции `dplyr::summarise()` есть синоним `dplyr::summarize()`, которая делает абсолбтно то же самое. Просто потому что в американском английском и британском английском это слово пишется по-разному.

```{r}
heroes %>%
  mutate(imt = Weight/(Height/100)^2) %>%
  summarise(min(imt, na.rm = TRUE),
            max(imt, na.rm = TRUE))
```

`group_by()` - это функция для группировки данных в тиббле по дискретной переменной для дальнейшей аггрегации с помощью `summarise()`. После применения `group_by()` тиббл будет выглядеть так же, но у него появятся аттрибут `groups`. Если после этого применить на тиббле функцию `summarise()`, то мы получим не тиббл длиной один, а тиббл со значением для каждой из групп.

Аггрегация по группам - это очень часто возникающая задача, например, это может использоваться для усреднения данных по испытуемым или условиям. 


```{r}
heroes %>%
  mutate(imt = Weight/(Height/100)^2) %>%
  group_by(Gender) %>%
  summarise(min(imt, na.rm = TRUE),
            max(imt, na.rm = TRUE))
```

Для подсчет количества значений можно воспользоваться функцией `n()`.

```{r}
heroes %>%
  group_by(Gender) %>%
  summarise(n = n())
```

Таблицу частот можно создать без `group_by()` и `summarise(n = n())`. Функция `count()` заменяет эту конструкцию: 

```{r}
heroes %>%
  count(Gender)
```

```{r}
heroes %>%
  count(Gender, sort = TRUE)
```

Если вы хотите создать не какое-то саммари, а целый дополнительный столбец с этим саммари вместо функции `summarise()` нужно использовать функцию `mutate()`:

```{r}
heroes %>%
  group_by(Race) %>%
  mutate(Gender_n = n()) %>%
  select(name, Gender, Gender_n)
```


### Соединение датафреймов: bind_rows(), bind_cols() {#tidy_bind}

Для начала создадим следующие тибблы и сохраним их как `dc` и `marvel`:

```{r}
dc <- heroes %>%
  filter(Publisher == "DC Comics") %>%
  group_by(Gender) %>%
  summarise(weight_mean = mean(Weight, na.rm = TRUE))
dc
marvel <- heroes %>%
  filter(Publisher == "Marvel Comics") %>%
  group_by(Gender) %>%
  summarise(weight_mean = mean(Weight, na.rm = TRUE))
marvel
```

Несколько тибблов можно объединить вертикально с помощью функции `bind_rows()`. Для корректного объединения тибблы должны иметь одинаковые названия колонок.

```{r}
bind_rows(dc, marvel)
```

Чтобы соединить тибблы горизонтально, воспользуйтесь функцией `bind_cols()`.

```{r}
bind_cols(dc, marvel)
```

## Соединение датафреймов: *_join

В реальности иногда возникает ситуация, когда нужно соединить две таблички, у которых есть общий столбец (или несколько столбцов), но все остальные столбцы различаются. Эти две таблички нужно объединить (*join*). Эта задача обычно возникает не очень часто, обычно это происходит один-два раза в одном проекте, когда нужно дополнить имеющиеся данные дополнительной информацией извне или объединить два набора данных, обрабатывавшихся в разных программах. Всякий раз, когда такая задача возникает, это доставляет много боли. `dplyr` предлагает интуитивно понятный инструмент для объединения тибблов - семейство функций `*_join()`.

Возьмем для примера два тиббла `band_members` и `band_instruments`, встроенных в `dplyr` специально для демонстрации работы функций `*_join()`.

```{r}
band_members
band_instruments
```

- `left_join()`: 

```{r}
band_members %>%
  left_join(band_instruments)
```


```{r}
band_members %>%
  left_join(band_instruments, by = "name")
```

```{r}
band_members %>%
  left_join(band_instruments2, by = c("name" = "artist"))
```

- `right_join()`:

```{r}
band_members %>%
  right_join(band_instruments)
```

- `full_join()`:

```{r}
band_members %>%
  full_join(band_instruments)
```

- `inner_join()`:

```{r}
band_members %>%
  inner_join(band_instruments)
```

- `semi_join()`:

```{r}
band_members %>%
  semi_join(band_instruments)
```

- `anti_join()`:

```{r}
band_members %>%
  anti_join(band_instruments)
```

## Tidy data: `tidyr::pivot_longer()`, `tidyr::pivot_wider()` {#tidy_data}

Принцип tidy data предполагает, что каждая строчка содержит в себе одно измерение, а каждая колонка - одну характеристику. Тем не менее, это не говорит однозначно о том, как именно хранить повторные измерения. Их можно хранить как одну колонку для каждого измерения (широкий формат) и как две колонки: одна колонка - для идентификатора измерения, другая колонка - для записи самого измерения.

Это лучше понять на примере. Например, вес до и после прохождения курса. Как это лучше записать - как два числовых столбца (один испытуемый - одна строка) или же создать отдельную "группирующую" колонку, в которой будет написано время измерения, а в другой - измеренные значения (одно измерение - одна строка)? 

- **Широкий формат:**

Студент |До курса по R     | После курса по R
--------|----------------  | ----------------
Маша    |70                | 63
Рома    |80                | 74
Антонина|86                | 71

- **Длинный" формат:**

Студент |Время измерения   | Масса (кг)
--------|----------------  | ----------------
Маша    |До курса по R     | 70
Рома    |До курса по R     | 80
Антонина|До курса по R     | 86
Маша    |После курса по R  | 63
Рома    |После курса по R  | 74
Антонина|После курса по R  | 71


На самом деле, оба варианта приемлимы, оба варианта возможны в реальных данных, а разные функции и статистические пакеты могут требовать от вас как длинный, так и широкий форматы.

Таким образом, нам нужно научиться переводить из широкого формата в длинный и наоборот.

+ `tidyr::pivot_longer()`: из *широкого* в *длинный* формат  

+ `tidyr::pivot_wider()`: из *длинного* в *широкий* формат  

```{r}
new_diet <- tibble(
  student = c("Маша", "Рома", "Антонина"),
  before_r_course = c(70, 80, 86),
  after_r_course = c(63, 74, 71)
)
new_diet
```

Тиббл `new_diet` - это пример широкого формата данных.

Превратим тиббл `new_diet` длинный:

```{r}
new_diet %>%
  pivot_longer(cols = before_r_course:after_r_course,
               names_to = "measurement_time", 
               values_to = "weight_kg")
```

А теперь обратно в короткий:

```{r}
new_diet %>%
  pivot_longer(cols = before_r_course:after_r_course,
               names_to = "measurement_time", 
               values_to = "weight_kg") %>%
  pivot_wider(names_from = "measurement_time",
              values_from = "weight_kg")
```



