#Введение в tidyverse {#tidy_intro}

## Вселенная tidyverse {#tidy_verse}

tidyverse - это не один, а целое множество пакетов. Есть ключевые пакеты (ядро тайдиверса), а есть побочные - в основном для работы со специфическими видами данных.

[_tidyverse_](https://www.tidyverse.org) --- это набор пакетов:

* _ggplot2_, для визуализации
* _tibble_, для работы с тибблами, продвинутый вариант датафрейма
* _tidyr_, для формата tidy data
* _readr_, для чтения файлов в R
* _purrr_, для функционального программирования (замена семейства функций *apply())
* _dplyr_, для преобразованиия данных
* _stringr_, для работы со строковыми переменными
* _forcats_, для работы с переменными-факторами

Полезно также знать о следующих пакетах, не включенных в ядро, но также считающихся частью тайдиверса:

* _vroom_, для быстрой загрузки табоичных данных
* _readxl_, для чтения .xls и .xlsx
* _jsonlite_, для работы с JSON
* _xml_, для работы с XML
* _DBI_, для работы с базами данных
* _rvest_, для веб-скреппинга
* _lubridate_, для работы с временем
* _tidytext_, для работы с текстами и корпусами
* _glue_, для продвинутого объединения строк
* _magrtittr_, с несколькими вариантами pipe оператора
* _tidymodels_, для моделирования и машинного обучения[^tidymodels]
* _dtplyr_, для ускорения `dplyr` за счет перевод синтаксиса на `data.table`

[^tidymodels]: Как и пакет `tidyverse`, `tidymodels` --- это пакет с несколькими пакетами.

И это еще не все пакеты tidyverse! Есть еще много других небольших пакетов, которые тоже считаются частью tidyverse. Кроме официальных пакетов tidyverse есть множество пакетов, которые пытаются соответствовать принципам tidyverse и дополняют его.

Все пакеты tidyverse объединены tidy философией и взаимосовместимым синтаксисом. Это означает, что, во многих случаях даже не нужно думать о том, из какого именно пакета тайдиверса пришла функция. Можно просто установить и загрузить пакет `tidyverse`.

```{r, eval = FALSE}
install.packages("tidyverse")
```

Пакет `tidyverse` --- это такой [пакет с пакетами](https://cs11.pikabu.ru/post_img/big/2019/03/12/11/1552415351186680692.jpg).

```{r, message = TRUE}
library("tidyverse")
```

Подключение пакета `tidyverse` автоматически приводит к подключению ядра tidyverse, остальные же пакеты нужно подключать дополнительно при необходимости.

## Загрузка данных с помощью `readr`

Стандартной функцией для чтения `.csv` файлов в R является функция `read.csv()`, но мы будем использовать функцию `read_csv()` из пакета `readr`. Синтаксис функции `read_csv()` очень похож на `read.csv()`: первым аргументом является путь к файлу (в том числе можно использовать URL), некоторые остальные параметры тоже совпадают.

```{r, message = TRUE}
heroes <- read_csv("data/heroes_information.csv",
                   na = c("-", "-99"))
```

Подробнее про импорт данных, в том числе в tidyverse, смотри в \@ref(real_data).  

##tibble

Когда мы загрузили данные с помощью `read_csv()`, то мы получили `tibble`, а не `data.frame`:

```{r}
class(heroes)
```

Тиббл (`tibble`) - это такой "усовершенствованный" `data.frame`. [Почти](https://www.jumpingrivers.com/blog/the-trouble-with-tibbles/) все, что работает с `data.frame`, работает и с тибблами. Однако у тибблов есть свои дополнительные фишки. Самая очевидная из них - более аккуратный вывод в консоль:

```{r}
heroes
```

Выводятся только первые 10 строк, если какие-то колонки не влезают на экран, то они просто перечислены внизу. Ну а тип данных написан прямо под названием колонки.

Функции различных пакетов tidyverse сами конвертируют в тиббл при необходимости. Если же нужно это сделать самостоятельно, то можно это сделать так:

```{r}
heroes_df <- as.data.frame(heroes) #создаем простой датафрейм
class(heroes_df)
as_tibble(heroes_df) #превращаем обратно в тиббл
```

> В дальнейшем мы будем работать только с tidyverse, а это значит, что только с тибблами, а не обычными датафреймами. Тем не менее, тибблы и датафреймы будут в дальнейшем использоваться как синонимы.

Можно создавать тибблы вручную с помощью функции `tibble()`, которая работает аналогично функции `data.frame()`:

```{r}
tibble(
  a = 1:3,
  b = letters[1:3]
)
```

## magrittr::`%>%` {#pipe}

Оператор `%>%` называется “пайпом” (pipe), т.е. “трубой”. Он означает, что следующая функция (справа от пайпа) принимает на вход в качестве первого аргумента результат выполнения предыдущей функции (той, что слева). Фактически, это примерно то же самое, что и вставлять результат выполнения функции в качестве первого аргумента в другую функцию. Просто выглядит это красивее и читабельнее. Как будто данные пропускаются через трубы функций или конвеерную ленту на заводе, если хотите. А то, что первый параметр функции - это почти всегда данные, работает нам здесь на руку. Этот оператор взят из пакета `magrittr`[^pipes_everywhere]. Возможно, даже если вы не захотите пользоваться tidyverse, использование пайпов Вам понравится.

[^pipes_everywhere]: Если быть точным, то оператор `%>%` был импортирован во все основные пакеты tidyverse, а сам пакет `magrittr` не входит в базовый набор tidyverse. Тем не менее, в самом `magrittr` есть еще несколько интересных операторов.

Важно понимать, что пайп не дает какой-то дополнительной функциональности или дополнительной скорости работы[^pipe_speed]. Он создан исключительно для читабельности и комфорта.

[^pipe_speed]: Даже наоборот, использование пайпов незначительно снижает скорость выполнения команды.

С помощью пайпов вот эту команду...

```{r}
sum(sqrt(abs(sin(1:22))))
```

...можно переписать вот так:

```{r}
1:22 %>% 
  sin() %>% 
  abs() %>% 
  sqrt() %>% 
  sum()
```

В очень редких случаях результат выполнения функции нужно вставить не на первую позицию (или же мы хотим использовать его несколько раз). В этих случаях можно использовать `.`, чтобы обозначить, куда мы хотим вставить результат выполнения выражения слева от `%>%`.

```{r}
"Всем привет!" %>%
  c("--", ., "--")
```

## Главные пакеты tidyverse: `dplyr` и `tidyr`

`dplyr`[^2] --- это самая основа всего `tidyverse`. Этот пакет предоставляет основные функции для манипуляции с тибблами. Пакет `dplyr` является наследником и более усовершенствованной версией `plyr`, так что если увидите использование пакета `plyr`, то, скорее всего, скрипт был написан очень давно.

[^2]: [Есть споры о том, как это правильно читать](https://community.rstudio.com/t/pronunciations-of-common-r-terms/1810). Используемые варианты: *диплаер*, *диплюр*, *диплир*.

Пакет `tidyr` дополняет `dplyr`, предоставляя полезные функции для трансформации тибблов. В общем, функционал этих двух пакетов давно смешался, поэтому мы будем рассматривать их вместе. Пакет `tidyr` --- это более усовершенствованная версия пакета `reshape2`, который в свою очередь является усовершенствованной версией `reshape`. По аналогии с `plyr`, если вы видите использование этих пакетов, то это указывает на то, что перед вами морально устаревший код.

Код с использованием `dplyr` и `tidyr`сильно непохож на то, что мы видели раньше. Большинство функций `dplyr` и `tidyr` работают с целым тибблом сразу, принимая его в качестве первого аргумента и возвращая измененный тиббл. Это позволяет превратить весь код в последовательный набор применяемых функций, соединенный пайпами. На практике это выглядит очень элегантно, и вы в этом скоро убедитесь.

## Выбор строк {#tidy_filter}

Начнем с выбора строк. Функция `dplyr::slice()` выбирает строчки по их числовому индексу.

```{r}
heroes %>%
  slice(1:3)
```

Функции tidyverse не изменяют сами изначальные тибблы/датафреймы. Это означает, что если вы хотите полученный результат сохранить, то нужно добавить присвоение:

```{r}
first_three_heroes <- heroes %>%
  slice(1:3)
```

Функция `dplyr::filter()` делает то же самое, что и `slice()`, но уже по условию. Причем для условий нужно использовать не векторы из тиббла, а название колонок (без кавычек) как будто бы они были переменными в окружении.

```{r}
heroes %>% 
  filter(Publisher == "DC Comics")
```

Если нужно выбрать только строчки без пропущенных значений, то можно воспользоваться удобной функцией `tidyr::drop_na()`.

```{r}
heroes %>%
  drop_na()
```

## Выборов столбцов {#tidy_select}

Функция `dplyr::select()` позволяет выбирать колонки по номеру или имени (кавычки не нужны).

```{r}
heroes %>%
  select(1,5)
```

```{r}
heroes %>%
  select(name, Race, Publisher, `Hair color`)
```

Обратите внимание, если в названии колонки присутствует пробел или, например, колонка начинается с цифры или точки и цифры, то это синтаксически невалидное имя (\@ref(variables)). Это не значит, что такие названия колонок недопустимы. Но такие названия колонок нужно обособлять \` грависом (правый штрих, на клавиатуре находится там же где и буква ё и ~).

Для выбора столбцов (не только в `select()`, но и для других функций tidyverse) используется специальный мини-язык tidyselect из одноименного пакета[^tidyselect_package]. tidyselect дает очень широкие возможности для выбора колонок.

[^tidyselect_package]: Как и в случае с `magrittr`, пакет `tidyselect` не содержатся в базовом tidyverse, но функции импортируются основыми пакетами tidyverse.

Можно использовать оператор `:` для выбора нескольких соседних колонок (по аналогии с созданием числового вектора с шагом 1).

```{r}
heroes %>%
  select(name:Publisher)
```

```{r}
heroes %>%
  select(name:`Eye color`, Publisher:Weight)
```

Используя `!` можно вырезать ненужные колонки.

```{r}
heroes %>%
  select(!X1)
heroes %>%
  select(!(Gender:Height))
```



```{r}
heroes %>%
  select(name:last_col())
```

```{r}
heroes %>%
  select(everything())
```

При этом `everything()` не будет дублировать выбранные колонки, поэтому можно использовать `everything()` для перестановки колонок в тиббле:

```{r}
heroes %>%
  select(name, Publisher, everything())
```

Можно даже выбирать колонки по их названию. Например, с помощью `ends_with()` можно выбрать все колонки, заканчивающиеся одинаковым суффиксом:

```{r}
heroes %>%
  select(ends_with("color"))
```

Аналогично, с помощью функции `starts_with()` можно найти колонки с одинаковым префиксом, с помощью `contains()` --- все колонки с выбранным паттерном в любой части названия колонки[^tidyselect_regex]. 

[^tidyselect_regex]: Выбранный паттерн будет найден посимвольно, если же вы хотите искать по регулярным выражениям, то вместо `contains()` нужно использовать `matches()`.

```{r}
heroes %>%
  select(starts_with("Eye") & ends_with("color"))
heroes %>%
  select(contains("eight"))
```

Ну и наконец, можно выбирать по содержимому колонок с помощью `where()`. Это напоминает применение `sapply()` на датафрейме для индексирования колонок: в качестве аргумента для `where` принимается функция, которая применяется для каждой из колонок, после чего выбираются только те колонки, для которых было получено `TRUE`.

```{r}
heroes %>%
  select(where(is.numeric))
```

Функция `where()` дает невиданную мощь. Например, можно выбрать все колонки без `NA`:

```{r}
heroes %>%
  select(where(function(x) !any(is.na(x))))
```

Внутри `select()` можно не только выбирать колонки, но и переименовывать их:

```{r}
heroes %>%
  select(id = X1)
```

Однако удобнее для этого использовать специальную функцию `dplyr::rename()`. Синтаксис у нее такой же, как и у `select()`, но `rename()` не выбрасывает колонки, которые не были упомянуты.

```{r}
heroes %>%
  rename(id = X1)
```


Последняя важная функция для выбора колонок --- `pull()`. Эта функция делает то же самое, что и индексирование с помощью `$`, т.е. вытаскивает из тиббла вектор с выбранным названием. Это лучше вписывается в логику tidyverse, поскольку позволяет извлечь колонку из тиббла с использованием пайпа:

```{r}
heroes %>%
  select(Height) %>%
  pull() %>%
  head()

heroes %>%
  pull(Height) %>%
  head()
```

У функции `pull()` есть аргумент `name =`, который позволяет создать проименованный вектор:

```{r}
heroes %>%
  pull(Height, name) %>%
  head()
```

## Сортировка строк: `dplyr::arrange()` {#tidy_arrange}

Функция `dplyr::arrange()` сортирует строчки от меньшего к большему (или по алфавиту - для текстовых значений) по выбранной колонке. 

```{r}
heroes %>%
  select(name, Weight) %>%
  arrange(Weight)
```

Чтобы отсортировать в обратном порядке, воспользуйтесь функцией `desc()`.

```{r}
heroes %>%
  select(name, Weight) %>%
  arrange(desc(Weight))
```

Можно сортировать по нескольким колонкам сразу:

```{r}
heroes %>%
  select(name, Gender, Weight) %>%
  arrange(Gender, desc(Weight))
```

## Уникальные значения: `dplyr::distinct()` {#tidy_distinct}

`dplyr::distinct()` - это более быстрый аналог `unique()`, позволяет извлекать уникальные значения для одной или нескольких колонок.

```{r}
heroes %>%
  distinct(Gender)
```

```{r}
heroes %>%
  distinct(Gender, Race)
```

## Создание колонок: `dplyr::mutate()` и `dplyr::transmute()` {#tidy_mutate}

Функция `dplyr::mutate()` позволяет создавать новые колонки в тиббле.

```{r}
heroes %>%
  mutate(imt = Weight/(Height/100)^2) %>%
  select(name, imt) %>%
  arrange(desc(imt))
```

`dplyr::transmute()` - это аналог `dplyr::mutate()`, который не только создает новые колонки, но и сразу же выкидывает все старые:

```{r}
heroes %>%
  transmute(imt = Weight/(Height/100)^2)
```

## Агрегация: `dplyr::group_by() %>% dplyr::summarise()` {#tidy_group_by}

Функция `dplyr::summarise()`[^summarize] позволяет аггрегировать данные в тиббле. Работает она очень похоже на `dplyr::mutate()`, но если внутри `mutate()` используются векторизованные функции, возвращающие вектор такой же длины, что и колонки, использовавшиеся для расчетов, то в `summarise()` используются функции, которые возвращают вектор длиной 1. Например, `min()`, `mean()`, `max()` и т.д. Можно создавать несколько колонок через запятую (это работает и для `mutate()`).

[^summarize]: У функции `dplyr::summarise()` есть синоним `dplyr::summarize()`, которая делает абсолбтно то же самое. Просто потому что в американском английском и британском английском это слово пишется по-разному.

```{r}
heroes %>%
  mutate(imt = Weight/(Height/100)^2) %>%
  summarise(min(imt, na.rm = TRUE),
            max(imt, na.rm = TRUE))
```

`group_by()` - это функция для группировки данных в тиббле по дискретной переменной для дальнейшей аггрегации с помощью `summarise()`. После применения `group_by()` тиббл будет выглядеть так же, но у него появятся аттрибут `groups`[^ungroup()]: 

```{r}
heroes %>%
  group_by()
```

[^ungroup]: Снять группировку можно с помощью функции `ungroup()`.

Если после этого применить на тиббле функцию `summarise()`, то мы получим не тиббл длиной один, а тиббл со значением для каждой из групп.

Аггрегация по группам - это очень часто возникающая задача, например, это может использоваться для усреднения данных по испытуемым или условиям. 


```{r}
heroes %>%
  mutate(imt = Weight/(Height/100)^2) %>%
  group_by(Gender) %>%
  summarise(min(imt, na.rm = TRUE),
            max(imt, na.rm = TRUE))
```

## Подсчет строк: `dplyr::n()`, `dplyr::count()`

Для подсчет количества значений можно воспользоваться функцией `n()`.

```{r}
heroes %>%
  group_by(Gender) %>%
  summarise(n = n())
```

Функция `n()` вместе с `group_by()` внутри `filter()` позволяет удобным образом "отрезать" от тиббла редкие группы...

```{r}
heroes %>%
  group_by(Race) %>%
  filter(n() > 10) %>%
  select(name, Race)
```

или же наоборот, выделить только маленькие группы: 

```{r}
heroes %>%
  group_by(Race) %>%
  filter(n() == 1) %>%
  select(name, Race)
```

Таблицу частот можно создать без `group_by()` и `summarise(n = n())`. Функция `count()` заменяет эту конструкцию: 

```{r}
heroes %>%
  count(Gender)
```

Эту таблицу частот удобно сразу проранжировать, указав в параметре `sort =` значение `TRUE`.

```{r}
heroes %>%
  count(Gender, sort = TRUE)
```

> Функция `count()`, несмотря на свою простоту, является одной из наиболее используемых в tidyverse.

Иногда нужно аггрегировать данные, но при этом сохранить исходную структуру тиббла.  Например, нужно посчитать размер групп или посчитать средние значения по группе для последующего сравнения с индивидуальными значениями.
В tidyverse это можно сделать с помощью сочетания `group_by()` и `mutate()` (вместо `summarise()`):

```{r}
heroes %>%
  group_by(Race) %>%
  mutate(Gender_n = n()) %>%
  select(Race, name, Gender, Gender_n)
```

Результаты аггрегации были записаны в отдельную колонку, при этом значения этой колонки внутри одной группы повторяются. 



## Соединение датафреймов: bind_rows(), bind_cols() {#tidy_bind}

Для начала создадим следующие тибблы и сохраним их как `dc` и `marvel`:

```{r}
dc <- heroes %>%
  filter(Publisher == "DC Comics") %>%
  group_by(Gender) %>%
  summarise(weight_mean = mean(Weight, na.rm = TRUE))
dc
marvel <- heroes %>%
  filter(Publisher == "Marvel Comics") %>%
  group_by(Gender) %>%
  summarise(weight_mean = mean(Weight, na.rm = TRUE))
marvel
```

Несколько тибблов можно объединить вертикально с помощью функции `bind_rows()`. Для корректного объединения тибблы должны иметь одинаковые названия колонок.

```{r}
bind_rows(dc, marvel)
```

Чтобы соединить тибблы горизонтально, воспользуйтесь функцией `bind_cols()`.

```{r}
bind_cols(dc, marvel)
```

## Соединение датафреймов: *_join

В реальности иногда возникает ситуация, когда нужно соединить две таблички, у которых есть общий столбец (или несколько столбцов), но все остальные столбцы различаются. Эти две таблички нужно объединить (*join*). Эта задача обычно возникает не очень часто, обычно это происходит один-два раза в одном проекте, когда нужно дополнить имеющиеся данные дополнительной информацией извне или объединить два набора данных, обрабатывавшихся в разных программах. Всякий раз, когда такая задача возникает, это доставляет много боли. `dplyr` предлагает интуитивно понятный инструмент для объединения тибблов - семейство функций `*_join()`.

Возьмем для примера два тиббла `band_members` и `band_instruments`, встроенных в `dplyr` специально для демонстрации работы функций `*_join()`.

```{r}
band_members
band_instruments
```

- `left_join()`: 

```{r}
band_members %>%
  left_join(band_instruments)
```


```{r}
band_members %>%
  left_join(band_instruments, by = "name")
```

```{r}
band_members %>%
  left_join(band_instruments2, by = c("name" = "artist"))
```

- `right_join()`:

```{r}
band_members %>%
  right_join(band_instruments)
```

- `full_join()`:

```{r}
band_members %>%
  full_join(band_instruments)
```

- `inner_join()`:

```{r}
band_members %>%
  inner_join(band_instruments)
```

- `semi_join()`:

```{r}
band_members %>%
  semi_join(band_instruments)
```

- `anti_join()`:

```{r}
band_members %>%
  anti_join(band_instruments)
```

## Tidy data: `tidyr::pivot_longer()`, `tidyr::pivot_wider()` {#tidy_data}

Принцип tidy data предполагает, что каждая строчка содержит в себе одно измерение, а каждая колонка - одну характеристику. Тем не менее, это не говорит однозначно о том, как именно хранить повторные измерения. Их можно хранить как одну колонку для каждого измерения (широкий формат) и как две колонки: одна колонка - для идентификатора измерения, другая колонка - для записи самого измерения.

Это лучше понять на примере. Например, вес до и после прохождения курса. Как это лучше записать - как два числовых столбца (один испытуемый - одна строка) или же создать отдельную "группирующую" колонку, в которой будет написано время измерения, а в другой - измеренные значения (одно измерение - одна строка)? 

- **Широкий формат:**

Студент |До курса по R     | После курса по R
--------|----------------  | ----------------
Маша    |70                | 63
Рома    |80                | 74
Антонина|86                | 71

- **Длинный" формат:**

Студент |Время измерения   | Масса (кг)
--------|----------------  | ----------------
Маша    |До курса по R     | 70
Рома    |До курса по R     | 80
Антонина|До курса по R     | 86
Маша    |После курса по R  | 63
Рома    |После курса по R  | 74
Антонина|После курса по R  | 71


На самом деле, оба варианта приемлимы, оба варианта возможны в реальных данных, а разные функции и статистические пакеты могут требовать от вас как длинный, так и широкий форматы.

Таким образом, нам нужно научиться переводить из широкого формата в длинный и наоборот.

+ `tidyr::pivot_longer()`: из *широкого* в *длинный* формат  

+ `tidyr::pivot_wider()`: из *длинного* в *широкий* формат  

```{r}
new_diet <- tibble(
  student = c("Маша", "Рома", "Антонина"),
  before_r_course = c(70, 80, 86),
  after_r_course = c(63, 74, 71)
)
new_diet
```

Тиббл `new_diet` - это пример широкого формата данных.

Превратим тиббл `new_diet` длинный:

```{r}
new_diet %>%
  pivot_longer(cols = before_r_course:after_r_course,
               names_to = "measurement_time", 
               values_to = "weight_kg")
```

А теперь обратно в короткий:

```{r}
new_diet %>%
  pivot_longer(cols = before_r_course:after_r_course,
               names_to = "measurement_time", 
               values_to = "weight_kg") %>%
  pivot_wider(names_from = "measurement_time",
              values_from = "weight_kg")
```



