

# Задания {#tasks}

```{r include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

## Вектор {#vec_task_1}

- Посчитайте логарифм от 8912162342 по основанию 6

```{r}
log(8912162342, 6)

```

- Теперь натуральный логарифм 10 и умножьте его на 5

```{r}
log(10)*5
```

- Создайте вектор от 1 до 20

```{r}
1:20
```

- Создайте вектор от 20 до 1

```{r}
20:1
```

- Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз!

```{r}
c(1:20, 19:1)
```

- Создайте вектор 2, 4, 6,  ... , 18, 20

```{r}
seq(2,20, 2)
```

- Создайте вектор из одной единицы, двух двоек, трех троек, .... , девяти девяток

```{r}
rep(1:9, 1:9)
```

- Сделайте вектор vec, в котором соедините `3`, а также значения `"Мой"` и `"вектор"`.

```{r}
vec <- c(3, "Мой", "вектор")
vec
```

- Вычесть `TRUE` из 10

```{r}
10 - TRUE
```

- Соедините значение `10` и `TRUE` в вектор `vec`

```{r}
vec <- c(10, TRUE)
vec
```

- Соедините вектор `vec` и значение `"r"`:

```{r}
c(vec, "r")
```

- Соедините значения `10`, `TRUE`, `"r"`  в вектор.

```{r}
c(10, TRUE, "r")
```

## Вектор. Операции с векторами {#vec_op}

Создайте вектор `p`, состоящий из значений 4, 5, 6, 7, и вектор `q`, состоящий из 0, 1, 2, 3. 

```{r}
p <- 4:7
p
q <- 0:3
q
```

Посчитайте поэлементную сумму векторов `p` и `q`:

```{r}
p + q
```

Посчитайте поэлементную разницу `p` и `q`:

```{r}
p - q
```

Поделите каждый элемент вектора `p` на соответствующий ему элемент вектора `q`:

> О, да, Вам нужно делить на 0!

```{r}
p/q
```

Возведите каждый элемент вектора `p` в степень соответствующего ему элемента вектора `q`:

```{r}
p^q
```


Создайте вектор квадратов чисел от 1 до 10:

```{r}
(1:10)^2
```

Создайте вектор 0, 2, 0, 4, ... , 18, 0, 20

```{r}
1:20 * 0:1
```

## Вектор. Индексирование {#vec_task_2}

Создайте вектор `vec1`:

```{r, echo = TRUE}
vec1 <- c(3, 5, 2, 1, 8, 4, 9, 10, 3, 15, 1, 11)
```

- Найдите второй элемент вектора `vec1`:

```{r}
vec1[2]
```

- Найдите последний элемент вектора `vec1`

```{r}
vec1[length(vec1)]
```

- Найдите все значения вектора `vec1`, которые больше 4

```{r}
vec1[vec1>4]
```

- Найдите все значения вектора vec1, которые больше 4, но меньше 10

```{r}
vec1[vec1>4 & vec1<10]
```

- Возведите в квадрат каждое значение вектора `vec1`

```{r}
vec1^2
```

- Возведите в квадрат каждое значение вектора на нечетной позиции и извлеките корень из каждого значения на четной позиции вектора `vec1`

```{r}
vec1 ^ c(2, 0.5)
```

- Создайте вектор `vec2`, в котором все значения `vec1`, которые меньше 10, будут заменены на `NA`.

```{r}
vec2 <- vec1
vec2[vec2<10] <- NA
vec2
```


- Посчитайте сумму `vec2` с помощью функции `sum()`. Ответ `NA` не считается!

```{r}
sum(vec2, na.rm = TRUE)
```

- Создайте вектор 2, 4, 6,  ... , 18, 20 как минимум 2 новыми способами

> Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше!

```{r}
(1:20)[c(F,T)]
#(1:10)*2
```

## Списки {#list_ta}

Дан список `list_1`:

```{r, echo = T}
list_1 = list(numbers = 1:5, letters = letters, logic = T)
list_1
```

- Найдите первый элемент списка. Ответ должен быть списком.

```{r}
list_1[1]
```

- Теперь найдите содержание первого элемента списка двумя разными способами. Ответ должен быть вектором.

```{r}
list_1[[1]]
list_1$numbers
```

Теперь возьмите первый элемент содержания первого элемента списка. Ответ должен быть вектором.

```{r}
list_1[[1]][1]
```

Создайте список `list_2`, содержащий в себе два списка `list_1` с именами `pupa` и `lupa`.

```{r}
list_2 = list(pupa = list_1, lupa = list_1)
list_2
```

Извлеките первый элемент списка, из него - второй полэлемент, а из него - третье значение
```{r}
list_2[[1]][[2]][3]
```


## Матрицы {#t}

- Создайте матрицу 4х4, состоящую из единиц. Назовите ее `M`

```{r}
M <- matrix(rep(1, 16), ncol = 4)
M
```

- Поменяйте все некрайние значения матрицы `M` (то есть значения на позициях [2,2], [2,3], [3,2] и [3,3]) на число 2.

```{r}
M[2:3, 2:3] <- 2
M
```

- Выделите второй и третий столбик из матрицы `M`

```{r}
M[,2:3]
```

- Сравните (`==`) вторую колонку и вторую строчку матрицы `M`
```{r}
M[,2] == M[2,]
```


- Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную `tab`:

```{r}
tab <- matrix(rep(1:9, rep(9,9))*(1:9), nrow = 9)
tab

#Еще
#outer(1:9, 1:9, "*")
#1:9 %o% 1:9
```

- Из матрицы `tab` выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7.

```{r}
tab[6:8, 3:7]
```

- Создайте матрицу с логическими значениями, где `TRUE`, если в этом месте в таблице умножения (`tab`) двузначное число и `FALSE`, если однозначное.

> Матрица - это почти вектор. К нему можно обращаться с единственным индексом.

```{r}
tab>=10
```

- Создайте матрицу `tab2`, в которой все значения `tab` меньше 10 заменены на 0.

```{r}
tab2 <- tab
tab2[tab<10] <- 0
tab2
```

## Условные конструкции {#if_tasks}

Дан вектор `nums`:

```{r, echo = TRUE}
nums <- c(5, 20, 30, 0, 2, 9)
```

- Создайте новый строковый вектор, где на месте чисел больше 10 в `nums` будет стоять "большое число", а на месте остальных чисел --- "маленькое число".

```{r}
ifelse(nums > 10, "большое число", "маленькое число")
```

Загрузите файл heroes_information.csv в переменную `heroes`

```{r, echo = TRUE}
heroes <- read.csv("data/heroes_information.csv", 
                   stringsAsFactors = FALSE,
                   na.strings = c("-", "-99"))
```

- Создайте новою колонку `hair` в `heroes`, в которой будет значение `"Bold"` для тех супергероев, у которых в колонке `Hair.color` стоит `"Bold"`, и значение `"Hairy"` во всех остальных случаях.

```{r}
heroes$hair <- ifelse(heroes$Hair.color == "No Hair", "Bold", "Hairy")
head(heroes)
```

- Создайте новою колонку `tall` в `heroes`, в которой будет значение `"tall"` для тех супергероев, у которых в колонке `Height` стоит число больше 190, значение `"short"` для тех супергероев, у которых в колонке `Height` стоит число меньше 170, и значение `"middle"` во всех остальных случаях.

```{r}
# heroes$tall <- dplyr::case_when(
#   heroes$Height > 190 ~ "tall",
#   heroes$Height < 170 ~ "short",
#   TRUE ~ "middle"
# )
heroes$tall <- ifelse(heroes$Height > 190, 
                      "tall",
                      ifelse(heroes$Height < 170,
                             "short",
                             "middle"))
```

## Создание функций {#task_function}

- Создайте функцию `plus_one()`, которая принимает число и возвращает это же число + 1

```{r}
plus_one <- function(x) x+1
```

```{r, echo = TRUE}
plus_one(41)
```

- Создайте функцию `circle_area`, которая вычисляет площадь круга по радиусу согласно формуле $\pi r^2$

```{r}
circle_area <- function(r) pi * r ^ 2
```

- Создайте функцию `cels2fahr()`, которая будет превращать градусы по Цельсию в градусы по Фаренгейту.

```{r}
cels2fahr <- function(x) x * 9 / 5 + 32
```

Проверьте на значениях -100, -40 и 0, что функция `cels2fahr()` работает корректно.

```{r, echo = TRUE}
cels2fahr(c(-100, -40, 0))
```


- создайте функцию `closest()`, которая найдет в целочисленном векторе `x` все позиции значений, которые наименее удалены (по модулю) от значения `n`.

```{r}
closest <- function(x, to) {
  which(abs(x-to)==min(abs(x-to)))
}
closest(c(1, 2, 1, 2, 3, 4), 3)
```


- *Напишите функцию `is_prime()`, которая проверяет, является ли число простым.

> Здесь может понадобиться оператор для получения остатка от деления: `%%`. Еще может пригодиться функция `any()` - она возвращает `TRUE`, если в векторе есть хотя бы один `TRUE`

```{r}
is_prime <- function(x) !any(x%%(2:(x-1)) == 0)
``` 

```{r, echo = TRUE}
is_prime(2017)
is_prime(2019)
2019/3 #2019 делится на 3 без остатка
is_prime(2020)
```

- *Создайте функцию `monotonic()`, которая принимает возвращает `TRUE`, если значения в векторе не убывают (то есть каждое следующее - больше или равно предыдущему) или не возврастают.

```{r}
monotonic <- function(x) all(diff(x)>=0) | all(diff(x)<=0)
```

```{r, echo = TRUE}
monotonic(1:7)
monotonic(c(1:5,5:1))
monotonic(6:-1)
monotonic(c(1:5, rep(5, 10), 5:10))
```

## Семейство apply() {#task_text}

- Создайте функцию `na_n()`, которая будет возвращать количество `NA` в векторе.

```{r}
na_n <- function(x) sum(is.na(x))
```

```{r, echo = TRUE}
na_n(c(NA, 3:5, NA, 2, NA))
```

- Есть список `spisok`:

```{r, echo = TRUE}
spisok <- list(1:5, 0:20, 4:24, 6:3, 6:25)
```

- Посчитайте сумму каждого вектора.

```{r}
sapply(spisok, sum)
```

- А теперь длину.

```{r}
sapply(spisok, length)
```

- Напишите функцию `max_item()`, которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент.

```{r}
max_item <- function (x) spisok[[which.max(sapply(x, length))]]
```

- Теперь мы сделаем сложный список:

```{r, echo = T}
large_spisok <- list(1:3, 3:40, spisok)
```

- Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри

> Для этого может понадобиться функция `rapply()`: **recursive lapply**

```{r}
rapply(large_spisok, length, how = "list")
```
