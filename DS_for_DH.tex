% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Наука о данных в R для программы Цифровых гуманитарных исследований},
  pdfauthor={Г. А. Мороз, И. С. Поздняков},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\usepackage[normalem]{ulem}
% Avoid problems with \sout in headers with hyperref
\pdfstringdefDisableCommands{\renewcommand{\sout}{}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{fontspec}
\setmainfont[Ligatures=TeX,
             Path=font/,
             BoldFont=brillb,
             ItalicFont=brilli,
             BoldItalicFont=brillbi]{brill}

\usepackage{longtable}
\usepackage[bf,singlelinecheck=off]{caption}

\usepackage{framed,color}
\definecolor{shadecolor}{RGB}{248,248,248}

\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}

\let\oldhref\href
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
  \makeatletter
  \newenvironment{kframe}{%
    \medskip{}
    \setlength{\fboxsep}{.8em}
    \def\at@end@of@kframe{}%
    \ifinner\ifhmode%
    \def\at@end@of@kframe{\end{minipage}}%
    \begin{minipage}{\columnwidth}%
    \fi\fi%
    \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
    \colorbox{shadecolor}{##1}\hskip-\fboxsep
      % There is no \\@totalrightmargin, so:
        \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
    \MakeFramed {\advance\hsize-\width
      \@totalleftmargin\z@ \linewidth\hsize
      \@setminipage}}%
  {\par\unskip\endMakeFramed%
    \at@end@of@kframe}
  \makeatother
  
  \makeatletter
  \@ifundefined{Shaded}{
  }{\renewenvironment{Shaded}{\begin{kframe}}{\end{kframe}}}
  \makeatother
  
  \newenvironment{rmdblock}[1]
  {
    \begin{itemize}
    \renewcommand{\labelitemi}{
      \raisebox{-.7\height}[0pt][0pt]{
        {\setkeys{Gin}{width=3em,keepaspectratio}\includegraphics{images/#1}}
        }
        }
        \setlength{\fboxsep}{1em}
        \begin{kframe}
        \item
      }
      {
        \end{kframe}
        \end{itemize}
      }
      \newenvironment{rmdtask}
      {\begin{rmdblock}{task}}
      {\end{rmdblock}}
      
      \usepackage{makeidx}
      \makeindex
      
      \urlstyle{tt}
      
      \usepackage{amsthm}
      \makeatletter
      \def\thm@space@setup{%
        \thm@preskip=8pt plus 2pt minus 4pt
        \thm@postskip=\thm@preskip
      }
      \makeatother
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Наука о данных в R для программы Цифровых гуманитарных исследований}
\author{Г. А. Мороз, И. С. Поздняков}
\date{}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{ux43e-ux43aux443ux440ux441ux435}{%
\chapter{О курсе}\label{ux43e-ux43aux443ux440ux441ux435}}

Материалы для курса Наука о данных для магистерской программы Цифровых гуманитарные исследования НИУ ВШЭ.

\hypertarget{intro}{%
\chapter{Введение в R}\label{intro}}

\hypertarget{ux43dux430ux443ux43aux430-ux43e-ux434ux430ux43dux43dux44bux445}{%
\section{Наука о данных}\label{ux43dux430ux443ux43aux430-ux43e-ux434ux430ux43dux43dux44bux445}}

Наука о данных --- это новая область знаний, которая активно развивается в последнее время. Она находиться на пересечении компьютерных наук, статистики и математики, и трудно сказать, действительно ли это наука. При этом это движение развивается в самых разных научных направлениях, иногда даже оформляясь в отдельную отрасль:

\begin{itemize}
\tightlist
\item
  биоинформатика
\item
  вычислительная криминалистика
\item
  цифровые гуманитарные исследования
\item
  датажурналистика
\item
  \ldots{}
\end{itemize}

Все больше книг ``Data Science for \ldots{}'':

\begin{itemize}
\tightlist
\item
  psychologists \citep{hansjoerg19}
\item
  immunologists \citep{thomas19}
\item
  business \citep{provost13}
\item
  public policy \citep{brooks13}
\item
  fraud detection \citep{baesens15}
\item
  \ldots{}
\end{itemize}

Среди умений датасаентистов можно перечислить следующие:

\begin{itemize}
\tightlist
\item
  сбор и обработка данных
\item
  трансформация данных
\item
  визуализация данных
\item
  статистическое моделирование данных
\item
  представление полученных результатов
\item
  организация всей работы \textbf{воспроизводимым способом}
\end{itemize}

Большинство этих тем в той или иной мере будет представлено в нашем курсе.

\hypertarget{ux443ux441ux442ux430ux43dux43eux432ux43aux430-r-ux438-rstudio}{%
\section{Установка R и RStudio}\label{ux443ux441ux442ux430ux43dux43eux432ux43aux430-r-ux438-rstudio}}

В данной книге используется исключительно R \citep{r_core_team19}, так что для занятий понадобятся:

\begin{itemize}
\tightlist
\item
  R

  \begin{itemize}
  \tightlist
  \item
    \href{https://cran.r-project.org/bin/windows/base/}{на Windows}
  \item
    \href{https://cran.r-project.org/bin/macosx/}{на Mac}
  \item
    \href{https://cran.rstudio.com/bin/linux/}{на Linux}, также можно добавить зеркало и установить из командной строки:
  \end{itemize}
\end{itemize}

\begin{verbatim}
sudo apt-get install r-cran-base
\end{verbatim}

\begin{itemize}
\tightlist
\item
  RStudio --- IDE для R (\href{https://www.rstudio.com/products/rstudio/download/}{можно скачать здесь})
\item
  и некоторые пакеты на R
\end{itemize}

Часто можно увидеть или услышать, что R --- язык программирования для ``статистической обработки данных''. Изначально это, конечно, было правдой, но уже давно R --- это полноценный язык программирования, который при помощи своих пакетов позволяет решать огромный спектр задач. В данной книге используется следующая версия R:

\begin{verbatim}
## [1] "R version 4.0.3 (2020-10-10)"
\end{verbatim}

Некоторые люди не любят устанавливать лишние программы себе на компьютер, несколько вариантов есть и для них:

\begin{itemize}
\tightlist
\item
  \href{https://rstudio.cloud/}{RStudio cloud} --- полная функциональность RStudio, пока бесплатная, но скоро это исправят;
\item
  \href{https://www.rollapp.com/app/rstudio}{RStudio on rollApp} --- облачная среда, позволяющая разворачивать программы.
\end{itemize}

Первый и вполне закономерный вопрос: зачем мы ставили R и отдельно еще какой-то RStudio?
Если опустить незначительные детали, то R --- это сам язык программирования, а RStudio --- это среда (IDE), которая позволяет в этом языке очень удобно работать.

\hypertarget{ux43fux43eux43bux435ux437ux43dux44bux435-ux441ux441ux44bux43bux43aux438}{%
\section{Полезные ссылки}\label{ux43fux43eux43bux435ux437ux43dux44bux435-ux441ux441ux44bux43bux43aux438}}

В интернете легко найти документацию и туториалы по самым разным вопросам в R, так что главный залог успеха --- грамотно пользоваться поисковиком, и лучше на английском языке.

\begin{itemize}
\tightlist
\item
  \href{https://r4ds.had.co.nz/}{книга \citep{wickham16}} является достаточно сильной альтернативой всему курсу
\item
  \href{https://stackoverflow.com}{stackoverflow} --- сервис, где достаточно быстро отвечают на любые вопросы (не обязательно по R)
\item
  \href{https://community.rstudio.com/}{RStudio community} --- быстро отвечают на вопросы, связанные с R
\item
  \href{https://ru.stackoverflow.com}{русский stackoverflow}
\item
  \href{https://www.r-bloggers.com/}{R-bloggers} --- сайт, где собираются новинки, связанные с R
\item
  \href{https://t.me/rlang_ru}{чат}, где можно спрашивать про R на русском (но почитайте \href{https://github.com/r-lang-group-ru/group-rules/blob/master/README.md}{правила чата}, перед тем как спрашивать)
\item
  \href{https://t.me/joinchat/CxZg5goGc6rlWGjcvOYrpA}{чат} по визуализации данных, \href{https://t.me/ddjrus}{чат} датажурналистов
\item
  \href{https://t.me/chartomojka}{канал про визуализацию}, \href{https://t.me/novaya_data}{дата-блог ``Новой газеты''}, \ldots{}
\end{itemize}

\hypertarget{rstudio}{%
\section{Rstudio}\label{rstudio}}

Когда вы откроете RStudio первый раз, вы увидите три панели: консоль, окружение и историю, а также панель для всего остального. Если ткнуть в консоли на значок уменьшения, то можно открыть дополнительную панель, где можно писать скрипт.

\includegraphics[width=6.94in]{images/01_01_rstudio}

Существуют разные типы пользователей: одни любят работать в консоли (на картинке это \textbf{2 --- R Console}), другие предпочитают скрипты (\textbf{1 --- Code Editor}). Консоль позволяет использовать интерактивный режим команда-ответ, а скрипт является по сути текстовым документом, фрагменты которого можно для отладки запускать в консоли.

\textbf{3 --- Workspace and History}: Здесь можно увидеть переменные. Это поле будет автоматически обновляться по мере того, как Вы будете запускать строчки кода и создавать новые переменные. Еще там есть вкладка с историей последних команд, которые были запущены.

\textbf{4 --- Plots and files}: Здесь есть очень много всего. Во-первых, небольшой файловый менеджер, во-вторых, там будут появляться графики, когда вы будете их рисовать. Там же есть вкладка с вашими пакетами (Packages) и Help по функциям. Но об этом потом.

\hypertarget{ux432ux432ux435ux434ux435ux43dux438ux435-ux432-r}{%
\section{Введение в R}\label{ux432ux432ux435ux434ux435ux43dux438ux435-ux432-r}}

\hypertarget{calc}{%
\subsection{R как калькулятор}\label{calc}}

Ой-ей, консоль, скрипт че-то все непонятно.\\
Давайте начнем с самого простого и попробуем использовать R как простой калькулятор. \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\^{}} (степень), \texttt{()} и т.д.

Просто запускайте в консоли пока не надоест:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{40} \OperatorTok{+}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 42
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3} \OperatorTok{-}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5} \OperatorTok{*}\StringTok{ }\DecValTok{6}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 30
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{99} \OperatorTok{/}\StringTok{ }\DecValTok{9}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 11
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{^}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

Ничего сложного, верно? Вводим выражение и получаем результат. Порядок выполнения арифметических операций как в математике, так что не забывайте про скобочки. Подсказку по порядку выполнения операций в R можно получить с помощью следующей команды:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?Syntax}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Если Вы не уверены в том, какие операции имеют приоритет, то используйте скобочки, чтобы точно обозначить, в каком порядке нужно производить операции.
\end{quote}

\includegraphics[width=4.16667in,height=\textheight]{images/ThePracticalDev_2016-Apr-13.jpg}

\hypertarget{func}{%
\subsection{Функции}\label{func}}

Давайте теперь извлечем корень из какого-нибудь числа. В принципе, тем, кто помнит школьный курс математики, возведения в степень вполне достаточно:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{16} \OperatorTok{^}\StringTok{ }\FloatTok{0.5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

Ну а если нет, то можете воспользоваться специальной \textbf{функцией}: это обычно какие-то буквенные символы с круглыми скобками сразу после названия функции. Мы подаем на вход (внутрь скобочек) какие-то данные, внутри этих функций происходят какие-то вычисления, которые выдают в ответ какие-то другие данные (или же функция записывает файл, рисует график и т.д.).

Данные на входе называются \textbf{аргументом} функции, а иногда --- \textbf{параметром} функции. В обыденной речи часто говорят \textbf{инпут} (калька с английского \emph{input}).

Вот, например, функция для корня:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sqrt}\NormalTok{(}\DecValTok{16}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{quote}
R --- case-sensitive язык, т.е. регистр важен. \texttt{SQRT(16)} не будет работать.
\end{quote}

А вот так выглядит функция логарифма:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.079442
\end{verbatim}

Так, вроде бы все нормально, но\ldots{} Если Вы еще что-то помните из школьной математики, то должны понимать, что что-то здесь не так.

Здесь не хватает основания логарифма!

\begin{quote}
Логарифм --- показатель степени, в которую надо возвести число, называемое основанием, чтобы получить данное число.
\end{quote}

То есть у логарифма 8 по основанию 2 будет значение 3:

\(\log_2 8 = 3\)

То есть если возвести 2 в степень 3 у нас будет 8:

\(2^3 = 8\)

Только наша функция считает все как-то не так.

Чтобы понять, что происходит, нам нужно залезть в хэлп этой функции:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?log}
\end{Highlighting}
\end{Shaded}

Справа внизу в RStudio появится вот такое окно:

\includegraphics[width=4.16667in,height=\textheight]{images/help.png}

Действительно, у этой функции есть еще аргумент \emph{\texttt{base\ =}}. По умолчанию он равен числу Эйлера (2.7182818\ldots), т.е. функция считает натуральный логарифм.
В большинстве функций R есть какой-то основной инпут --- данные в том или ином формате, а есть и дополнительные параметры, которые можно прописывать вручную, если параметры по умолчанию вас не устраивают.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DataTypeTok{x =} \DecValTok{8}\NormalTok{, }\DataTypeTok{base =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\ldots или просто (если Вы уверены в порядке аргументов):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{8}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

Более того, Вы можете использовать результат выполнения одних функций в качестве аргумента для других:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{8}\NormalTok{, }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

Если эксплицитно писать имена аргументов, то их порядок в функции не важен:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DataTypeTok{base =} \DecValTok{2}\NormalTok{, }\DataTypeTok{x =} \DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

А еще можно недописывать имена аргументов, если они не совпадают с другими:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{x =} \DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

Мы еще много раз будем возвращаться к функциям. Вообще, функции --- это одна из важнейших штук в R (примерно так же как и в Python). Мы будем создавать свои функции, использовать функции как инпут для функций и многое-многое другое. В R очень крутые возможности работы с функциями. Поэтому подружитесь с функциями, они клевые.

\begin{quote}
Арифметические знаки, которые мы использовали: +,-,/,\^{} и т.д. называются \textbf{операторами} и на самом деле тоже являются функциями:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{'+'}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
\end{verbatim}

\hypertarget{variables}{%
\subsection{Переменные}\label{variables}}

Важная штука в программировании на практически любом языке --- возможность сохранять значения в \textbf{переменных}. В R это обычно делается с помощью вот этих символов: \texttt{\textless{}-} (но можно использовать и обычное \emph{=}, хотя это не очень принято). Для этого есть удобное сочетание клавиш: нажмите одновременно \texttt{Alt\ -} (или \texttt{option\ -} на Маке).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{2}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

Справа от \texttt{\textless{}-} находится значение, которое вы хотите сохранить, или же какое-то выражение, результат которого вы хотите сохранить в эту переменную\footnote{Есть еще оператор \texttt{-\textgreater{}}, который позволяет присваивать значения слева направо, но так делать не рекомендуется, хотя это бывает довольно удобным.}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{log}\NormalTok{(}\DecValTok{9}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Слева от \texttt{\textless{}-} находится название будущей переменной. Название переменных может быть самым разным. Есть несколько ограничений для синтаксически валидных имен переменных: они должны включать в себя буквы, цифры, \texttt{.} или \texttt{\_}, начинаться на букву (или точку, за которой не будет следовать цифра), не должны совпадать с \href{https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html}{коротким списком зарезервированных слов}. Короче говоря, название не должно включать в себя пробелы и большинство других знаков.

Нельзя:
- \texttt{new\ variable}
- \texttt{\_new\_variable}
- \texttt{.1var}
- \texttt{v-r}

Можно:
- \texttt{new\_variable}
- \texttt{.new.variable}
- \texttt{var\_2}

Обязательно делайте названия переменных осмысленными! Старайтесь делать при этом их понятными и короткими, это сохранит вам очень много времени, когда вы (или кто-то еще) будете пытаться разобраться в написанном ранее коде. Если название все-таки получается длинным и состоящим из нескольких слов, то лучше всего использовать нижнее подчеркивание в качестве разделителя: \texttt{some\_variable}\footnote{Еще иногда используются большие буквы \texttt{SomeVariable}, но это плохо читается, а иногда --- точка, но это тоже не рекомендуется.}.

После присвоения переменная появляется во вкладке \textbf{Environment} в RStudio:

\includegraphics[width=4.16667in,height=\textheight]{images/env.png}

Можно использовать переменные в функциях и просто вычислениях:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b <-}\StringTok{ }\NormalTok{a }\OperatorTok{^}\StringTok{ }\NormalTok{a }\OperatorTok{+}\StringTok{ }\NormalTok{a }\OperatorTok{*}\StringTok{ }\NormalTok{a}
\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(b, a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\hypertarget{logic}{%
\section{Логические операторы}\label{logic}}

Вы можете сравнивать разные переменные:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{==}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Заметьте, что сравнивая две переменные мы используем два знака равно \texttt{==}, а не один \texttt{=}. Иначе это будет означать присвоение.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a =}\StringTok{ }\NormalTok{b }\CommentTok{#присвоение, а не сравнение!}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

Теперь Вы сможете понять комикс про восстание роботов на следующей странице (пусть он и совсем про другой язык программирования)

\includegraphics[width=4.16667in,height=\textheight]{images/WaCM5x3mvQM.jpg}

Этот комикс объясняет, как важно не путать присваивание и сравнение \emph{(хотя я иногда путаю до сих пор =( )}.

Иногда нам нужно проверить на \emph{не}равенство:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{2}
\NormalTok{b <-}\StringTok{ }\DecValTok{3}

\NormalTok{a }\OperatorTok{==}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{!=}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Восклицательный язык в программировании вообще и в R в частности стандартно означает отрицание.

Еще мы можем сравнивать на больше/меньше:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{>}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{<}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{>=}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{<=}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Этим мы будем пользоваться в дальнейшем регулярно! Именно на таких простых логических операциях построено большинство операций с данными.

\hypertarget{data_types}{%
\section{Типы данных}\label{data_types}}

До этого момента мы работали только с числами (numeric):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

На самом деле, в R три типа numeric: integer (целые), double (дробные), complex (комплексные числа)\footnote{Комплексные числа в R пишутся так: \texttt{complexnumber\ \textless{}-\ 2+2i}. \texttt{i} здесь - это та самая мнимая единица, которая является квадратным корнем из -1.}. R сам будет конвертировать числа в нужный тип numeric при необходимости, поэтому этим можно не заморачиваться.

Если же все-таки нужно задать конкретный тип числа эксплицитно, то можно воспользоваться функциями \texttt{as.integer()}, \texttt{as.double()} и \texttt{as.complex()}. Кроме того, при создании числа можно поставить в конце \texttt{L}, чтобы обозначить число как integer:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.integer}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.integer}\NormalTok{(5L)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Про double есть еще один маленький секрет. Дело в том, что дробные числа хранятся в R как \href{https://ru.wikipedia.org/wiki/Число_двойной_точности}{числа с плавающей запятой двойной точности}. Дробные числа в компьютере могут быть записаны только с определенной степенью точности, поэтому иногда встречаются вот такие вот ситуации:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{^}\DecValTok{2} \OperatorTok{==}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Это довольно стандартная ситуация, характерная не только для R. Чтобы ее избежать, можно воспользоваться функцией \texttt{all.equal()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{^}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Теперь же нам нужно ознакомиться с двумя другими важными типами данных в R:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{character}: строки символов. Они должны выделяться кавычками.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s <-}\StringTok{ 'Всем привет!'}
\NormalTok{s}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Всем привет!"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

Можно использовать как \texttt{"}, так и \texttt{\textquotesingle{}} (что удобно, когда строчка внутри уже содержит какие-то кавычки).

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{logical}: просто \texttt{TRUE} или \texttt{FALSE}.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 <-}\StringTok{ }\OtherTok{TRUE}
\NormalTok{f1 <-}\StringTok{ }\OtherTok{FALSE}

\NormalTok{t1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Вообще, можно еще писать \texttt{T} и \texttt{F} (но не \texttt{True} и \texttt{False}!).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t2 <-}\StringTok{ }\NormalTok{T}
\NormalTok{f2 <-}\StringTok{ }\NormalTok{F}
\end{Highlighting}
\end{Shaded}

Это дурная практика, так как R защищает от перезаписи переменные \texttt{TRUE} и \texttt{FALSE}, но не защищает от этого \texttt{T} и \texttt{F}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE}\NormalTok{ <-}\StringTok{ }\OtherTok{FALSE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in TRUE <- FALSE: invalid (do_set) left-hand side to assignment
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{T <-}\StringTok{ }\OtherTok{FALSE}
\NormalTok{T}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Мы уже встречались с логическими значениями при сравнении двух числовых переменных. Теперь вы можете догадаться, что результаты сравнения, например, числовых или строковых переменных, можно тоже сохранять в переменные!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{comparison <-}\StringTok{ }\NormalTok{a }\OperatorTok{==}\StringTok{ }\NormalTok{b}
\NormalTok{comparison}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Это нам очень понадобится, когда мы будем работать с реальными данными: нам нужно будет постоянно вытаскивать какие-то данные из датасета, что как раз и построено на игре со сравнением переменных.

Чтобы этим хорошо уметь пользоваться, нам нужно еще освоить как работать с логическими операторами. Про один мы немного уже говорили --- это логическое НЕ (\texttt{!}). \texttt{!} превращает \texttt{TRUE} в \texttt{FALSE}, а \texttt{FALSE} в \texttt{TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{!}\NormalTok{t1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{!!}\NormalTok{t1 }\CommentTok{#Двойное отрицание!}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Еще есть логическое И (выдаст \texttt{TRUE} только в том случае если обе переменные \texttt{TRUE}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 }\OperatorTok{&}\StringTok{ }\NormalTok{t2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 }\OperatorTok{&}\StringTok{ }\NormalTok{f1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

А еще логическое ИЛИ (выдаст \texttt{TRUE} в случае если хотя бы одна из переменных \texttt{TRUE}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 }\OperatorTok{|}\StringTok{ }\NormalTok{f1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 }\OperatorTok{|}\StringTok{ }\NormalTok{f2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Если кому-то вдруг понадобится другое ИЛИ (строгое ЛИБО) --- есть функция \texttt{xor()}, принимающая два аргумента.

Итак, мы только что разобрались с самой занудной (хотя и важной) частью - с основными типа данных в R и как с ними работать\footnote{Кроме описанных пяти типов данных (integer, double, complex, character и logical) есть еще и шестой --- это raw, сырая последовательность байтов, но нам она не понадобится.}. Пора переходить к чему-то более интересному и специфическому для R. Вперед к ВЕКТОРАМ!

\hypertarget{atomic}{%
\section{Вектор}\label{atomic}}

Если у вас не было линейной алгебры (или у вас с ней было все плохо), то просто запомните, что \textbf{вектор} (или \textbf{atomic vector} или \textbf{atomic}) --- это набор (столбик) чисел в определенном порядке.

Если вы привыкли из школьного курса физики считать вектора стрелочками, то не спешите возмущаться и паниковать. Представьте стрелочки как точки из нуля координат \{0,0\} до какой-то точки на координатной плоскости, например, \{2,3\}:

\includegraphics[width=4.16667in,height=\textheight]{images/coord_vector.png}

Вот последние два числа и будем считать вектором. Попытайтесь теперь мысленно стереть координатную плоскость и выбросить стрелочки из головы, оставив только последовательность чисел \{2,3\}:

\includegraphics[width=4.16667in,height=\textheight]{images/coord_vector_blur.png}

На самом деле, мы уже работали с векторами в R, но, возможно, вы об этом даже не догадывались. Дело в том, что в R нет как таковых ``значений'', \textbf{есть вектора длиной 1}. Такие дела!

Чтобы создать вектор из нескольких значений, нужно воспользоваться функцией \emph{\texttt{c()}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{16}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{42}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4  8 15 16 23 42
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\StringTok{"Хэй"}\NormalTok{, }\StringTok{"Хэй"}\NormalTok{, }\StringTok{"Ха"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Хэй" "Хэй" "Ха"
\end{verbatim}

\begin{quote}
Одна из самых мерзких и раздражающих причин ошибок в коде --- это использование \texttt{с} из кириллицы вместо \texttt{c} из латиницы. Видите разницу? И я не вижу. А R видит. И об этом сообщает:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{с(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in с(3, 4, 5): could not find function "с"
\end{verbatim}

Для создания числовых векторов есть удобный \textbf{оператор} \texttt{:}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5}\OperatorTok{:-}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  5  4  3  2  1  0 -1 -2 -3
\end{verbatim}

Этот оператор создает вектор от первого числа до второго с шагом 1. Вы не представляете, как часто эта штука нам пригодится\ldots{} Если же нужно сделать вектор с другим шагом, то есть функция \texttt{seq()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DataTypeTok{by =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  10  20  30  40  50  60  70  80  90 100
\end{verbatim}

Кроме того, можно задавать не шаг, а длину вектора. Тогда шаг функция \texttt{seq()} посчитает сама:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  5  9 13
\end{verbatim}

Другая функция --- \texttt{rep()} --- позволяет создавать вектора с повторяющимися значениями. Первый аргумент --- значение, которое нужно повторять, а второй аргумент --- сколько раз повторять.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 1 1 1 1
\end{verbatim}

И первый, и второй аргумент могут быть векторами!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 1 2 3 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 2 3 3 3
\end{verbatim}

Еще можно объединять вектора (что мы, по сути, и делали, просто с векторами длиной 1):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Hey"}\NormalTok{, }\StringTok{"Ho"}\NormalTok{)}
\NormalTok{v2 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Let's"}\NormalTok{, }\StringTok{"Go!"}\NormalTok{)}
\KeywordTok{c}\NormalTok{(v1, v2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hey"   "Ho"    "Let's" "Go!"
\end{verbatim}

\hypertarget{coercion}{%
\subsection{Приведение типов}\label{coercion}}

Что будет, если вы объедините два вектора с значениями разных типов? Ошибка?

Мы уже обсуждали, что в \emph{atomic} может быть только один тип данных. В некоторых языках программирования при операции с данными разных типов мы бы получили ошибку. А вот в R при несовпадении типов пройзойдет попытка привести типы к ``общему знаменателю'', то есть конвертировать данные в более ``широкий'' тип.

Например:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 2
\end{verbatim}

\texttt{FALSE} превратился в \texttt{0} (а \texttt{TRUE} превратился бы в \texttt{1}), чтобы оба значения можно было объединить в вектор. То же самое произошло бы в случае операций с векторами:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{+}\StringTok{ }\OtherTok{TRUE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

Это называется \textbf{неявным приведением типов (implicit coercion)}.

Вот более сложный пример:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\DecValTok{3}\NormalTok{, }\StringTok{"Привет"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "TRUE"   "3"      "Привет"
\end{verbatim}

У R есть иерархия приведения типов:

\texttt{NULL\ \textless{}\ raw\ \textless{}\ logical\ \textless{}\ integer\ \textless{}\ double\ \textless{}\ complex\ \textless{}\ character\ \textless{}\ list\ \textless{}\ expression}.

Мы из этого списка еще многого не знаем, сейчас важно запомнить, что логические данные --- \texttt{TRUE} и \texttt{FALSE} --- превращаются в \texttt{0} и \texttt{1} соответственно, а \texttt{0} и \texttt{1} в строчки \texttt{"0"} и \texttt{"1"}.

Если Вы боитесь полагаться на приведение типов, то можете воспользоваться функциями \texttt{as.нужныйтипданных} для явного приведения типов (\textbf{explicit coercion}):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, F, F))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 0 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(}\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, F, F)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "0" "0" "0"
\end{verbatim}

Можно превращать и обратно, например, строковые значения в числовые. Если среди числа встретится буква или другой неподходящий знак, то мы получим предупреждение \texttt{NA} --- пропущенное значение (мы очень скоро научимся с ними работать).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"1"}\NormalTok{, }\StringTok{"2"}\NormalTok{, }\StringTok{"три"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: NAs introduced by coercion
\end{verbatim}

\begin{verbatim}
## [1]  1  2 NA
\end{verbatim}

\begin{quote}
Один из распространенных примеров использования неявного приведения типов --- использования функций \texttt{sum()} и \texttt{mean()} для подсчета в логическом векторе количества и доли \texttt{TRUE} соответсвенно. Мы будем много раз пользоваться этим приемом в дальнейшем!
\end{quote}

\hypertarget{vector_op}{%
\subsection{Векторизация}\label{vector_op}}

Все те арифметические операторы, что мы использовали ранее, можно использовать с векторами одинаковой длины:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{4}
\NormalTok{m <-}\StringTok{ }\DecValTok{4}\OperatorTok{:}\DecValTok{1}
\NormalTok{n }\OperatorTok{+}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5 5 5 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{-}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -3 -1  1  3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{*}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 6 6 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{/}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.2500000 0.6666667 1.5000000 4.0000000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{^}\StringTok{ }\NormalTok{m }\OperatorTok{+}\StringTok{ }\NormalTok{m }\OperatorTok{*}\StringTok{ }\NormalTok{(n }\OperatorTok{-}\StringTok{ }\NormalTok{m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -11   5  11   7
\end{verbatim}

Если применить операторы на двух векторах одинаковой длины, то мы получим результат поэлементного применения оператора к двум векторам. Это называется \textbf{векторизацией} (\textbf{vectorization}).

\begin{quote}
Если после какого-нибудь MATLAB Вы привыкли, что по умолчанию операторы работают по правилам линейной алгебры и \texttt{m*n} будет давать скалярное произведение (\emph{dot product}), то снова нет. Для скалярного произведения нужно использовать операторы с \texttt{\%} по краям:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{%*%}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1]
## [1,]   20
\end{verbatim}

\begin{quote}
Абсолютно так же и с операциями с матрицами в R, хотя про матрицы будет немного позже.
\end{quote}

В принципе, большинство функций в R, которые работают с отдельными значениями, так же хорошо работают и с целыми векторами. Скажем, Вы хотите извлечь корень из нескольких чисел, для этого не нужны никакие циклы (как это обычно делается в других языках программирования). Можно просто ``скормить'' вектор функции и получить результат применения функции к каждому элементу вектора:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sqrt}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
##  [9] 3.000000 3.162278
\end{verbatim}

Таких векторизованных функций в R очень много. Многие из них написаны на более низкоуровневых языках программирования (C, C++, FORTRAN), за счет чего использование таких функций приводит не только к более элегантному, лаконичному, но и к более быстрому коду.

\begin{quote}
Векторизация в R --- это очень важная фишка, которая отличает этот язык программирования от многих других. Если вы уже имеете опыт программирования на другом языке, то вам во многих задачах захочется использовать циклы типа \texttt{for} и \texttt{while} \ref{for}. Не спешите этого делать! В очень многих случаях циклы можно заменить векторизацией. Тем не менее, векторизация --- это не единственный способ избавить от циклов типа \texttt{for} и \texttt{while} \ref{apply}.
\end{quote}

\hypertarget{recycling}{%
\subsection{Ресайклинг}\label{recycling}}

Допустим мы хотим совершить какую-нибудь операцию с двумя векторами. Как мы убедились, с этим обычно нет никаких проблем, если они совпадают по длине. А что если вектора не совпадают по длине?
Ничего страшного! Здесь будет работать правило \textbf{ресайклинга} (\emph{правило переписывания, recycling rule}). Это означает, что если мы делаем операцию на двух векторах разной длины, то если короткий вектор кратен по длине длинному, короткий вектор будет повторяться необходимое количество раз:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{4}
\NormalTok{m <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{2}
\NormalTok{n }\OperatorTok{*}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 4 3 8
\end{verbatim}

А что будет, если совершать операции с вектором и отдельным значением? Можно считать это частным случаем ресайклинга: короткий вектор длиной 1 будет повторятся столько раз, сколько нужно, чтобы он совпадал по длине с длинным:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 4 6 8
\end{verbatim}

Если же меньший вектор не кратен большему (например, один из них длиной 3, а другой длиной 4), то R посчитает результат, но выдаст предупреждение.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{+}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in n + c(3, 4, 5): longer object length is not a multiple of shorter
## object length
\end{verbatim}

\begin{verbatim}
## [1] 4 6 8 7
\end{verbatim}

Проблема в том, что эти предупреждения могут в неожиданный момент стать причиной ошибок. Поэтому не стоит полагаться на ресайклинг некратных по длине векторов. \href{https://stackoverflow.com/questions/6555651/under-what-circumstances-does-r-recycle}{См. здесь}. А вот ресайклинг кратных по длине векторов --- это очень удобная штука, которая используется очень часто.

\hypertarget{index_atomic}{%
\subsection{Индексирование векторов}\label{index_atomic}}

Итак, мы подошли к одному из самых сложных моментов. И одному из основных. От того, как хорошо вы научись с этим работать, зависит весь Ваш дальнейший успех на R-поприще!

Речь пойдет об \textbf{индексировании} векторов. Задача, которую Вам придется решать каждые пять минут работы в R - как выбрать из вектора (или же списка, матрицы и датафрейма) какую-то его часть. Для этого используются квадратные скобочки \texttt{{[}{]}} (не круглые - они для функций!).\\
Самое простое - индексировать по номеру индекса, т.е. порядку значения в векторе.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{n[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10
\end{verbatim}

\begin{quote}
Если вы знакомы с другими языками программирования (не MATLAB, там все так же) и уже научились думать, что индексация с 0 --- это очень удобно и очень правильно (ну или просто свыклись с этим), то в R Вам придется переучиться обратно. Здесь первый индекс --- это 1, а последний равен длине вектора --- ее можно узнать с помощью функции \texttt{length()}. С обоих сторон индексы берутся включительно.
\end{quote}

С помощью индексирования можно не только вытаскивать имеющиеся значения в векторе, но и присваивать им новые:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\DecValTok{3}\NormalTok{] <-}\StringTok{ }\DecValTok{20}
\NormalTok{n}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2 20  4  5  6  7  8  9 10
\end{verbatim}

Конечно, можно использовать целые векторы для индексирования:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\DecValTok{4}\OperatorTok{:}\DecValTok{7}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 5 6 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\DecValTok{10}\OperatorTok{:}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 10  9  8  7  6  5  4 20  2  1
\end{verbatim}

Индексирование с минусом выдаст вам все значения вектора кроме выбранных:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  2 20  4  5  6  7  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{4}\NormalTok{, }\DecValTok{-5}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  2 20  6  7  8  9 10
\end{verbatim}

Минус здесь ``выключает'' выбранные значения из вектора, а не означает отсчет с конца как в Python.

Более того, можно использовать логический вектор для индексирования. В этом случае нужен логический вектор такой же длины:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1 20  5  7  9
\end{verbatim}

Логический вектор работает здесь как фильтр: пропускает только те значения, где на соответствующей позиции в логическом векторе для индексирования содержится \texttt{TRUE}, и не пропускает те значения, где на соответствующей позиции в логическом векторе для индексирования содержится \texttt{FALSE}.

\includegraphics{images/indexgandolf.png}

Ну а если эти два вектора (исходный вектор и логический вектор индексов) не равны по длине, то тут будет снова работать правило ресайклинга!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)] }\CommentTok{#то же самое - recycling rule!}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1 20  5  7  9
\end{verbatim}

Есть еще один способ индексирования векторов, но он несколько более редкий: индексирование по имени. Дело в том, что для значений векторов можно (но не обязательно) присваивать имена:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_named_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{first =} \DecValTok{1}\NormalTok{,}
                     \DataTypeTok{second =} \DecValTok{2}\NormalTok{,}
                     \DataTypeTok{third =} \DecValTok{3}\NormalTok{)}
\NormalTok{                     my_named_vector[}\StringTok{'first'}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## first 
##     1
\end{verbatim}

А еще можно ``вытаскивать'' имена из вектора с помощью функции \texttt{names()} и присваивать таким образом новые имена.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{4}
\KeywordTok{names}\NormalTok{(d) <-}\StringTok{ }\NormalTok{letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{]}
\NormalTok{d[}\StringTok{"a"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## a 
## 1
\end{verbatim}

\begin{quote}
\texttt{letters} - это ``зашитая'' в R константа - вектор букв от a до z. Иногда это очень удобно! Кроме того, есть константа \texttt{LETTERS} - то же самое, но заглавными буквами. А еще в R есть названия месяцев на английском и числовая константа \texttt{pi}.
\end{quote}

Теперь посчитаем среднее вектора \texttt{n}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7.2
\end{verbatim}

А как вытащить все значения, которые больше среднего?

Сначала получим логический вектор --- какие значения больше среднего:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{larger <-}\StringTok{ }\NormalTok{n }\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(n)}
\NormalTok{larger}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE
\end{verbatim}

А теперь используем его для индексирования вектора \texttt{n}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[larger]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 20  8  9 10
\end{verbatim}

Можно все это сделать в одну строчку:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[n}\OperatorTok{>}\KeywordTok{mean}\NormalTok{(n)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 20  8  9 10
\end{verbatim}

Предыдущая строчка отражает то, что мы будем постоянно делать в R: вычленять (subset) из данных отдельные куски на основании разных условий.

\hypertarget{na}{%
\subsection{NA --- пропущенные значения}\label{na}}

В реальных данных у нас часто чего-то не хватает. Например, из-за технической ошибки или невнимательности не получилось записать какое-то измерение. Для обозначения пропущенных значений в R есть специальное значение \texttt{NA}. \texttt{NA} --- это не строка \texttt{"NA"}, не \texttt{0}, не пустая строка \texttt{""} и не \texttt{FALSE}. \texttt{NA} --- это \texttt{NA}.
Большинство операций с векторами, содержащими \texttt{NA} будут выдавать \texttt{NA}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{missed <-}\StringTok{ }\OtherTok{NA}
\NormalTok{missed }\OperatorTok{==}\StringTok{ "NA"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{missed }\OperatorTok{==}\StringTok{ ""}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{missed }\OperatorTok{==}\StringTok{ }\OtherTok{NA}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

Заметьте: даже сравнение \texttt{NA} c \texttt{NA} выдает \texttt{NA}!

Иногда \texttt{NA} в данных очень бесит:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\DecValTok{5}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{n}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2 20  4 NA  6  7  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

Что же делать?\\
Наверное, надо сравнить вектор с \texttt{NA} и исключить этих пакостников. Давайте попробуем:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{==}\StringTok{ }\OtherTok{NA}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] NA NA NA NA NA NA NA NA NA NA
\end{verbatim}

Ах да, мы ведь только что узнали, что даже сравнение \texttt{NA} c \texttt{NA} приводит к \texttt{NA}!

Чтобы выбраться из этой непростой ситуации, используйте функцию \texttt{is.na()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.na}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
\end{verbatim}

Результат выполнения \texttt{is.na(n)} выдает \texttt{FALSE} в тех местах, где у нас числа и \texttt{TRUE} там, где у нас \texttt{NA}. Чтобы вычленить из вектора \texttt{n} все значения кроме \texttt{NA} нам нужно, чтобы было наоборот: \texttt{TRUE}, если это не \texttt{NA}, \texttt{FALSE}, если это \texttt{NA}. Здесь нам понадобится логический оператор НЕ \texttt{!} (мы его уже встречали), который инвертирует логические значения:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(n)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  2 20  4  6  7  8  9 10
\end{verbatim}

Ура, мы можем считать среднее!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(n[}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(n)])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7.444444
\end{verbatim}

Теперь Вы понимаете, зачем нужно отрицание (\texttt{!})

Вообще, есть еще один из способов посчитать среднее, если есть \texttt{NA}. Для этого надо залезть в хэлп по функции \emph{mean()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?}\KeywordTok{mean}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

В хэлпе мы найдем параметр \texttt{na.rm\ =}, который по умолчанию \texttt{FALSE}. Вы знаете, что нужно делать!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(n, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7.444444
\end{verbatim}

\begin{quote}
\texttt{NA} может появляться в векторах других типов тоже. На самом деле, \texttt{NA} - это специальное значение в логических векторах, тогда как в векторах других типов \texttt{NA} появляется как \texttt{NA\_integer\_}, \texttt{NA\_real\_}, \texttt{NA\_complex\_} или \texttt{NA\_character\_}, но R обычно сам все переводит в нужный формат и показывает как просто \texttt{NA}.\\
Кроме \texttt{NA} есть еще \texttt{NaN} --- это разные вещи. \texttt{NaN} расшифровывается как Not a Number и получается в результате таких операций как \texttt{0/0}.
\end{quote}

\hypertarget{google}{%
\subsection{В любой непонятной ситуации --- ищите в поисковике}\label{google}}

Если вдруг вы не знаете, что искать в хэлпе, или хэлпа попросту недостаточно, то ищите в поисковике!

\includegraphics[width=4.16667in,height=\textheight]{images/2AmXWgVoULk.jpg}

Нет ничего постыдного в том, чтобы искать в Интернете решения проблем. Это абсолютно нормально. Используйте силу интернета во благо и да помогут вам \emph{Stackoverflow} и бесчисленные R-туториалы!

Computer Programming To Be Officially Renamed ``Googling Stack Overflow''Source: http://t.co/xu7acfXvFF pic.twitter.com/iJ9k7aAVhd

--- Stack Exchange July 20, 2015

Главное, помните: загуглить работающий ответ всегда недостаточно. Надо понять, как и почему он работает. Иначе что-то обязательно пойдет не так.

Кроме того, правильно загуглить проблему --- не так уж и просто.

Does anyone ever get good at R or do they just get good at googling how to do things in R

--- 🔬🖤Lauren M. Seyler, Ph.D.❤️⚒ href=``\url{https://twitter.com/mousquemere/status/1125522375141883907?ref_src=twsrc\%5Etfw}''\textgreater May 6, 2019

\includegraphics[width=4.16667in,height=\textheight]{images/doctors-googling-stuff-online-does-not-make-you-a-doctor-programmers-confused.jpg}

Итак, с векторами мы более-менее разобрались. Помните, что вектора --- это один из краеугольных камней Вашей работы в R. Если Вы хорошо с ними разобрались, то дальше все будет довольно несложно. Тем не менее, вектора --- это не все. Есть еще два важных типа данных: списки (\textbf{list}) и матрицы (\textbf{matrix}). Их можно рассматривать как своеобразное ``расширение'' векторов, каждый в свою сторону. Ну а списки и матрицы нужны чтобы понять основной тип данных в R --- \textbf{data.frame}.

\includegraphics[width=4.16667in,height=\textheight]{images/New-Mind-Map.jpg}

\hypertarget{matrix}{%
\section{Матрицы (matrix)}\label{matrix}}

Если вдруг Вас пугает это слово, то совершенно зря. Матрица --- это всего лишь ``двумерный'' вектор: вектор, у которого есть не только длина, но и ширина. Создать матрицу можно с помощью функции \texttt{matrix()} из вектора, указав при этом количество строк и столбцов.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DataTypeTok{nrow=}\DecValTok{5}\NormalTok{,}\DataTypeTok{ncol=}\DecValTok{4}\NormalTok{)}
\NormalTok{A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
\end{verbatim}

\begin{quote}
Заметьте, значения вектора заполняются следующим образом: сначала заполняется первый столбик сверху вниз, потом второй сверху вниз и так до конца, т.е. заполнение значений матрицы идет в первую очередь по вертикали. Это довольно стандартный способ создания матриц, характерный не только для R.
\end{quote}

Если мы знаем сколько значений в матрице и сколько мы хотим строк, то количество столбцов указывать необязательно:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DataTypeTok{nrow=}\DecValTok{5}\NormalTok{)}
\NormalTok{A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
\end{verbatim}

Все остальное так же как и с векторами: внутри находится данные только одного типа. Поскольку матрица --- это уже двумерный массив, то у него имеется два индекса. Эти два индекса разделяются запятыми.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[}\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    2    7   12
## [2,]    3    8   13
## [3,]    4    9   14
\end{verbatim}

Первый индекс --- выбор строк, второй индекс --- выбор колонок. Если же мы оставляем пустое поле вместо числа, то мы выбираем все строки/колонки в зависимости от того, оставили мы поле пустым до или после запятой:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[,}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    6   11
## [2,]    2    7   12
## [3,]    3    8   13
## [4,]    4    9   14
## [5,]    5   10   15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[}\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    2    7   12   17
## [2,]    3    8   13   18
## [3,]    4    9   14   19
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
\end{verbatim}

Если мы выберем только одну колонку/строчку, то на выходе получим уже вектор, а не матрицу:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  2  7 12 17
\end{verbatim}

Это называется ``схлопыванием размерности''. Чтобы этого избежать, нужно поставить \texttt{drop\ =\ FALSE} после второй запятой внутри квадратных скобок.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[}\DecValTok{2}\NormalTok{,, drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    2    7   12   17
\end{verbatim}

Для соединения двух или более матриц можно воспользоваться функциями \texttt{rbind()} и \texttt{cbind()} для соединения матриц по вертикали и по горизонтали соответственно.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rbind}\NormalTok{(A, A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       [,1] [,2] [,3] [,4]
##  [1,]    1    6   11   16
##  [2,]    2    7   12   17
##  [3,]    3    8   13   18
##  [4,]    4    9   14   19
##  [5,]    5   10   15   20
##  [6,]    1    6   11   16
##  [7,]    2    7   12   17
##  [8,]    3    8   13   18
##  [9,]    4    9   14   19
## [10,]    5   10   15   20
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cbind}\NormalTok{(A, A)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
## [1,]    1    6   11   16    1    6   11   16
## [2,]    2    7   12   17    2    7   12   17
## [3,]    3    8   13   18    3    8   13   18
## [4,]    4    9   14   19    4    9   14   19
## [5,]    5   10   15   20    5   10   15   20
\end{verbatim}

В принципе, это все, что нам нужно знать о матрицах. Матрицы используются в R довольно редко, особенно по сравнению, например, с MATLAB. Но вот индексировать матрицы хорошо бы уметь: это понадобится в работе с датафреймами.

\begin{quote}
То, что матрица - это просто двумерный вектор, не является метафорой: в R матрица - это по сути своей вектор с дополнительными \emph{атрибутами} \texttt{dim} и \texttt{dimnames}. Атрибуты --- это неотъемлемые свойства объектов, для всех объектов есть обязательные атрибуты типа и длины и могут быть любые необязательные атрибуты. Можно задавать свои атрибуты или удалять уже присвоенные: удаление атрибута \texttt{dim} у матрицы превратит ее в обычный вектор. Про атрибуты подробнее можно почитать \href{https://perso.esiee.fr/~courivad/R/06-objects.html}{здесь} или на стр. 99--101 книги ``R in a Nutshell'' \citep{adler2010r}.
\end{quote}

\hypertarget{list}{%
\section{Списки (list)}\label{list}}

Теперь представим себе вектор без ограничения на одинаковые данные внутри. И получим список!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_list <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{42}\NormalTok{, }\StringTok{"Пам пам"}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\NormalTok{simple_list}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 42
## 
## [[2]]
## [1] "Пам пам"
## 
## [[3]]
## [1] TRUE
\end{verbatim}

А это значит, что там могут содержаться самые разные данные, в том числе и другие списки и векторы!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{complex_list <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Wow"}\NormalTok{, }\StringTok{"this"}\NormalTok{, }\StringTok{"list"}\NormalTok{, }\StringTok{"is"}\NormalTok{, }\StringTok{"so"}\NormalTok{, }\StringTok{"big"}\NormalTok{), }\StringTok{"16"}\NormalTok{, simple_list)}
\NormalTok{complex_list}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "Wow"  "this" "list" "is"   "so"   "big" 
## 
## [[2]]
## [1] "16"
## 
## [[3]]
## [[3]][[1]]
## [1] 42
## 
## [[3]][[2]]
## [1] "Пам пам"
## 
## [[3]][[3]]
## [1] TRUE
\end{verbatim}

Если у нас сложный список, то есть очень классная функция, чтобы посмотреть, как он устроен, под названием \texttt{str()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(complex_list)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 3
##  $ : chr [1:6] "Wow" "this" "list" "is" ...
##  $ : chr "16"
##  $ :List of 3
##   ..$ : num 42
##   ..$ : chr "Пам пам"
##   ..$ : logi TRUE
\end{verbatim}

Как и в случае с векторами мы можем давать имена элементам списка:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{named_list <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{age =} \DecValTok{24}\NormalTok{, }\DataTypeTok{phd_student =}\NormalTok{ T, }\DataTypeTok{language =} \StringTok{"Russian"}\NormalTok{)}
\NormalTok{named_list}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $age
## [1] 24
## 
## $phd_student
## [1] FALSE
## 
## $language
## [1] "Russian"
\end{verbatim}

К списку можно обращаться как с помощью индексов, так и по именам. Начнем с последнего:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{named_list}\OperatorTok{$}\NormalTok{age}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 24
\end{verbatim}

А вот с индексами сложнее, и в этом очень легко запутаться. Давайте попробуем сделать так, как мы делали это раньше:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{named_list[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $age
## [1] 24
\end{verbatim}

Мы, по сути, получили элемент списка - просто как часть списка, т.е. как список длиной один:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(named_list)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(named_list[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

А вот чтобы добраться до самого элемента списка (и сделать с ним что-то хорошее) нам нужна не одна, а две квадратных скобочки:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{named_list[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 24
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(named_list[[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

Indexing lists in \#rstats. Inspired by the Residence Inn pic.twitter.com/YQ6axb2w7t

--- Hadley Wickham (@ href=``\url{https://twitter.com/hadleywickham/status/643381054758363136?ref_src=twsrc\%5Etfw}''\textgreater September 14, 2015

Как и в случае с вектором, к элементу списка можно обращаться по имени.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{named_list[[}\StringTok{'age'}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 24
\end{verbatim}

Хотя последнее --- практически то же самое, что и использование знака \$.

\begin{quote}
Списки довольно часто используются в R, но реже, чем в Python. Со многими объектами в R, такими как результаты статистических тестов, объекты ggplot и т.д. удобно работать именно как со списками --- к ним все вышеописанное применимо. Кроме того, некоторые данные мы изначально получаем в виде древообразной структуры --- хочешь не хочешь, а придется работать с этим как со списком. Особенно это характерно для данных, выкачанных из веб-страниц (HTML страницы, XML данные) или полученных с помощью API различных веб-сайтов (например, в формате JSON). Но обычно после этого стоит как можно скорее превратить список в датафрейм.
\end{quote}

\hypertarget{df}{%
\section{Датафрейм}\label{df}}

Итак, мы перешли к самому главному. Самому-самому. Датафреймы (\textbf{data.frames}). Более того, сейчас станет понятно, зачем нам нужно было разбираться со всеми предыдущими темами.

Без векторов мы не смогли бы разобраться с матрицами и списками. А без последних мы не сможем понять, что такое датафрейм.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{name <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Ivan"}\NormalTok{, }\StringTok{"Eugeny"}\NormalTok{, }\StringTok{"Lena"}\NormalTok{, }\StringTok{"Misha"}\NormalTok{, }\StringTok{"Sasha"}\NormalTok{) }
\NormalTok{age <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{26}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{26}\NormalTok{) }
\NormalTok{student <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{) }
\NormalTok{df =}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(name, age, student)  }
\NormalTok{df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     name age student
## 1   Ivan  26   FALSE
## 2 Eugeny  34   FALSE
## 3   Lena  23    TRUE
## 4  Misha  27    TRUE
## 5  Sasha  26    TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    5 obs. of  3 variables:
##  $ name   : chr  "Ivan" "Eugeny" "Lena" "Misha" ...
##  $ age    : num  26 34 23 27 26
##  $ student: logi  FALSE FALSE TRUE TRUE TRUE
\end{verbatim}

Вообще, очень похоже на список, не правда ли? Так и есть, датафрейм --- это что-то вроде проименованного списка, каждый элемент которого является atomic вектором фиксированной длины. Скорее всего, список Вы представляли ``горизонтально''. Если это так, то теперь ``переверните'' его у себя в голове. Так, чтоб названия векторов оказались сверху, а колонки стали столбцами. Поскольку длина всех этих векторов равна (обязательное условие!), то данные представляют собой табличку, похожую на матрицу. Но в отличие от матрицы, разные столбцы могут имет разные типы данных: первая колонка --- character, вторая колонка --- numeric, третья колонка --- logical. Тем не менее, обращаться с датафреймом можно и как с проименованным списком, и как с матрицей:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\OperatorTok{$}\NormalTok{age[}\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 34 23
\end{verbatim}

Здесь мы сначала вытащили колонку \texttt{age} с помощью оператора \texttt{\$}. Результатом этой операции является числовой вектор, из которого мы вытащили кусок, выбрав индексы \texttt{2} и \texttt{3}.

Используя оператор \texttt{\$} и присваивание можно создавать новые колонки датафрейма:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\OperatorTok{$}\NormalTok{lovesR <-}\StringTok{ }\OtherTok{TRUE} \CommentTok{#правило recycling - узнали? }
\NormalTok{df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     name age student lovesR
## 1   Ivan  26   FALSE   TRUE
## 2 Eugeny  34   FALSE   TRUE
## 3   Lena  23    TRUE   TRUE
## 4  Misha  27    TRUE   TRUE
## 5  Sasha  26    TRUE   TRUE
\end{verbatim}

Ну а можно просто обращаться с помощью двух индексов через запятую, как мы это делали с матрицей:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\DecValTok{3}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   age student
## 3  23    TRUE
## 4  27    TRUE
## 5  26    TRUE
\end{verbatim}

Как и с матрицами, первый индекс означает строчки, а второй --- столбцы.

А еще можно использовать названия колонок внутри квадратных скобок:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{,}\StringTok{"age"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 26 34
\end{verbatim}

И здесь перед нами открываются невообразимые возможности! Узнаем, любят ли R те, кто моложе среднего возраста в группе:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[df}\OperatorTok{$}\NormalTok{age }\OperatorTok{<}\StringTok{ }\KeywordTok{mean}\NormalTok{(df}\OperatorTok{$}\NormalTok{age), }\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE TRUE TRUE TRUE
\end{verbatim}

Эту же задачу можно выполнить другими способами:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\OperatorTok{$}\NormalTok{lovesR[df}\OperatorTok{$}\NormalTok{age }\OperatorTok{<}\StringTok{ }\KeywordTok{mean}\NormalTok{(df}\OperatorTok{$}\NormalTok{age)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE TRUE TRUE TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[df}\OperatorTok{$}\NormalTok{age }\OperatorTok{<}\StringTok{ }\KeywordTok{mean}\NormalTok{(df}\OperatorTok{$}\NormalTok{age), }\StringTok{'lovesR'}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE TRUE TRUE TRUE
\end{verbatim}

В большинстве случаев подходят сразу несколько способов --- тем не менее, стоит овладеть ими всеми.

Датафреймы удобно просматривать в RStudio. Для это нужно написать команду \texttt{View(df)} или же просто нажать на названии нужной переменной из списка вверху справа (там где Environment). Тогда увидите табличку, очень похожую на Excel и тому подобные программы для работы с таблицами. Там же есть и всякие возможности для фильтрации, сортировки и поиска\ldots{} Но, конечно, интереснее все эти вещи делать руками, т.е. с помощью написания кода.

На этом пора заканчивать с введением и приступать к реальным данным.

\hypertarget{real_data}{%
\chapter{Импорт данных}\label{real_data}}

Итак, пришло время перейти к реальным данным. Мы начнем с использования датасета (так мы будем называть любой набор данных) по супергероям. Этот датасет представляет собой табличку, каждая строка которой - отдельный супергерой, а столбик --- какая-либо информация о нем. Например, цвет глаз, цвет волос, вселенная супергероя\footnote{супергерои в комиксах, фильмах и телесериалах часто взаимодействуют друг с другом, однако обычно это взаимодействие происходит между супергероями одного издателя. Два крупнейших издателя комиксов --- DC и Marvel, поэтому принято говорить о вселенной DC и Marvel.}, рост, вес, пол и так далее. Несложно заметить, что этот датасет идеально подходит под структуру датафрейма: прямоугольная табличка, внутри которой есть разные колонки, каждая из которой имеет свой тип (числовой или строковый).

\hypertarget{wd}{%
\section{Рабочая папка и проекты RStudio}\label{wd}}

Для начала скачайте файл по \href{https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/heroes_information.csv}{ссылке}

Он, скорее всего, появился у Вас в папке ``Загрузки''. Если мы будем просто пытаться прочитать этот файл (например, с помощью \texttt{read.csv()} --- мы к этой функцией очень скоро перейдем), указав его имя и разрешение, то наткнемся на такую ошибку:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{read.csv}\NormalTok{(}\StringTok{"heroes_information.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in file(file, "rt"): cannot open file 'heroes_information.csv': No such
## file or directory
\end{verbatim}

\begin{verbatim}
## Error in file(file, "rt"): cannot open the connection
\end{verbatim}

Это означает, что R не может найти нужный файл. Вообще-то мы даже не сказали, где искать. Нам нужно как-то совместить место, где R ищет загружаемые файлы и сами файлы. Для этого есть несколько способов.

\begin{itemize}
\tightlist
\item
  Магомет идет к горе: перемещение файлов в рабочую папку.
\end{itemize}

Для этого нужно узнать, какая папка является рабочей с помощью функции \texttt{getwd()} (без аргументов), найти эту папку в проводнике и переместить туда файл. После этого можно использовать просто название файла с разрешением:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"heroes_information.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Кроме того, путь к рабочей папке можно увидеть в RStudio во вкладке с консолью, в самой верхней части (прямо под надписью ``Console''):

\includegraphics[width=4.16667in,height=\textheight]{images/Console_wd.png}

\begin{itemize}
\tightlist
\item
  Гора идет к Магомету: изменение рабочей папки.
\end{itemize}

Можно просто сменить рабочую папку с помощью \texttt{setwd()} на ту, где сейчас лежит файл, прописав путь до этой папки. Теперь файл находится в рабочей папке:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"heroes_information.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Этот вариант использовать не рекомендуется! Как минимум, это сразу делает невозможным запустить скрипт на другом компьютере.

\begin{itemize}
\tightlist
\item
  Гора находит Магомета по месту прописки: указание полного пути файла.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"/Users/Username/Some_Folder/heroes_information.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Этот вариант страдает теми же проблемами, что и предыдущий, поэтому тоже не рекомендуется!

\begin{quote}
Для пользователей Windows есть дополнительная сложность: знак \texttt{/} является особым знаком для R, поэтому вместо него нужно использовать двойной \texttt{//}.
\end{quote}

\begin{itemize}
\tightlist
\item
  Магомет использует кнопочный интерфейс: Import Dataset.
\end{itemize}

Во вкладке Environment справа в окне RStudio есть кнопка ``Import Dataset''. Возможно, у Вас возникло непреодолимое желание отдохнуть от написания кода и понажимать кнопочки --- сопротивляйтесь этому всеми силами, но не вините себя, если не сдержитесь.

\begin{itemize}
\tightlist
\item
  Гора находит Магомета в интернете.
\end{itemize}

Многие функции в R, предназначенные для чтения файлов, могут прочитать файл не только на Вашем компьютере, но и сразу из интернета. Для этого просто используйте ссылку вместо пути:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/heroes_information.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Каждый Магомет получает по своей горе: использование проектов в RStudio.
\end{itemize}

На первый взгляд это кажется чем-то очень сложным, но это не так. Это очень просто и ОЧЕНЬ удобно. При создании проекта создается отдельная папочка, где у Вас лежат данные, хранятся скрипты, вспомогательные файлы и отчеты. Если нужно вернуться к другому проекту --- просто открываете другой проект, с другими файлами и скриптами. Это еще помогает не пересекаться переменным из разных проектов --- а то, знаете, использование двух переменных \texttt{data} в разных скриптах чревато ошибками. Поэтому очень удобным решением будет выделение отдельного проекта под этот курс.

\begin{quote}
При закрытии проекта все переменные по умолчанию тоже будут сохраняться, а при открытии --- восстанавливаться. Это очень удобно, хотя некоторые \href{https://r4ds.had.co.nz/workflow-projects.html}{рекомендуют от этого отказаться}. Это можно сделать во вкладке \texttt{Tool\ -\ Global\ Options...}
\end{quote}

\hypertarget{text_binary}{%
\subsection{Табличные данные: текстовые и бинарные данные}\label{text_binary}}

Как Вы уже поняли, импортирование данных - одна из самых муторных и неприятных вещей в R. Если у Вас получится с этим справится, то все остальное - ерунда. Мы уже разобрались с первой частью этого процесса - нахождением файла с данными, осталось научиться их читать.

Здесь стоит сделать небольшую ремарку. Довольно часто данные представляют собой табличку. Или же их можно свести к табличке. Такая табличка, как мы уже выяснили, удобно репрезентируется в виде датафрейма. Но как эти данные хранятся на компьютере? Есть два варианта: в \emph{бинарном} и в \emph{текстовом} файле.

Текстовый файл означает, что такой файл можно открыть в программе ``Блокнот'' или аналоге (например, TextEdit на macOS) и увидеть напечатанный текст: скрипт, роман или упорядоченный набор цифр и букв. Нас сейчас интересует именно последний случай. Таблица может быть представлена как текст: отдельные строчки в файле будут разделять разные строчки таблицы, а какой-нибудь знак-разделитель отделять колонки друг от друга.

Для чтения данных из текстового файла есть довольно удобная функция \texttt{read.table()}. Почитайте хэлп по ней и ужаснитесь: столько разных параметров на входе! Но там же вы увидете функции \texttt{read.csv()}, \texttt{read.csv2()} и некоторые другие --- по сути, это тот же \texttt{read.table()}, но с другими параметрами по умолчанию, соответствующие формату файла, который мы загружаем. В данном случае используется формат .csv, что означает ``Comma Separated Values'' (Значения, Разделенные Запятыми). Формат .csv --- это самый известный способ хранения табличных данных в файде на сегодняшний день. Файлы с расширением .csv можно легко открыть в любой программе, работающей с таблицами, в том числе Microsoft Excel и его аналогах.

Файл с расширением .csv --- это просто текстовый файл, в котором ``закодирована'' таблица: разные строчки разделяют разные строчки таблицы, а столбцы отделяются запятыми (отсюда и название). Вы можете вручную создать такие файлы в Блокноте и сохранять их с форматом .csv - и такая табличка будет нормально открываться в Microsoft Excel и других программах для работы с таблицами. Можете попробовать это сделать самостоятельно!

Как говорилось ранее, в качестве разделителя ячеек по горизонтали --- то есть разделителя между столбцами --- используется запятая. С этим связана одна проблема: в некоторых странах (в т.ч. и России) принято использовать запятую для разделения дробной части числа, а не точку, как это делается в большинстве стран мира. Поэтому есть альтернативный вариант формата .csv, где значения разделены точкой с запятой (\texttt{;}), а дробные значения - запятой (\texttt{,}). В этом и различие функций \texttt{read.csv()} и \texttt{read.csv2()} --- первая функция предназначена для ``международного'' формата, вторая - для (условно) ``Российского''. Оба варианта формата имеют расширение .csv, поэтому заранее понять какой именно будет вариант довольно сложно, приходится либо пробовать оба, либо заранее открывать файл в текстовом редакторе.

В первой строчке обычно содержатся названия столбцов - и это чертовски удобно, функции \texttt{read.csv()} и \texttt{read.csv2()} по умолчанию считают первую строчку именно как название для колонок.

Кроме .csv формата есть и другие варианты хранения таблиц в виде текста. Например, .tsv
--- тоже самое, что и .csv, но разделитель - знак табуляции. Для чтения таких файлов есть функция \texttt{read.delim()} и \texttt{read.delim2()}. Впрочем, даже если бы ее и не было, можно было бы просто подобрать нужные параметры для функции \texttt{read.table()}. Есть даже функции, которые пытаются сами ``угадать'' нужные параметры для чтения --- часто они справляются с этим довольно удачно. Но не всегда. Поэтому стоит научиться справляться с любого рода данными на входе.

Итак, прочитаем наш файл. Для этого используем только параметр \texttt{file\ =}, который идет первым, и для параметра \texttt{stringsAsFactors\ =} поставим значение \texttt{FALSE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{, }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Параметр \texttt{stringsAsFactors\ =} задает то, как будут прочитаны строковые значения - как уже знакомые нам строки или как факторы. По сути, факторы - это примерно то же самое, что и character, но закодированные числами. Когда-то это было придумано для экономии используемых времени и памяти, сейчас же обычно становится просто лишней морокой. Но некоторые функции требуют именно character, некоторые factor, в большинстве случаев это без разницы. Но иногда непонимание может привести к дурацким ошибкам. В данном случае мы просто пока обойдемся без факторов. Если у вас версия R выше 4.0, то \texttt{stringsAsFactors\ =} будет \texttt{FALSE} по умолчанию.
\end{quote}

Можете проверить с помощью \texttt{View(heroes)}: все работает! Если же вылезает какая-то странная ерунда или же просто ошибка - попробуйте другие функции (\texttt{read.table()}, \texttt{read.delim()}) и покопаться с параметрами. Для этого читайте \texttt{Help}.

\hypertarget{ux43fux440ux43eux432ux435ux440ux43aux430-ux438ux43cux43fux43eux440ux442ux438ux440ux43eux432ux430ux43dux43dux44bux445-ux434ux430ux43dux43dux44bux445}{%
\section{Проверка импортированных данных}\label{ux43fux440ux43eux432ux435ux440ux43aux430-ux438ux43cux43fux43eux440ux442ux438ux440ux43eux432ux430ux43dux43dux44bux445-ux434ux430ux43dux43dux44bux445}}

При импорте данных обратите внимания на предупреждения (если таковые появляются), в большинстве случаев они указывают на то, что данные импортированы некорректно.

Проверим, что все прочиталось нормально с помощью уже известной нам функции \texttt{str()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(heroes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    734 obs. of  11 variables:
##  $ X         : int  0 1 2 3 4 5 6 7 8 9 ...
##  $ name      : chr  "A-Bomb" "Abe Sapien" "Abin Sur" "Abomination" ...
##  $ Gender    : chr  "Male" "Male" "Male" "Male" ...
##  $ Eye.color : chr  "yellow" "blue" "blue" "green" ...
##  $ Race      : chr  "Human" "Icthyo Sapien" "Ungaran" "Human / Radiation" ...
##  $ Hair.color: chr  "No Hair" "No Hair" "No Hair" "No Hair" ...
##  $ Height    : num  203 191 185 203 -99 193 -99 185 173 178 ...
##  $ Publisher : chr  "Marvel Comics" "Dark Horse Comics" "DC Comics" "Marvel Comics" ...
##  $ Skin.color: chr  "-" "blue" "red" "-" ...
##  $ Alignment : chr  "good" "good" "good" "bad" ...
##  $ Weight    : int  441 65 90 441 -99 122 -99 88 61 81 ...
\end{verbatim}

\begin{quote}
Всегда проверяйте данные на входе и никогда не верьте на слово, если вам говорят, что данные вычищенные и не содержат никаких ошибок.
\end{quote}

На что нужно обращать внимание?

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Прочитаны ли пропущенные значения как \texttt{NA}. По умолчанию пропущенные значения обозначаются пропущенной строчкой или ``NA'', но встречаются самые разнообразные варианты. Возможные варианты кодирования пропущенных значений можно задать в параметре \texttt{na.strings\ =} функции \texttt{read.table()} и ее вариантов. В нашем датасете как раз такая ситуация, где нужно самостоятельно задавать, какие значения будут прочитаны как \texttt{NA}. Попытайтесь самостоятельно догадаться, как именно.
\item
  Прочитаны ли те столбики, которые должны быть числовыми, как \texttt{int} или \texttt{num}. Если в колонке содержатся числа, а написано \texttt{chr} (= \texttt{"character"}) или \texttt{Factor} (в случае если \texttt{stringsAsFactors\ =\ TRUE}), то, скорее всего, одна из строчек содержит в себе нечисловые знаки, которые не были прочитаны как \texttt{NA}.
\item
  Странные названия колонок. Это может случиться по самым разным причинам, но в таких случаях стоит открывать файл в другой программе и смотреть первые строчки. Например, может оказаться, что первые несколько строчек --- пустые или что первая строчка не содержит название столбцов (тогда для параметра \texttt{header\ =} нужно поставить \texttt{FALSE})
\item
  Вместо строковых данных у вас кракозябры. Это означает проблемы с кодировкой. В первую очередь попробуйте выставить значение \texttt{"UTF-8"} для параметра \texttt{encoding\ =} в функции для чтения файла:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{, }
                   \DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{,}
                   \DataTypeTok{encoding =} \StringTok{"UTF-8"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

В случае если это не помогает, попробуйте \href{https://www.artlebedev.ru/decoder/}{разобрать}, что это за кодировка.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\item
  Все прочиталось как одна колонка. В этом случае, скорее всего, неправильно подобран разделить колонок --- параметр \texttt{sep\ =}. Откройте файл в текстовом редакторе, чтобы понять какой нужно использовать.
\item
  В отдельных строчках все прочиталось как одна колонка, а в остальных нормально. Скорее всего, в файле есть значения типа \texttt{\textbackslash{}} или \texttt{"}, которые в функциях \texttt{read.csv()}, \texttt{read.delim()}, \texttt{read.csv2()}, \texttt{read.delim2()} читаются как символы для закавычивания значений. Это может понадобиться, если у вас в таблице есть строковые значения со знаками \texttt{,} или \texttt{;}, которые могут восприниматься как разделитель столбцов.
\item
  Появились какие-то новые числовые колонки. Возможно неправильно поставлен разделитель дробной части. Обычно это либо \texttt{.} (\texttt{read.table()}, \texttt{read.csv()}, \texttt{read.delim()}), либо \texttt{,} (\texttt{read.csv2()}, \texttt{read.delim2()}).
\end{enumerate}

Конкретно в нашем случае все прочиталось хорошо с помощью функции \texttt{read.csv()}, но в строковых переменных есть много прочерков, которые обозначают отсутствие информации по данному параметру супергероя, т.е. пропущенное значение. А вот с числовыми значениями все не так просто: для всех супергероев прописано какое-то число, но во многих случаях это -99. Очевидно, отрицательного роста и массы не бывает, это просто обозначение пропущенных значений (такое часто используется). Таким образом, чтобы адекватно прочитать файл, нам нужно поменять параметр \texttt{na.strings\ =} функции \texttt{read.csv()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{, }
                   \DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{,}
                   \DataTypeTok{na.strings =} \KeywordTok{c}\NormalTok{(}\StringTok{"-"}\NormalTok{, }\StringTok{"-99"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{export_data}{%
\section{Экспорт данных}\label{export_data}}

Представим, что вы хотите сохранить табличку с данными про супергероев из вселенной DC в виде отдельного файла .csv.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dc <-}\StringTok{ }\NormalTok{heroes[heroes}\OperatorTok{$}\NormalTok{Publisher }\OperatorTok{==}\StringTok{ "DC Comics"}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

Функция \texttt{write.csv()} позволит записать датафрейм в файл формата .csv:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{write.csv}\NormalTok{(dc, }\StringTok{"data/dc_heroes_information.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Обычно названия строк не используются, и их лучше не записывать, поставив для \texttt{row.names\ =} значение \texttt{FALSE}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{write.csv}\NormalTok{(dc, }\StringTok{"data/dc_heroes_information.csv"}\NormalTok{, }\DataTypeTok{row.names =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

По аналогии с \texttt{read.csv2()}, \texttt{write.csv2()} позволит записать файлы формата .csv с разделителем \texttt{;}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{write.csv2}\NormalTok{(dc, }\StringTok{"data/dc_heroes_information.csv"}\NormalTok{, }\DataTypeTok{row.names =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{binary}{%
\section{Импорт таблиц в бинарном формате: таблицы Excel, SPSS}\label{binary}}

Тем не менее, далеко не всегда таблицы представлены в виде текстового файла. Самый распространенный пример таблицы в бинарном виде --- родные форматы Microsoft Excel. Если Вы попробуете открыть .xlsx файл в Блокноте, то увидите кракозябры. Это делает работу с этим файлами гораздо менее удобной, поэтому стоит избегать экселевских форматов и стараться все сохранять в .csv.

Такие файлы не получится прочитать при помощи базового инструментария R. Тем не менее, для чтения таких файлов есть много дополнительных пакетов:

\begin{itemize}
\item
  файлы Microsoft Excel: лучше всего справляется пакет \texttt{readxl} (является частью расширенного tidyverse), у него есть много альтернатив (\texttt{xlsx}, \texttt{openxlsx}).
\item
  файлы SPSS, SAS, Stata: существуют два основных пакета --- \texttt{haven} (часть расширенного tidyverse) и \texttt{foreign}.
\end{itemize}

Что такое пакеты и как их устанавливать мы изучим очень скоро.

\hypertarget{fastread}{%
\section{Быстрый импорт данных}\label{fastread}}

Чтение табличных данных обычно происходит очень быстро. По крайней мере, до тех пор пока ваши данные не содержат очень много значений. Если вы попробуете прочитать с помощью \texttt{read.csv()} таблицу с миллионами строчками, то заметите, что это происходит довольно медленно. Впрочем, эта проблема эффективно решается дополнительными пакетами.

\begin{itemize}
\tightlist
\item
  Пакет \texttt{readr} (часть базового tidyverse) предлагает функции, очень похожие на стандартные \texttt{read.csv()}, \texttt{read.csv2()} и тому подобные, только в названиях используется нижнее подчеркивание: \texttt{read\_csv()} и \texttt{read\_csv2()}. Они быстрее и немного удобнее, особенно если вы работаете в tidyverse.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{readr}\OperatorTok{::}\KeywordTok{read_csv}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{,}
         \DataTypeTok{na =} \KeywordTok{c}\NormalTok{(}\StringTok{"-"}\NormalTok{, }\StringTok{"-99"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: Missing column names filled in: 'X1' [1]
\end{verbatim}

\begin{verbatim}
## 
## -- Column specification --------------------------------------------------------
## cols(
##   X1 = col_double(),
##   name = col_character(),
##   Gender = col_character(),
##   `Eye color` = col_character(),
##   Race = col_character(),
##   `Hair color` = col_character(),
##   Height = col_double(),
##   Publisher = col_character(),
##   `Skin color` = col_character(),
##   Alignment = col_character(),
##   Weight = col_double()
## )
\end{verbatim}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
##  2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  4     3 Abom~ Male   green       Huma~ No Hair         203 Marvel C~
##  5     4 Abra~ Male   blue        Cosm~ Black            NA Marvel C~
##  6     5 Abso~ Male   blue        Human No Hair         193 Marvel C~
##  7     6 Adam~ Male   blue        <NA>  Blond            NA NBC - He~
##  8     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  9     8 Agen~ Female blue        <NA>  Blond           173 Marvel C~
## 10     9 Agen~ Male   brown       Human Brown           178 Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Пакет \texttt{vroom} - это часть расширенного tidyverse. Это такая альтернатива \texttt{readr} из того же tidyverse, но еще быстрее (отсюда и название).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vroom}\OperatorTok{::}\KeywordTok{vroom}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## New names:
## * `` -> ...1
\end{verbatim}

\begin{verbatim}
## Rows: 734
## Columns: 11
## Delimiter: ","
## chr [8]: name, Gender, Eye color, Race, Hair color, Publisher, Skin color, Alignment
## dbl [3]: ...1, Height, Weight
## 
## Use `spec()` to retrieve the guessed column specification
## Pass a specification to the `col_types` argument to quiet this message
\end{verbatim}

\begin{verbatim}
## # A tibble: 734 x 11
##     ...1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
##  2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  4     3 Abom~ Male   green       Huma~ No Hair         203 Marvel C~
##  5     4 Abra~ Male   blue        Cosm~ Black           -99 Marvel C~
##  6     5 Abso~ Male   blue        Human No Hair         193 Marvel C~
##  7     6 Adam~ Male   blue        -     Blond           -99 NBC - He~
##  8     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  9     8 Agen~ Female blue        -     Blond           173 Marvel C~
## 10     9 Agen~ Male   brown       Human Brown           178 Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Пакет \texttt{data.table} - это не просто пакет, а целый фреймворк для работы с R, основной конкурент tidyverse. Одна из основных фишек \texttt{data.table} - быстрота работы. Это касается не только процессинга данных, но и их загрузки и записи. Поэтому некоторые используют функции \texttt{data.table} для чтения и записи данных в отдельности от всего остального пакета - они даже и называются соответствующе: \texttt{fread()} и \texttt{fwrite()}, где \textbf{f} означет \textbf{f}ast\footnote{А еще \textbf{f}riendly: \texttt{fread()} обычно самостоятельно хорошо угадывает формат таблицы на входе. \texttt{vroom} тоже так умеет.}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data.table}\OperatorTok{::}\KeywordTok{fread}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       V1            name Gender Eye color              Race       Hair color
##   1:   0          A-Bomb   Male    yellow             Human          No Hair
##   2:   1      Abe Sapien   Male      blue     Icthyo Sapien          No Hair
##   3:   2        Abin Sur   Male      blue           Ungaran          No Hair
##   4:   3     Abomination   Male     green Human / Radiation          No Hair
##   5:   4         Abraxas   Male      blue     Cosmic Entity            Black
##  ---                                                                        
## 730: 729 Yellowjacket II Female      blue             Human Strawberry Blond
## 731: 730            Ymir   Male     white       Frost Giant          No Hair
## 732: 731            Yoda   Male     brown    Yoda's species            White
## 733: 732         Zatanna Female      blue             Human            Black
## 734: 733            Zoom   Male       red                 -            Brown
##      Height         Publisher Skin color Alignment Weight
##   1:  203.0     Marvel Comics          -      good    441
##   2:  191.0 Dark Horse Comics       blue      good     65
##   3:  185.0         DC Comics        red      good     90
##   4:  203.0     Marvel Comics          -       bad    441
##   5:  -99.0     Marvel Comics          -       bad    -99
##  ---                                                     
## 730:  165.0     Marvel Comics          -      good     52
## 731:  304.8     Marvel Comics      white      good    -99
## 732:   66.0      George Lucas      green      good     17
## 733:  170.0         DC Comics          -      good     57
## 734:  185.0         DC Comics          -       bad     81
\end{verbatim}

Чем же пользоваться среди всего этого многообразия? \href{https://www.danielecook.com/speeding-up-reading-and-writing-in-r/}{Бенчмарки}\footnote{бенчмаркинг --- это тест производительности, в данном случае --- сравнение скорости работы конкурирующих пакетов.} показывают, что быстрее всех \texttt{vroom} и \texttt{data.table}. Если же у вас нет задачи ускорить работу кода на несколько миллисекунд или прочитать датасет на много миллионов строк, то стандартного \texttt{read.csv()} (если вы работаете в базовом R) и \texttt{readr::read\_csv()} (если вы работаете в tidyverse) должно быть достаточно.

Все перечисленные пакеты повзоляют не только быстро импортировать данные, но и быстро (и удобно!) экспортировать их:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{readr}\OperatorTok{::}\KeywordTok{write_csv}\NormalTok{(dc, }\StringTok{"data/dc_heroes_information.csv"}\NormalTok{)}
\NormalTok{readr}\OperatorTok{::}\KeywordTok{write_excel_csv}\NormalTok{(dc, }\StringTok{"data/dc_heroes_information.csv"}\NormalTok{) }\CommentTok{#Если в Excel возникают проблемы с кодировками при открытии созданного .csv файла, то эта функция решает эти проблемы}
\NormalTok{vroom}\OperatorTok{::}\KeywordTok{vroom_write}\NormalTok{(dc, }\StringTok{"data/dc_heroes_information.csv"}\NormalTok{, }\DataTypeTok{delim =} \StringTok{","}\NormalTok{)}
\NormalTok{data.table}\OperatorTok{::}\KeywordTok{fwrite}\NormalTok{(dc, }\StringTok{"data/dc_heroes_information.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

В плане скорости записи файлов соотношение сил примерно такое же, как и для чтения: \texttt{vroom} и \texttt{data.table} обгоняют всех, затем идет \texttt{readr}, и только после него - базовые функции R.

\hypertarget{loops_conditions}{%
\chapter{Условные конструкции и циклы}\label{loops_conditions}}

\hypertarget{if}{%
\section{\texorpdfstring{Выражения \texttt{if}, \texttt{else}, \texttt{else\ if}}{Выражения if, else, else if}}\label{if}}

Стандратная часть практически любого языка программирования --- условные конструкции. R не исключение. Однако и здесь есть свои особенности. Начнем с самого простого варианта с одним условием. Выглядеть условная конcтрукция будет вот так:

\begin{verbatim}
if (условие) выражение
\end{verbatim}

Вот так это будет работать на практике:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number <-}\StringTok{ }\DecValTok{1}
\ControlFlowTok{if}\NormalTok{ (number }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) }\StringTok{"Положительное число"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Положительное число"
\end{verbatim}

Если выражение (expression) содержит больше одной строчки, то они объединяются фигурными скобками. Впрочем, использовать их можно, даже если строчка всего в выражении всего одна.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number <-}\StringTok{ }\DecValTok{1}
\ControlFlowTok{if}\NormalTok{ (number }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
  \StringTok{"Положительное число"}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Положительное число"
\end{verbatim}

В рассмотренной нами конструкции происходит проверка на условие. Если условие верно\footnote{В принципе, необязательно внутри должна быть проверка условий, достаточно просто значения \texttt{TRUE}.}, то происходит то, что записано в последующем выражении. Если же условие неверно\footnote{Аналогично, достаточно просто значения \texttt{FALSE}.}, то ничего не происходит.

Оператор \texttt{else} позволяет задавать действие на все остальные случаи:

\begin{verbatim}
if (условие) выражение else выражение
\end{verbatim}

Работает это так:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number <-}\StringTok{ }\DecValTok{-3}
\ControlFlowTok{if}\NormalTok{ (number }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
  \StringTok{"Положительное число"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \StringTok{"Отрицательное число или ноль"}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Отрицательное число или ноль"
\end{verbatim}

Иногда нам нужна последовательная проверка на несколько условий. Для этого есть оператор \texttt{else\ if}. Вот как выглядит ее применение:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number <-}\StringTok{ }\DecValTok{0}
\ControlFlowTok{if}\NormalTok{ (number }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
  \StringTok{"Положительное число"}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (number }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{)\{}
  \StringTok{"Отрицательное число"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \StringTok{"Ноль"}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Ноль"
\end{verbatim}

Как мы помним, R --- язык, в котором векторизация играет большое значение. Но вот незадача --- условные конструкции не векторизованы в R! Давайте попробуем применить эти конструкции для вектора значений и посмотрим, что получится.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number <-}\StringTok{ }\DecValTok{-2}\OperatorTok{:}\DecValTok{2}
\ControlFlowTok{if}\NormalTok{ (number }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
  \StringTok{"Положительное число"}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (number }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{)\{}
  \StringTok{"Отрицательное число"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
  \StringTok{"Ноль"}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in if (number > 0) {: the condition has length > 1 and only the first
## element will be used
\end{verbatim}

\begin{verbatim}
## Warning in if (number < 0) {: the condition has length > 1 and only the first
## element will be used
\end{verbatim}

\begin{verbatim}
## [1] "Отрицательное число"
\end{verbatim}

R выдает сообщение, что используется только первое значение логического вектора внутри условия. Остальные просто игнорируются. Как же посчитать для всего вектора сразу?

\hypertarget{for}{%
\section{\texorpdfstring{Циклы \texttt{for}}{Циклы for}}\label{for}}

Во-первых, можно использовать \texttt{for}. Синтаксис у \texttt{for} похож на синтаксис условных конструкций.

\begin{verbatim}
for(переменная in последовательность) выражение
\end{verbatim}

Теперь мы можем объединить условные конструкции и \texttt{for}. Немножко монструозно, но это работает:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in}\NormalTok{ number) \{}
  \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{print}\NormalTok{(}\StringTok{"Положительное число"}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{print}\NormalTok{(}\StringTok{"Отрицательное число"}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{print}\NormalTok{(}\StringTok{"Ноль"}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Отрицательное число"
## [1] "Отрицательное число"
## [1] "Ноль"
## [1] "Положительное число"
## [1] "Положительное число"
\end{verbatim}

\begin{quote}
Чтобы выводить в консоль результат вычислений внутри \texttt{for}, нужно использовать \texttt{print()}.
\end{quote}

Здесь стоит отметить, что \texttt{for} используется в R относительно редко. В подавляющем числе ситуаций использование \texttt{for} можно избежать. Обычно мы работаем в R с векторами или датафреймами, которые представляют собой множество относительно независимых наблюдений. Если мы хотим провести какие-нибудь операции с этими наблюдениями, то они обычно могут быть выполнены параллельно. Скажем, вы хотите для каждого испытуемого пересчитать его массу из фунтов в килограммы. Этот пересчет осуществляется по одинаковой формуле для каждого испытуемого. Эта формула не изменится из-за того, что какой-то испытуемый слишком большой или слишком маленький - для следующего испытуемого формула будет прежняя. Если Вы встречаете подобную задачу (где функцию можно применить независимо для всех значений), то без цикла \texttt{for} вполне можно обойтись.

Даже во многих случаях, где расчеты для одной строчки зависят от расчетов предыдущих строчек, можно обойтись без \texttt{for} векторизованными функциями, например, \texttt{cumsum()} для подсчета кумулятивной суммы.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cumsum}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  3  6 10 15 21 28 36 45 55
\end{verbatim}

Если же нет подходящей векторизованной функции, то можно воспользоваться семейством функций \texttt{apply()} (см. @ref(apply\_f) ).

\begin{quote}
После этих объяснений кому-то может показаться странным, что я вообще упоминаю про эти циклы. Но для кого-то циклы \texttt{for} настолько привычны, что их полное отсутствие в курсе может показаться еще более странным. Поэтому лучше от меня, чем на улице.
\end{quote}

Зачем вообще избегать конструкций \texttt{for}? Некоторые говорят, что они слишком медленные, и частично это верно, если мы сравниваем с векторизованными функциями, которые написаны на более низкоуровневых языках. Но в большинстве случаев низкая скорость \texttt{for} связана с неправильным использованием этой конструкции. Например, стоит избегать ситуации, когда на каждой итерации \texttt{for} какой-то объект (вектор, список, что угодно) изменяется в размере. Лучше будет создать заранее объект нужного размера, который затем будет наполняться значениями:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{number_descriptions <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\KeywordTok{length}\NormalTok{(number)) }\CommentTok{#создаем строковый вектор с такой же длиной, как и исходный вектор}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(number)) \{}
  \ControlFlowTok{if}\NormalTok{ (number[i] }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{    number_descriptions[i] <-}\StringTok{ "Положительное число"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (number[i] }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{    number_descriptions[i] <-}\StringTok{ "Отрицательное число"}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    number_descriptions[i] <-}\StringTok{ "Ноль"}
\NormalTok{  \}}
\NormalTok{\}}
\NormalTok{number_descriptions}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Отрицательное число" "Отрицательное число" "Ноль"               
## [4] "Положительное число" "Положительное число"
\end{verbatim}

В общем, при правильном обращении с \texttt{for} особых проблем со скоростью не будет. Но все равно это будет громоздкая конструкция, в которой легко ошибиться, и которую, скорее всего, можно заменить одной короткой строчкой. Кроме того, без конструкции \texttt{for} код обычно легко превратить в набор функций, последовательно применяющихся к данным, что мы будем по максимуму использовать, работая в tidyverse и применяя пайпы (см. {[}pipe{]}).

\hypertarget{ifelse}{%
\section{\texorpdfstring{Векторизованные условные конструкции: функции \texttt{ifelse()} и \texttt{dplyr::case\_when()}}{Векторизованные условные конструкции: функции ifelse() и dplyr::case\_when()}}\label{ifelse}}

Альтернатива сочетанию условных конструкций и циклов \texttt{for} является использование встроенной функции \texttt{ifelse()}. Функция \texttt{ifelse()} принимает три аргумента - 1) условие (т.е. просто логический вектор, состоящий из \texttt{TRUE} и \texttt{FALSE}), 2) что выдавать в случае \texttt{TRUE}, 3) что выдавать в случае \texttt{FALSE}. На выходе получается вектор такой же длины, как и изначальный логический вектор (условие).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ifelse}\NormalTok{(number }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{, }\StringTok{"Положительное число"}\NormalTok{, }\StringTok{"Отрицательное число или ноль"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Отрицательное число или ноль" "Отрицательное число или ноль"
## [3] "Отрицательное число или ноль" "Положительное число"         
## [5] "Положительное число"
\end{verbatim}

\begin{quote}
Периодически я встречаю у студентов строчку вроде такой: \texttt{ifelse(условие,\ TRUE,\ FALSE)}. Эта конструкция избыточна, т.к. получается, что логический вектор из \texttt{TRUE} и \texttt{FALSE} превращается в абсолютно такой же вектор из \texttt{TRUE} и \texttt{FALSE} на тех же самых местах. Выходит, что ничего не меняется!
\end{quote}

У \texttt{ifelse()} тоже есть недостаток: он не может включать в себя дополнительных условий по типу \texttt{else\ if}. В простых ситуациях можно вставлять \texttt{ifelse()} внутри \texttt{ifelse()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ifelse}\NormalTok{(number }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{,}
       \StringTok{"Положительное число"}\NormalTok{,}
       \KeywordTok{ifelse}\NormalTok{(number }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{, }\StringTok{"Отрицательное число"}\NormalTok{, }\StringTok{"Ноль"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Отрицательное число" "Отрицательное число" "Ноль"               
## [4] "Положительное число" "Положительное число"
\end{verbatim}

Достаточно симпатичное решение предлогает пакет \texttt{dplyr} (основа tidyverse) --- функция \texttt{case\_when()}, которая работает с использованием формулы:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{case_when}\NormalTok{(}
\NormalTok{  number }\OperatorTok{>}\StringTok{ }\DecValTok{0} \OperatorTok{~}\StringTok{ "Положительное число"}\NormalTok{,}
\NormalTok{  number }\OperatorTok{<}\StringTok{ }\DecValTok{0} \OperatorTok{~}\StringTok{ "Отрицательное число"}\NormalTok{,}
\NormalTok{  number }\OperatorTok{==}\StringTok{ }\DecValTok{0} \OperatorTok{~}\StringTok{ "Ноль"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Отрицательное число" "Отрицательное число" "Ноль"               
## [4] "Положительное число" "Положительное число"
\end{verbatim}

\hypertarget{functional}{%
\chapter{Функциональное программирование в R}\label{functional}}

\hypertarget{create_fun}{%
\section{Создание функций}\label{create_fun}}

Поздравляю, сейчас мы выйдем на качественно новый уровень владения R. Вместо того, чтобы пользоваться теми функциями, которые уже написали за нас, мы можем сами создавать свои функции! В этом нет ничего сложного.

Синтаксис создания функции внешне похож на создание циклов или условных конструкций. Мы пишем ключевое слово \texttt{function}, в круглых скобках обозначаем переменные, с которыми собираемся что-то делать. Внутри фигурных скобок пишем выражения, которые будут выполняться при запуске функции. У функции есть свое собственное окружение --- место, где хранятся переменные. Именно те объекты, которые мы передаем в скобочках, и будут в окружении, так же как и ``обычные'' переменные для нас в глобальном окружении. Это означает, что функция будет искать переменные в первую очередь среди объектов, которые переданы в круглых скобочках. С ними функция и будет работать. На выходе функция выдаст то, что вычисляется внутри функции \texttt{return()}. Если \texttt{return()} появляется в теле функции несколько раз, то до результат будет возвращаться из той функции \texttt{return()}, до которой выполнение дошло первым.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pow <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, p) \{}
\NormalTok{  power <-}\StringTok{ }\NormalTok{x }\OperatorTok{^}\StringTok{ }\NormalTok{p}
  \KeywordTok{return}\NormalTok{(power)}
\NormalTok{\}}
\KeywordTok{pow}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

Если функция проработала до конца, а функция \texttt{return()} так и не встретилась, то возвращается последнее посчитанное значение.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pow <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, p) \{}
\NormalTok{  x }\OperatorTok{^}\StringTok{ }\NormalTok{p}
\NormalTok{\}}
\KeywordTok{pow}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

Если в последней строчке будет присвоение, то функция ничего не вернет обратно. Это очень распространенная ошибка: функция вроде бы работает правильно, но ничего не возвращает. Нужно писать так, как будто бы в последней строчке результат выполнения выводится в консоль.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pow <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, p) \{}
\NormalTok{  power <-}\StringTok{ }\NormalTok{x }\OperatorTok{^}\StringTok{ }\NormalTok{p }\CommentTok{#Функция ничего не вернет, потому что в последней строчке присвоение!}
\NormalTok{\}}
\KeywordTok{pow}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{) }\CommentTok{#ничего не возвращается из функции}
\end{Highlighting}
\end{Shaded}

Если функция небольшая, то ее можно записать в одну строчку без фигурных скобок.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pow <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, p) x }\OperatorTok{^}\StringTok{ }\NormalTok{p}
\KeywordTok{pow}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

Вообще, фигурные скобки используются для того, чтобы выполнить серию выражений, но вернуть только результат выполнения последнего выражения. Это можно использовать, чтобы не создавать лишних временных переменных в глобальном окружении.

Мы можем оставить в функции параметры по умолчанию.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pow <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{p =} \DecValTok{2}\NormalTok{) x }\OperatorTok{^}\StringTok{ }\NormalTok{p}
\KeywordTok{pow}\NormalTok{(}\DecValTok{3}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pow}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 27
\end{verbatim}

В R работают \textbf{ленивые вычисления (lazy evaluations)}. Это означает, что параметры функций будут только когда они понадобятся, а не заранее. Например, эта функция не будет выдавать ошибку, если мы не зададим параметр \texttt{we\_will\_not\_use\_this\_parameter\ =}, потому что он нигде не используется в расчетах.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pow <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{p =} \DecValTok{2}\NormalTok{, we_will_not_use_this_parameter) x }\OperatorTok{^}\StringTok{ }\NormalTok{p}
\KeywordTok{pow}\NormalTok{(}\DataTypeTok{x =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

\hypertarget{sanity_check}{%
\section{Проверка на адекватность}\label{sanity_check}}

Лучший способ не бояться ошибок и предупреждений --- научиться прописывать их самостоятельно в собственных функциях. Это позволит понять, что за текстом предупреждений и ошибок, которые у вас возникают, стоит забота разработчиков о пользователях, которые хотят максимально обезопасить нас от наших непродуманных действий.

Хорошо написанные функции не только выдают правильный результат на все возможные адекватные данные на входе, но и не дают получить правдоподобные результаты при неадекватных входных данных. Как вы уже знаете, если на входе у вас имеются пропущенные значения, то многие функции будут в ответ тоже выдавать пропущенные значения. И это вполне осознанное решение, которое позволяет избегать ситуаций вроде той, когда \href{https://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-1044-7}{около одной пятой научных статей по генетике содержало ошибки в приложенных данных} и замечать пропущенные значения на ранней стадии. Кроме того, можно проводить проверки на адекватность входящих данных (sanity check).

Разберем это на примере самодельной функции \texttt{imt()}, которая выдает индекс массы тела, если на входе задать вес (аргумент \texttt{weight\ =}) в килограммах и рост (аргумент \texttt{height\ =}) в метрах.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{imt <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(weight, height) weight }\OperatorTok{/}\StringTok{ }\NormalTok{height }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

Проверим, что функция работает верно:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{w <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{60}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{120}\NormalTok{)}
\NormalTok{h <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\FloatTok{1.6}\NormalTok{, }\FloatTok{1.7}\NormalTok{, }\FloatTok{1.8}\NormalTok{)}
\KeywordTok{imt}\NormalTok{(}\DataTypeTok{weight =}\NormalTok{ w, }\DataTypeTok{height =}\NormalTok{ h)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 23.43750 27.68166 37.03704
\end{verbatim}

Очень легко перепутать и написать рост в сантиметрах. Было бы здорово предупредить об этом пользователя, показав ему предупреждающее сообщение, если рост больше, чем, например, 3. Это можно сделать с помощью функции \texttt{warning()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{imt <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(weight, height) \{}
  \ControlFlowTok{if}\NormalTok{ (height }\OperatorTok{>}\StringTok{ }\DecValTok{3}\NormalTok{) }\KeywordTok{warning}\NormalTok{(}\StringTok{"Рост в аргументе height больше 3: возможно, указан рост в сантиметрах, а не в метрах}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{  weight }\OperatorTok{/}\StringTok{ }\NormalTok{height }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\NormalTok{\}}
\KeywordTok{imt}\NormalTok{(}\DecValTok{78}\NormalTok{, }\DecValTok{167}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in imt(78, 167): Рост в аргументе height больше 3: возможно, указан рост в сантиметрах, а не в метрах
\end{verbatim}

\begin{verbatim}
## [1] 0.002796802
\end{verbatim}

В некоторых случаях ответ будет совершенно точно некорректным, хотя функция все посчитает и выдаст ответ, как будто так и надо. Например, если какой-то из аргументов функции \texttt{imt()} будет меньше или равен 0. В этом случае нужно прописать проверку на это условие, и если это действительно так, то выдать пользователю ошибку.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{imt <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(weight, height) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{any}\NormalTok{(weight }\OperatorTok{<=}\StringTok{ }\DecValTok{0} \OperatorTok{|}\StringTok{ }\NormalTok{height }\OperatorTok{<=}\StringTok{ }\DecValTok{0}\NormalTok{)) }\KeywordTok{stop}\NormalTok{(}\StringTok{"Индекс массы тела не может быть посчитан для отрицательных значений"}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (height }\OperatorTok{>}\StringTok{ }\DecValTok{3}\NormalTok{) }\KeywordTok{warning}\NormalTok{(}\StringTok{"Рост в аргументе height больше 3: возможно, указан рост в сантиметрах, а не в метрах}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{  weight }\OperatorTok{/}\StringTok{ }\NormalTok{height }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\NormalTok{\}}
\KeywordTok{imt}\NormalTok{(}\OperatorTok{-}\DecValTok{78}\NormalTok{, }\DecValTok{167}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in imt(-78, 167): Индекс массы тела не может быть посчитан для отрицательных значений
\end{verbatim}

Когда вы попробуете самостоятельно прописывать предупреждения и ошибки в функциях, то быстро поймете, что ошибки - это вовсе не обязательно результат того, что где-то что-то сломалось и нужно паниковать. Совсем даже наоборот, прописанная ошибка - чья-то забота о пользователях, которых пытаются максимально проинформировать о том, что и почему пошло не так.

Это естественно в начале работы с R (и вообще с программированием) избегать ошибок, конечно, в самом начале обучения большая часть из них остается непонятной. Но постарайтесь понять текст ошибки, вспомнить в каких случаях у вас возникала похожая ошибка. Очень часто этого оказывается достаточно чтобы понять причину ошибки даже если вы только-только начали изучать R.

Ну а в дальнейшем я советую ознакомиться со \href{https://adv-r.hadley.nz/debugging.html}{средствами отладки кода в R} для того, чтобы научиться справляться с ошибками в своем коде на более продвинутом уровне.

\hypertarget{why_functions}{%
\section{Когда и зачем создавать функции?}\label{why_functions}}

Когда стоит создавать функции? Существует \href{https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)}{``правило трех''} --- если у вас есть три куска очень похожего кода, то самое время превратить код в функцию. Это очень условное правило, но, действительно, стоит избегать копипастинга в коде. В этом случае очень легко ошибиться, а сам код становится нечитаемым.

Есть и другой подход к созданию функций: их стоит создавать не столько для того, чтобы использовать тот же код снова, сколько для абстрагирования от того, что происходит в отдельных строчках кода. Если несколько строчек кода были написаны для того, чтобы решить одну задачу, которой можно дать понятное название (например, подсчет какой-то особенной метрики, для которой нет готовой функции в R), то этот код стоит обернуть в функцию. Если функция работает корректно, то теперь не нужно думать над тем, что происходит внутри нее. Вы ее можете мысленно представить как операцию, которая имеет определенный вход и выход --- как и встроенные функции в R.

Отсюда следует важный вывод, что хорошее название для функции --- это очень важно. Очень, очень, очень важно.

\hypertarget{functions_objects}{%
\section{Функции как объекты первого порядка}\label{functions_objects}}

Ранее мы убедились, что арифметические операторы --- это тоже функции. На самом деле, практически все в R --- это функции. Даже \texttt{function} --- это функция \texttt{function()}. Даже скобочки \texttt{(}, \texttt{\{} --- это функции!

А сами функции --- это объекты первого порядка в R. Это означает, что с функциями вы можете делать практически все то же самое, что и с другими объектами в R (векторами, датафреймами и т.д.). Небольшой пример, который может взорвать ваш мозг:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{list}\NormalTok{(mean, min, }\StringTok{`}\DataTypeTok{\{}\StringTok{`}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## function (x, ...) 
## UseMethod("mean")
## <bytecode: 0x5fe2f0338d20>
## <environment: namespace:base>
## 
## [[2]]
## function (..., na.rm = FALSE)  .Primitive("min")
## 
## [[3]]
## .Primitive("{")
\end{verbatim}

Мы можем создать список из функций! Зачем --- это другой вопрос, но ведь можем же!

Еще можно создавать функции внутри функций \footnote{Функция, которая создает другие функции, называется \textbf{фабрикой функций}.}, использовать функции в качестве аргументов функций, сохранять функции как переменные. Пожалуй, самое важное из этого всего - это то, что функция может быть аргументом в функции. Не просто название функции как строковая переменная, не результат выполнения функции, а именно сама функция. Это лежит в основе использования семейства функций \texttt{apply()} (@ref(apply\_f) и многих фишек tidyverse.

\begin{quote}
В Python дело обстоит похожим образом: функции там тоже являются объектами первого порядка, поэтому все эти фишки функционального программирования (с поправкой на синтаксис, конечно) будут работать и там.
\end{quote}

\hypertarget{apply_f}{%
\section{Семейство функций apply()}\label{apply_f}}

\hypertarget{apply}{%
\subsection{\texorpdfstring{Применение \texttt{apply()} для матриц}{Применение apply() для матриц}}\label{apply}}

Семейство? Да, их целое множество: \texttt{apply()}, \texttt{lapply()},\texttt{sapply()}, \texttt{vapply()},\texttt{tapply()},\texttt{mapply()}, \texttt{rapply()}\ldots{} Ладно, не пугайтесь, всех их знать не придется. Обычно достаточно первых двух-трех. Проще всего пояснить как они работают на простой матрице с числами:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{A }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
\end{verbatim}

\begin{quote}
Функция \texttt{apply()} предназначена для работы с матрицами (или многомерными массивами). Если вы скормите функции \texttt{apply()} датафрейм, то этот датафрейм будет сначала превращен в матрицу. Главное отличие матрицы от датафрейма в том, что в матрице все значения одного типа, поэтому будьте готовы, что сработает имплицитное приведение к общему типу данных. Например, если среди колонок датафрейма есть хотя бы одна строковая колонка, то все колонки станут строковыми.
\end{quote}

Теперь представим, что нам нужно посчитать что-нибудь (например, сумму) по каждой из строк. С помощью функции \texttt{apply()} вы можете в буквальном смысле ``применить'' функцию к матрице или датафрейму. Синтаксис такой: \texttt{apply(X,\ MARGIN,\ FUN,\ ...)}, где \texttt{X} --- данные, \texttt{MARGIN} это \texttt{1} (для строк), \texttt{2} (для колонок), \texttt{c(1,2)} для строк и колонок (т.е. для каждого элемента по отдельности), а \texttt{FUN} --- это функция, которую вы хотите применить! \texttt{apply()} будет брать строки/колонки из \texttt{X} в качестве первого аргумента для функции.

\begin{figure}
\centering
\includegraphics[width=4.16667in,height=\textheight]{images/Apply_function.png}
\caption{apply}
\end{figure}

\begin{quote}
Заметьте, мы вставляем функцию без скобок и кавычек как аргумент в функцию. Это как раз тот случай, когда аргументом в функции выступает сама функция, а не ее название или результат ее выполнения.
\end{quote}

Давайте разберем на примере:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{1}\NormalTok{, sum) }\CommentTok{#сумма по каждой строчке}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 22 26 30
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{2}\NormalTok{, sum) }\CommentTok{#сумма по каждой колонке}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  6 15 24 33
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{), sum) }\CommentTok{#кхм... сумма каждого элемента}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
\end{verbatim}

\begin{quote}
Конкретно для подсчета сумм и средних по столбцам и строкам в R есть функции \texttt{colSums()}, \texttt{rowSums()}, \texttt{colMeans()} и \texttt{rowMeans()}, которые можно использовать как альтернативы \texttt{apply()} в данном случае.
\end{quote}

Если же мы хотим прописать дополнительные аргументы для функции, то их можно перечислить через запятую после функции:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{1}\NormalTok{, sum, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 22 26 30
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{1}\NormalTok{, weighted.mean, }\DataTypeTok{w =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.2}\NormalTok{, }\FloatTok{0.4}\NormalTok{, }\FloatTok{0.3}\NormalTok{, }\FloatTok{0.1}\NormalTok{)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4.9 5.9 6.9
\end{verbatim}

\hypertarget{anon_f}{%
\subsection{Анонимные функции}\label{anon_f}}

Что делать, если мы хотим сделать что-то более сложное, чем просто применить одну функцию? А если функция принимает не первым, а вторым аргументом данные из матрицы? В этом случае нам помогут \textbf{анонимные функции}.

Анонимные функции - это функции, которые будут использоваться один раз и без названия.

\begin{quote}
Питонистам знакомо понятие \textbf{лямбда-функций}. Да, это то же самое.
\end{quote}

Например, мы можем посчитать отклонения от среднего без называния этой функции:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{1}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)) }\CommentTok{#отклонения от среднего по строчке}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,] -4.5 -4.5 -4.5
## [2,] -1.5 -1.5 -1.5
## [3,]  1.5  1.5  1.5
## [4,]  4.5  4.5  4.5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{2}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)) }\CommentTok{#отклонения от среднего по столбцу}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]   -1   -1   -1   -1
## [2,]    0    0    0    0
## [3,]    1    1    1    1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)) }\CommentTok{#отклонения от одного значения, т.е. ноль}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    0    0    0    0
## [2,]    0    0    0    0
## [3,]    0    0    0    0
\end{verbatim}

Как и в случае с обычной функцией, в качестве \texttt{x} выступает объект, с которым мы хотим что-то сделать, а дальше следует функция, которую мы собираемся применить к \texttt{х}. Можно использовать не \texttt{х}, а что угодно, как и в обычных функциях:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{1}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(whatevername) whatevername }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(whatevername))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,] -4.5 -4.5 -4.5
## [2,] -1.5 -1.5 -1.5
## [3,]  1.5  1.5  1.5
## [4,]  4.5  4.5  4.5
\end{verbatim}

\hypertarget{apply_other}{%
\subsection{\texorpdfstring{Другие функции семейства \texttt{apply()}}{Другие функции семейства apply()}}\label{apply_other}}

Ок, с \texttt{apply()} разобрались. А что с остальными? Некоторые из них еще проще и не требуют индексов, например, \texttt{lapply} (для применения к каждому элементу списка) и \texttt{sapply()} - упрощенная версия \texttt{lapply()}, которая пытается по возможности ``упростить'' результат до вектора или матрицы.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{some_list <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{some =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{list =}\NormalTok{ letters)}
\KeywordTok{lapply}\NormalTok{(some_list, length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $some
## [1] 10
## 
## $list
## [1] 26
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(some_list, length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## some list 
##   10   26
\end{verbatim}

Использование \texttt{sapply()} на векторе приводит к тем же результатам, что и просто применить векторизованную функцию обычным способом.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, sqrt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
##  [9] 3.000000 3.162278
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sqrt}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
##  [9] 3.000000 3.162278
\end{verbatim}

Зачем вообще тогда нужен \texttt{sapply()}, если мы можем просто применить векторизованную функцию? Ключевое слово здесь \emph{векторизованная} функция. Если функция не векторизована, то \texttt{sapply()} становится удобным вариантом для того, чтобы избежать итерирования с помощью циклов \texttt{for}.

\begin{quote}
Еще одна альтернатива - это векторизация невекторизованной функции с помощью \texttt{Vectorize()}. Эта функция просто оборачивает функцию одним из вариантов \texttt{apply()}.
\end{quote}

Можно применять функции \texttt{lapply()} и \texttt{sapply()} на датафреймах. Поскольку фактически датафрейм - это список из векторов одинаковой длины (см. \ref{df}), то итерироваться эти функции будут по колонкам:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{, }
                   \DataTypeTok{na.strings =} \KeywordTok{c}\NormalTok{(}\StringTok{"-"}\NormalTok{, }\StringTok{"-99"}\NormalTok{))}
\KeywordTok{sapply}\NormalTok{(heroes, class)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##           X        name      Gender   Eye.color        Race  Hair.color 
##   "integer" "character" "character" "character" "character" "character" 
##      Height   Publisher  Skin.color   Alignment      Weight 
##   "numeric" "character" "character" "character"   "integer"
\end{verbatim}

Еще одна функция из семейства \texttt{apply()} - функция \texttt{replicate()} - самый простой способ повторить одну и ту же операцию много раз. Обычно эта функция используется при симуляции данных и моделировании. Например, давайте сделаем выборку из логнормального распределения:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{samp <-}\StringTok{ }\KeywordTok{rlnorm}\NormalTok{(}\DecValTok{30}\NormalTok{)}
\KeywordTok{hist}\NormalTok{(samp)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-145-1.pdf}

А теперь давайте сделаем 1000 таких выборок и из каждой возьмем среднее:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sampdist <-}\StringTok{ }\KeywordTok{replicate}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\KeywordTok{mean}\NormalTok{(}\KeywordTok{rlnorm}\NormalTok{(}\DecValTok{30}\NormalTok{)))}
\KeywordTok{hist}\NormalTok{(sampdist)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-146-1.pdf}

\begin{quote}
Про функции для генерации случайных чисел и про визуализацию мы поговорим в следующие дни.
\end{quote}

Если хотите познакомиться с семейством \texttt{apply()} чуточку ближе, то рекомендую \href{https://www.datacamp.com/community/tutorials/r-tutorial-apply-family}{вот этот туториал}.

В заключение стоит сказать, что семейство функций \texttt{apply()} --- это очень сильное колдунство, но в tidyverse оно практически полностью перекрывается функциями из пакета \texttt{purrr}. Впрочем, если вы поняли логику \texttt{apply()}, то при желании вы легко сможете переключиться на альтернативы из пакета \texttt{purrr}.

\#Введение в tidyverse \{\#tidy\_intro\}

\hypertarget{tidy_verse}{%
\section{Вселенная tidyverse}\label{tidy_verse}}

tidyverse - это не один, а целое множество пакетов. Есть ключевые пакеты (ядро тайдиверса), а есть побочные - в основном для работы со специфическими видами данных.

\href{https://www.tidyverse.org}{\emph{tidyverse}} --- это набор пакетов:

\begin{itemize}
\tightlist
\item
  \emph{ggplot2}, для визуализации
\item
  \emph{tibble}, для работы с тибблами, продвинутый вариант датафрейма
\item
  \emph{tidyr}, для формата tidy data
\item
  \emph{readr}, для чтения файлов в R
\item
  \emph{purrr}, для функционального программирования (замена семейства функций *apply())
\item
  \emph{dplyr}, для преобразованиия данных
\item
  \emph{stringr}, для работы со строковыми переменными
\item
  \emph{forcats}, для работы с переменными-факторами
\end{itemize}

Полезно также знать о следующих пакетах, не включенных в ядро, но также считающихся частью тайдиверса:

\begin{itemize}
\tightlist
\item
  \emph{vroom}, для быстрой загрузки табоичных данных
\item
  \emph{readxl}, для чтения .xls и .xlsx
\item
  \emph{jsonlite}, для работы с JSON
\item
  \emph{xml}, для работы с XML
\item
  \emph{DBI}, для работы с базами данных
\item
  \emph{rvest}, для веб-скреппинга
\item
  \emph{lubridate}, для работы с временем
\item
  \emph{tidytext}, для работы с текстами и корпусами
\item
  \emph{glue}, для продвинутого объединения строк
\item
  \emph{magrtittr}, с несколькими вариантами pipe оператора
\item
  \emph{tidymodels}, для моделирования и машинного обучения\footnote{Как и пакет \texttt{tidyverse}, \texttt{tidymodels} --- это пакет с несколькими пакетами.}
\item
  \emph{dtplyr}, для ускорения \texttt{dplyr} за счет перевод синтаксиса на \texttt{data.table}
\end{itemize}

И это еще не все пакеты tidyverse! Есть еще много других небольших пакетов, которые тоже считаются частью tidyverse. Кроме официальных пакетов tidyverse есть множество пакетов, которые пытаются соответствовать принципам tidyverse и дополняют его.

Все пакеты tidyverse объединены tidy философией и взаимосовместимым синтаксисом. Это означает, что, во многих случаях даже не нужно думать о том, из какого именно пакета тайдиверса пришла функция. Можно просто установить и загрузить пакет \texttt{tidyverse}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Пакет \texttt{tidyverse} --- это такой \href{https://cs11.pikabu.ru/post_img/big/2019/03/12/11/1552415351186680692.jpg}{пакет с пакетами}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## -- Attaching packages --------------------------------------- tidyverse 1.3.0 --
\end{verbatim}

\begin{verbatim}
## v ggplot2 3.3.2     v purrr   0.3.4
## v tibble  3.0.4     v dplyr   1.0.2
## v tidyr   1.1.2     v stringr 1.4.0
## v readr   1.4.0     v forcats 0.5.0
\end{verbatim}

\begin{verbatim}
## -- Conflicts ------------------------------------------ tidyverse_conflicts() --
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()
\end{verbatim}

Подключение пакета \texttt{tidyverse} автоматически приводит к подключению ядра tidyverse, остальные же пакеты нужно подключать дополнительно при необходимости.

\hypertarget{ux437ux430ux433ux440ux443ux437ux43aux430-ux434ux430ux43dux43dux44bux445-ux441-ux43fux43eux43cux43eux449ux44cux44e-readr}{%
\section{\texorpdfstring{Загрузка данных с помощью \texttt{readr}}{Загрузка данных с помощью readr}}\label{ux437ux430ux433ux440ux443ux437ux43aux430-ux434ux430ux43dux43dux44bux445-ux441-ux43fux43eux43cux43eux449ux44cux44e-readr}}

Стандартной функцией для чтения \texttt{.csv} файлов в R является функция \texttt{read.csv()}, но мы будем использовать функцию \texttt{read\_csv()} из пакета \texttt{readr}. Синтаксис функции \texttt{read\_csv()} очень похож на \texttt{read.csv()}: первым аргументом является путь к файлу (в том числе можно использовать URL), некоторые остальные параметры тоже совпадают.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{,}
                   \DataTypeTok{na =} \KeywordTok{c}\NormalTok{(}\StringTok{"-"}\NormalTok{, }\StringTok{"-99"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: Missing column names filled in: 'X1' [1]
\end{verbatim}

\begin{verbatim}
## 
## -- Column specification --------------------------------------------------------
## cols(
##   X1 = col_double(),
##   name = col_character(),
##   Gender = col_character(),
##   `Eye color` = col_character(),
##   Race = col_character(),
##   `Hair color` = col_character(),
##   Height = col_double(),
##   Publisher = col_character(),
##   `Skin color` = col_character(),
##   Alignment = col_character(),
##   Weight = col_double()
## )
\end{verbatim}

Подробнее про импорт данных, в том числе в tidyverse, смотри в @ref(real\_data).

\#\#tibble

Когда мы загрузили данные с помощью \texttt{read\_csv()}, то мы получили \texttt{tibble}, а не \texttt{data.frame}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(heroes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "spec_tbl_df" "tbl_df"      "tbl"         "data.frame"
\end{verbatim}

Тиббл (\texttt{tibble}) - это такой ``усовершенствованный'' \texttt{data.frame}. \href{https://www.jumpingrivers.com/blog/the-trouble-with-tibbles/}{Почти} все, что работает с \texttt{data.frame}, работает и с тибблами. Однако у тибблов есть свои дополнительные фишки. Самая очевидная из них - более аккуратный вывод в консоль:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
##  2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  4     3 Abom~ Male   green       Huma~ No Hair         203 Marvel C~
##  5     4 Abra~ Male   blue        Cosm~ Black            NA Marvel C~
##  6     5 Abso~ Male   blue        Human No Hair         193 Marvel C~
##  7     6 Adam~ Male   blue        <NA>  Blond            NA NBC - He~
##  8     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  9     8 Agen~ Female blue        <NA>  Blond           173 Marvel C~
## 10     9 Agen~ Male   brown       Human Brown           178 Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

Выводятся только первые 10 строк, если какие-то колонки не влезают на экран, то они просто перечислены внизу. Ну а тип данных написан прямо под названием колонки.

Функции различных пакетов tidyverse сами конвертируют в тиббл при необходимости. Если же нужно это сделать самостоятельно, то можно это сделать так:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes_df <-}\StringTok{ }\KeywordTok{as.data.frame}\NormalTok{(heroes) }\CommentTok{#создаем простой датафрейм}
\KeywordTok{class}\NormalTok{(heroes_df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "data.frame"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as_tibble}\NormalTok{(heroes_df) }\CommentTok{#превращаем обратно в тиббл}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
##  2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  4     3 Abom~ Male   green       Huma~ No Hair         203 Marvel C~
##  5     4 Abra~ Male   blue        Cosm~ Black            NA Marvel C~
##  6     5 Abso~ Male   blue        Human No Hair         193 Marvel C~
##  7     6 Adam~ Male   blue        <NA>  Blond            NA NBC - He~
##  8     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  9     8 Agen~ Female blue        <NA>  Blond           173 Marvel C~
## 10     9 Agen~ Male   brown       Human Brown           178 Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

\begin{quote}
В дальнейшем мы будем работать только с tidyverse, а это значит, что только с тибблами, а не обычными датафреймами. Тем не менее, тибблы и датафреймы будут в дальнейшем использоваться как синонимы.
\end{quote}

Можно создавать тибблы вручную с помощью функции \texttt{tibble()}, которая работает аналогично функции \texttt{data.frame()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{a =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{,}
  \DataTypeTok{b =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 2
##       a b    
##   <int> <chr>
## 1     1 a    
## 2     2 b    
## 3     3 c
\end{verbatim}

\hypertarget{pipe}{%
\section{\texorpdfstring{magrittr::\texttt{\%\textgreater{}\%}}{magrittr::\%\textgreater\%}}\label{pipe}}

Оператор \texttt{\%\textgreater{}\%} называется ``пайпом'' (pipe), т.е. ``трубой''. Он означает, что следующая функция (справа от пайпа) принимает на вход в качестве первого аргумента результат выполнения предыдущей функции (той, что слева). Фактически, это примерно то же самое, что и вставлять результат выполнения функции в качестве первого аргумента в другую функцию. Просто выглядит это красивее и читабельнее. Как будто данные пропускаются через трубы функций или конвеерную ленту на заводе, если хотите. А то, что первый параметр функции - это почти всегда данные, работает нам здесь на руку. Этот оператор взят из пакета \texttt{magrittr}\footnote{Если быть точным, то оператор \texttt{\%\textgreater{}\%} был импортирован во все основные пакеты tidyverse, а сам пакет \texttt{magrittr} не входит в базовый набор tidyverse. Тем не менее, в самом \texttt{magrittr} есть еще несколько интересных операторов.}. Возможно, даже если вы не захотите пользоваться tidyverse, использование пайпов Вам понравится.

Важно понимать, что пайп не дает какой-то дополнительной функциональности или дополнительной скорости работы\footnote{Даже наоборот, использование пайпов незначительно снижает скорость выполнения команды.}. Он создан исключительно для читабельности и комфорта.

С помощью пайпов вот эту команду\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{abs}\NormalTok{(}\KeywordTok{sin}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{22}\NormalTok{))))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 16.72656
\end{verbatim}

\ldots можно переписать вот так:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{22} \OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{sin}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{abs}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{sqrt}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{sum}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 16.72656
\end{verbatim}

В очень редких случаях результат выполнения функции нужно вставить не на первую позицию (или же мы хотим использовать его несколько раз). В этих случаях можно использовать \texttt{.}, чтобы обозначить, куда мы хотим вставить результат выполнения выражения слева от \texttt{\%\textgreater{}\%}.

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Всем привет!"} \OperatorTok{%>%}
\StringTok{  }\KeywordTok{c}\NormalTok{(}\StringTok{"--"}\NormalTok{, ., }\StringTok{"--"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "--"           "Всем привет!" "--"
\end{verbatim}

\hypertarget{ux433ux43bux430ux432ux43dux44bux435-ux43fux430ux43aux435ux442ux44b-tidyverse-dplyr-ux438-tidyr}{%
\section{\texorpdfstring{Главные пакеты tidyverse: \texttt{dplyr} и \texttt{tidyr}}{Главные пакеты tidyverse: dplyr и tidyr}}\label{ux433ux43bux430ux432ux43dux44bux435-ux43fux430ux43aux435ux442ux44b-tidyverse-dplyr-ux438-tidyr}}

\texttt{dplyr}\footnote{\href{https://community.rstudio.com/t/pronunciations-of-common-r-terms/1810}{Есть споры о том, как это правильно читать}. Используемые варианты: \emph{диплаер}, \emph{диплюр}, \emph{диплир}.} --- это самая основа всего \texttt{tidyverse}. Этот пакет предоставляет основные функции для манипуляции с тибблами. Пакет \texttt{dplyr} является наследником и более усовершенствованной версией \texttt{plyr}, так что если увидите использование пакета \texttt{plyr}, то, скорее всего, скрипт был написан очень давно.

Пакет \texttt{tidyr} дополняет \texttt{dplyr}, предоставляя полезные функции для тайдификации тибблов.
Тайдификация (``аккуратизация'') данных означает приведение табличных данных к такому формату, в котором:

\begin{itemize}
\tightlist
\item
  Каждая переменная имеет собственный столбец
\item
  Каждый наблюдение имеет собственную строку
\item
  Каждое значение имеет свою собственную ячейку
\end{itemize}

Впрочем, многие функции \texttt{dplyr} часто используются при тайдификации, так же как и многие функции \texttt{tidyr} имеет применение вне тайдификации. В общем, функционал этих двух пакетов несколько смешался, поэтому мы будем рассматривать их вместе. А чтобы представлять, какая функция относится к какому пакету (хотя запоминать это необязательно), я буду использовать запись с двумя двоеточиями \texttt{::}, которая обычно используется для использования функции без подгрузки всего пакета, при первом упоминании функции.

Пакет \texttt{tidyr} --- это более усовершенствованная версия пакета \texttt{reshape2}, который в свою очередь является усовершенствованной версией \texttt{reshape}. По аналогии с \texttt{plyr}, если вы видите использование этих пакетов, то это указывает на то, что перед вами морально устаревший код.

Код с использованием \texttt{dplyr} и \texttt{tidyr}сильно непохож на то, что мы видели раньше. Большинство функций \texttt{dplyr} и \texttt{tidyr} работают с целым тибблом сразу, принимая его в качестве первого аргумента и возвращая измененный тиббл. Это позволяет превратить весь код в последовательный набор применяемых функций, соединенный пайпами. На практике это выглядит очень элегантно, и вы в этом скоро убедитесь.

\hypertarget{tidy_select_cols}{%
\section{Работа с колонками тиббла}\label{tidy_select_cols}}

\hypertarget{ux432ux44bux431ux43eux440-ux43aux43eux43bux43eux43dux43eux43a-dplyrselect}{%
\subsection{\texorpdfstring{Выбор колонок: \texttt{dplyr::select()}}{Выбор колонок: dplyr::select()}}\label{ux432ux44bux431ux43eux440-ux43aux43eux43bux43eux43dux43eux43a-dplyrselect}}

Функция \texttt{dplyr::select()} позволяет выбирать колонки по номеру или имени (кавычки не нужны).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 2
##       X1 Race             
##    <dbl> <chr>            
##  1     0 Human            
##  2     1 Icthyo Sapien    
##  3     2 Ungaran          
##  4     3 Human / Radiation
##  5     4 Cosmic Entity    
##  6     5 Human            
##  7     6 <NA>             
##  8     7 Human            
##  9     8 <NA>             
## 10     9 Human            
## # ... with 724 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, Race, Publisher, }\StringTok{`}\DataTypeTok{Hair color}\StringTok{`}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 4
##    name          Race              Publisher         `Hair color`
##    <chr>         <chr>             <chr>             <chr>       
##  1 A-Bomb        Human             Marvel Comics     No Hair     
##  2 Abe Sapien    Icthyo Sapien     Dark Horse Comics No Hair     
##  3 Abin Sur      Ungaran           DC Comics         No Hair     
##  4 Abomination   Human / Radiation Marvel Comics     No Hair     
##  5 Abraxas       Cosmic Entity     Marvel Comics     Black       
##  6 Absorbing Man Human             Marvel Comics     No Hair     
##  7 Adam Monroe   <NA>              NBC - Heroes      Blond       
##  8 Adam Strange  Human             DC Comics         Blond       
##  9 Agent 13      <NA>              Marvel Comics     Blond       
## 10 Agent Bob     Human             Marvel Comics     Brown       
## # ... with 724 more rows
\end{verbatim}

Обратите внимание, если в названии колонки присутствует пробел или, например, колонка начинается с цифры или точки и цифры, то это синтаксически невалидное имя (\ref{variables}). Это не значит, что такие названия колонок недопустимы. Но такие названия колонок нужно обособлять ` грависом (правый штрих, на клавиатуре находится там же где и буква ё и \textasciitilde).

Еще обратите внимание на то, что функции tidyverse не изменяют сами изначальные тибблы/датафреймы. Это означает, что если вы хотите полученный результат сохранить, то нужно добавить присвоение:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes_some_cols <-}\StringTok{ }\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, Race, Publisher, }\StringTok{`}\DataTypeTok{Hair color}\StringTok{`}\NormalTok{)}
\NormalTok{heroes_some_cols}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 4
##    name          Race              Publisher         `Hair color`
##    <chr>         <chr>             <chr>             <chr>       
##  1 A-Bomb        Human             Marvel Comics     No Hair     
##  2 Abe Sapien    Icthyo Sapien     Dark Horse Comics No Hair     
##  3 Abin Sur      Ungaran           DC Comics         No Hair     
##  4 Abomination   Human / Radiation Marvel Comics     No Hair     
##  5 Abraxas       Cosmic Entity     Marvel Comics     Black       
##  6 Absorbing Man Human             Marvel Comics     No Hair     
##  7 Adam Monroe   <NA>              NBC - Heroes      Blond       
##  8 Adam Strange  Human             DC Comics         Blond       
##  9 Agent 13      <NA>              Marvel Comics     Blond       
## 10 Agent Bob     Human             Marvel Comics     Brown       
## # ... with 724 more rows
\end{verbatim}

\hypertarget{tidyselect}{%
\subsection{Мини-язык tidyselect для выбора колонок}\label{tidyselect}}

Для выбора столбцов (не только в \texttt{select()}, но и для других функций tidyverse) используется специальный мини-язык tidyselect из одноименного пакета\footnote{Как и в случае с \texttt{magrittr}, пакет \texttt{tidyselect} не содержатся в базовом tidyverse, но функции импортируются основыми пакетами tidyverse.}. tidyselect дает очень широкие возможности для выбора колонок.

Можно использовать оператор \texttt{:} для выбора нескольких соседних колонок (по аналогии с созданием числового вектора с шагом 1).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name}\OperatorTok{:}\NormalTok{Publisher)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 7
##    name       Gender `Eye color` Race          `Hair color` Height Publisher    
##    <chr>      <chr>  <chr>       <chr>         <chr>         <dbl> <chr>        
##  1 A-Bomb     Male   yellow      Human         No Hair         203 Marvel Comics
##  2 Abe Sapien Male   blue        Icthyo Sapien No Hair         191 Dark Horse C~
##  3 Abin Sur   Male   blue        Ungaran       No Hair         185 DC Comics    
##  4 Abominati~ Male   green       Human / Radi~ No Hair         203 Marvel Comics
##  5 Abraxas    Male   blue        Cosmic Entity Black            NA Marvel Comics
##  6 Absorbing~ Male   blue        Human         No Hair         193 Marvel Comics
##  7 Adam Monr~ Male   blue        <NA>          Blond            NA NBC - Heroes 
##  8 Adam Stra~ Male   blue        Human         Blond           185 DC Comics    
##  9 Agent 13   Female blue        <NA>          Blond           173 Marvel Comics
## 10 Agent Bob  Male   brown       Human         Brown           178 Marvel Comics
## # ... with 724 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name}\OperatorTok{:}\StringTok{`}\DataTypeTok{Eye color}\StringTok{`}\NormalTok{, Publisher}\OperatorTok{:}\NormalTok{Weight)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 7
##    name         Gender `Eye color` Publisher       `Skin color` Alignment Weight
##    <chr>        <chr>  <chr>       <chr>           <chr>        <chr>      <dbl>
##  1 A-Bomb       Male   yellow      Marvel Comics   <NA>         good         441
##  2 Abe Sapien   Male   blue        Dark Horse Com~ blue         good          65
##  3 Abin Sur     Male   blue        DC Comics       red          good          90
##  4 Abomination  Male   green       Marvel Comics   <NA>         bad          441
##  5 Abraxas      Male   blue        Marvel Comics   <NA>         bad           NA
##  6 Absorbing M~ Male   blue        Marvel Comics   <NA>         bad          122
##  7 Adam Monroe  Male   blue        NBC - Heroes    <NA>         good          NA
##  8 Adam Strange Male   blue        DC Comics       <NA>         good          88
##  9 Agent 13     Female blue        Marvel Comics   <NA>         good          61
## 10 Agent Bob    Male   brown       Marvel Comics   <NA>         good          81
## # ... with 724 more rows
\end{verbatim}

Используя \texttt{!} можно вырезать ненужные колонки.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\OperatorTok{!}\NormalTok{X1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 10
##    name  Gender `Eye color` Race  `Hair color` Height Publisher `Skin color`
##    <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>     <chr>       
##  1 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~ <NA>        
##  2 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~ blue        
##  3 Abin~ Male   blue        Unga~ No Hair         185 DC Comics red         
##  4 Abom~ Male   green       Huma~ No Hair         203 Marvel C~ <NA>        
##  5 Abra~ Male   blue        Cosm~ Black            NA Marvel C~ <NA>        
##  6 Abso~ Male   blue        Human No Hair         193 Marvel C~ <NA>        
##  7 Adam~ Male   blue        <NA>  Blond            NA NBC - He~ <NA>        
##  8 Adam~ Male   blue        Human Blond           185 DC Comics <NA>        
##  9 Agen~ Female blue        <NA>  Blond           173 Marvel C~ <NA>        
## 10 Agen~ Male   brown       Human Brown           178 Marvel C~ <NA>        
## # ... with 724 more rows, and 2 more variables: Alignment <chr>, Weight <dbl>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\OperatorTok{!}\NormalTok{(Gender}\OperatorTok{:}\NormalTok{Height))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 6
##       X1 name          Publisher         `Skin color` Alignment Weight
##    <dbl> <chr>         <chr>             <chr>        <chr>      <dbl>
##  1     0 A-Bomb        Marvel Comics     <NA>         good         441
##  2     1 Abe Sapien    Dark Horse Comics blue         good          65
##  3     2 Abin Sur      DC Comics         red          good          90
##  4     3 Abomination   Marvel Comics     <NA>         bad          441
##  5     4 Abraxas       Marvel Comics     <NA>         bad           NA
##  6     5 Absorbing Man Marvel Comics     <NA>         bad          122
##  7     6 Adam Monroe   NBC - Heroes      <NA>         good          NA
##  8     7 Adam Strange  DC Comics         <NA>         good          88
##  9     8 Agent 13      Marvel Comics     <NA>         good          61
## 10     9 Agent Bob     Marvel Comics     <NA>         good          81
## # ... with 724 more rows
\end{verbatim}

Другие известные нам логические операторы (\texttt{\&} и \texttt{\textbar{}}) тоже работают в tidyselect.

В дополнение к логическим операторам и \texttt{:}, в tidyselect есть набор вспомогательных функций, работающих исключительно в контексте выбора колонок с помощью tidyselect.

Вспомогательная функция \texttt{last\_col()} позволит обратиться к последней колонке тиббла:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name}\OperatorTok{:}\KeywordTok{last_col}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 10
##    name  Gender `Eye color` Race  `Hair color` Height Publisher `Skin color`
##    <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>     <chr>       
##  1 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~ <NA>        
##  2 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~ blue        
##  3 Abin~ Male   blue        Unga~ No Hair         185 DC Comics red         
##  4 Abom~ Male   green       Huma~ No Hair         203 Marvel C~ <NA>        
##  5 Abra~ Male   blue        Cosm~ Black            NA Marvel C~ <NA>        
##  6 Abso~ Male   blue        Human No Hair         193 Marvel C~ <NA>        
##  7 Adam~ Male   blue        <NA>  Blond            NA NBC - He~ <NA>        
##  8 Adam~ Male   blue        Human Blond           185 DC Comics <NA>        
##  9 Agen~ Female blue        <NA>  Blond           173 Marvel C~ <NA>        
## 10 Agen~ Male   brown       Human Brown           178 Marvel C~ <NA>        
## # ... with 724 more rows, and 2 more variables: Alignment <chr>, Weight <dbl>
\end{verbatim}

А функция \texttt{everything()} позволяет выбрать все колонки.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\KeywordTok{everything}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
##  2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  4     3 Abom~ Male   green       Huma~ No Hair         203 Marvel C~
##  5     4 Abra~ Male   blue        Cosm~ Black            NA Marvel C~
##  6     5 Abso~ Male   blue        Human No Hair         193 Marvel C~
##  7     6 Adam~ Male   blue        <NA>  Blond            NA NBC - He~
##  8     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  9     8 Agen~ Female blue        <NA>  Blond           173 Marvel C~
## 10     9 Agen~ Male   brown       Human Brown           178 Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

При этом \texttt{everything()} не будет дублировать выбранные колонки, поэтому можно использовать \texttt{everything()} для перестановки колонок в тиббле:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, Publisher, }\KeywordTok{everything}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##    name  Publisher    X1 Gender `Eye color` Race  `Hair color` Height
##    <chr> <chr>     <dbl> <chr>  <chr>       <chr> <chr>         <dbl>
##  1 A-Bo~ Marvel C~     0 Male   yellow      Human No Hair         203
##  2 Abe ~ Dark Hor~     1 Male   blue        Icth~ No Hair         191
##  3 Abin~ DC Comics     2 Male   blue        Unga~ No Hair         185
##  4 Abom~ Marvel C~     3 Male   green       Huma~ No Hair         203
##  5 Abra~ Marvel C~     4 Male   blue        Cosm~ Black            NA
##  6 Abso~ Marvel C~     5 Male   blue        Human No Hair         193
##  7 Adam~ NBC - He~     6 Male   blue        <NA>  Blond            NA
##  8 Adam~ DC Comics     7 Male   blue        Human Blond           185
##  9 Agen~ Marvel C~     8 Female blue        <NA>  Blond           173
## 10 Agen~ Marvel C~     9 Male   brown       Human Brown           178
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

Впрочем, для перестановки колонок удобнее использовать специальную функцию \texttt{relocate()} (@ref(tidy\_relocate))
Можно даже выбирать колонки по паттернам в названиях. Например, с помощью \texttt{ends\_with()} можно выбрать все колонки, заканчивающиеся одинаковым суффиксом:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\KeywordTok{ends_with}\NormalTok{(}\StringTok{"color"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 3
##    `Eye color` `Hair color` `Skin color`
##    <chr>       <chr>        <chr>       
##  1 yellow      No Hair      <NA>        
##  2 blue        No Hair      blue        
##  3 blue        No Hair      red         
##  4 green       No Hair      <NA>        
##  5 blue        Black        <NA>        
##  6 blue        No Hair      <NA>        
##  7 blue        Blond        <NA>        
##  8 blue        Blond        <NA>        
##  9 blue        Blond        <NA>        
## 10 brown       Brown        <NA>        
## # ... with 724 more rows
\end{verbatim}

Аналогично, с помощью функции \texttt{starts\_with()} можно найти колонки с одинаковым префиксом, с помощью \texttt{contains()} --- все колонки с выбранным паттерном в любой части названия колонки\footnote{Выбранный паттерн будет найден посимвольно, если же вы хотите искать по регулярным выражениям, то вместо \texttt{contains()} нужно использовать \texttt{matches()}.}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\KeywordTok{starts_with}\NormalTok{(}\StringTok{"Eye"}\NormalTok{) }\OperatorTok{&}\StringTok{ }\KeywordTok{ends_with}\NormalTok{(}\StringTok{"color"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 1
##    `Eye color`
##    <chr>      
##  1 yellow     
##  2 blue       
##  3 blue       
##  4 green      
##  5 blue       
##  6 blue       
##  7 blue       
##  8 blue       
##  9 blue       
## 10 brown      
## # ... with 724 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\KeywordTok{contains}\NormalTok{(}\StringTok{"eight"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 2
##    Height Weight
##     <dbl>  <dbl>
##  1    203    441
##  2    191     65
##  3    185     90
##  4    203    441
##  5     NA     NA
##  6    193    122
##  7     NA     NA
##  8    185     88
##  9    173     61
## 10    178     81
## # ... with 724 more rows
\end{verbatim}

Ну и наконец, можно выбирать по содержимому колонок с помощью \texttt{where()}. Это напоминает применение \texttt{sapply()}(@ref(apply\_other)) на датафрейме для индексирования колонок: в качестве аргумента для \texttt{where} принимается функция, которая применяется для каждой из колонок, после чего выбираются только те колонки, для которых было получено \texttt{TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\KeywordTok{where}\NormalTok{(is.numeric))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 3
##       X1 Height Weight
##    <dbl>  <dbl>  <dbl>
##  1     0    203    441
##  2     1    191     65
##  3     2    185     90
##  4     3    203    441
##  5     4     NA     NA
##  6     5    193    122
##  7     6     NA     NA
##  8     7    185     88
##  9     8    173     61
## 10     9    178     81
## # ... with 724 more rows
\end{verbatim}

Функция \texttt{where()} дает невиданную мощь. Например, можно выбрать все колонки без \texttt{NA}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\KeywordTok{where}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) }\OperatorTok{!}\KeywordTok{any}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x))))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 3
##       X1 name          Publisher        
##    <dbl> <chr>         <chr>            
##  1     0 A-Bomb        Marvel Comics    
##  2     1 Abe Sapien    Dark Horse Comics
##  3     2 Abin Sur      DC Comics        
##  4     3 Abomination   Marvel Comics    
##  5     4 Abraxas       Marvel Comics    
##  6     5 Absorbing Man Marvel Comics    
##  7     6 Adam Monroe   NBC - Heroes     
##  8     7 Adam Strange  DC Comics        
##  9     8 Agent 13      Marvel Comics    
## 10     9 Agent Bob     Marvel Comics    
## # ... with 724 more rows
\end{verbatim}

\#\#\#Переименование колонок: \texttt{dplyr::rename()}

Внутри \texttt{select()} можно не только выбирать колонки, но и переименовывать их:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ X1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 1
##       id
##    <dbl>
##  1     0
##  2     1
##  3     2
##  4     3
##  5     4
##  6     5
##  7     6
##  8     7
##  9     8
## 10     9
## # ... with 724 more rows
\end{verbatim}

Однако удобнее для этого использовать специальную функцию \texttt{dplyr::rename()}. Синтаксис у нее такой же, как и у \texttt{select()}, но \texttt{rename()} не выбрасывает колонки, которые не были упомянуты.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{rename}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ X1)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       id name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
##  2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  4     3 Abom~ Male   green       Huma~ No Hair         203 Marvel C~
##  5     4 Abra~ Male   blue        Cosm~ Black            NA Marvel C~
##  6     5 Abso~ Male   blue        Human No Hair         193 Marvel C~
##  7     6 Adam~ Male   blue        <NA>  Blond            NA NBC - He~
##  8     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  9     8 Agen~ Female blue        <NA>  Blond           173 Marvel C~
## 10     9 Agen~ Male   brown       Human Brown           178 Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

Для массового переименования колонок можно использовать функцию \texttt{rename\_with()}. Эта функция так же использует tidyselect синтаксис для выбора колонок (по умолчанию выбираются все колонки) и применяет функцию в качестве аргумента, которая изменяет

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{rename_with}\NormalTok{(make.names)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Gender Eye.color Race  Hair.color Height Publisher Skin.color
##    <dbl> <chr> <chr>  <chr>     <chr> <chr>       <dbl> <chr>     <chr>     
##  1     0 A-Bo~ Male   yellow    Human No Hair       203 Marvel C~ <NA>      
##  2     1 Abe ~ Male   blue      Icth~ No Hair       191 Dark Hor~ blue      
##  3     2 Abin~ Male   blue      Unga~ No Hair       185 DC Comics red       
##  4     3 Abom~ Male   green     Huma~ No Hair       203 Marvel C~ <NA>      
##  5     4 Abra~ Male   blue      Cosm~ Black          NA Marvel C~ <NA>      
##  6     5 Abso~ Male   blue      Human No Hair       193 Marvel C~ <NA>      
##  7     6 Adam~ Male   blue      <NA>  Blond          NA NBC - He~ <NA>      
##  8     7 Adam~ Male   blue      Human Blond         185 DC Comics <NA>      
##  9     8 Agen~ Female blue      <NA>  Blond         173 Marvel C~ <NA>      
## 10     9 Agen~ Male   brown     Human Brown         178 Marvel C~ <NA>      
## # ... with 724 more rows, and 2 more variables: Alignment <chr>, Weight <dbl>
\end{verbatim}

\#\#\#Перестановка колонок: \texttt{dplyr::relocate()} \{\#tidy\_relocate\}

Для изменения порядка колонок можно использовать функцию \texttt{relocate()}. Она тоже работает похожим образом на \texttt{select()} и \texttt{rename()}\footnote{\texttt{relocate()} не позволяет переименовывать колонки в отличие от \texttt{select()} и \texttt{rename()}}. Как и \texttt{rename()}, функция \texttt{relocate()} не выкидывает неиспользованные колонки:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{relocate}\NormalTok{(Publisher)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##    Publisher    X1 name  Gender `Eye color` Race  `Hair color` Height
##    <chr>     <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl>
##  1 Marvel C~     0 A-Bo~ Male   yellow      Human No Hair         203
##  2 Dark Hor~     1 Abe ~ Male   blue        Icth~ No Hair         191
##  3 DC Comics     2 Abin~ Male   blue        Unga~ No Hair         185
##  4 Marvel C~     3 Abom~ Male   green       Huma~ No Hair         203
##  5 Marvel C~     4 Abra~ Male   blue        Cosm~ Black            NA
##  6 Marvel C~     5 Abso~ Male   blue        Human No Hair         193
##  7 NBC - He~     6 Adam~ Male   blue        <NA>  Blond            NA
##  8 DC Comics     7 Adam~ Male   blue        Human Blond           185
##  9 Marvel C~     8 Agen~ Female blue        <NA>  Blond           173
## 10 Marvel C~     9 Agen~ Male   brown       Human Brown           178
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

При этом \texttt{relocate()} имеет дополнительные параметры \texttt{.after\ =} и \texttt{.before\ =}, которые позволяют выбирать, куда поместить выбранные колонки.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{relocate}\NormalTok{(Publisher, }\DataTypeTok{.after =}\NormalTok{ name)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Publisher Gender `Eye color` Race  `Hair color` Height
##    <dbl> <chr> <chr>     <chr>  <chr>       <chr> <chr>         <dbl>
##  1     0 A-Bo~ Marvel C~ Male   yellow      Human No Hair         203
##  2     1 Abe ~ Dark Hor~ Male   blue        Icth~ No Hair         191
##  3     2 Abin~ DC Comics Male   blue        Unga~ No Hair         185
##  4     3 Abom~ Marvel C~ Male   green       Huma~ No Hair         203
##  5     4 Abra~ Marvel C~ Male   blue        Cosm~ Black            NA
##  6     5 Abso~ Marvel C~ Male   blue        Human No Hair         193
##  7     6 Adam~ NBC - He~ Male   blue        <NA>  Blond            NA
##  8     7 Adam~ DC Comics Male   blue        Human Blond           185
##  9     8 Agen~ Marvel C~ Female blue        <NA>  Blond           173
## 10     9 Agen~ Marvel C~ Male   brown       Human Brown           178
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

\texttt{relocate()} очень хорошо работает в сочетании с выбором колонок с помощью tidyselect. Например, можно передвинуть в одно место все колонки с одним типом данных:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{relocate}\NormalTok{(Publisher, }\KeywordTok{where}\NormalTok{(is.numeric), }\DataTypeTok{.after =}\NormalTok{ name)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##    name  Publisher    X1 Height Weight Gender `Eye color` Race  `Hair color`
##    <chr> <chr>     <dbl>  <dbl>  <dbl> <chr>  <chr>       <chr> <chr>       
##  1 A-Bo~ Marvel C~     0    203    441 Male   yellow      Human No Hair     
##  2 Abe ~ Dark Hor~     1    191     65 Male   blue        Icth~ No Hair     
##  3 Abin~ DC Comics     2    185     90 Male   blue        Unga~ No Hair     
##  4 Abom~ Marvel C~     3    203    441 Male   green       Huma~ No Hair     
##  5 Abra~ Marvel C~     4     NA     NA Male   blue        Cosm~ Black       
##  6 Abso~ Marvel C~     5    193    122 Male   blue        Human No Hair     
##  7 Adam~ NBC - He~     6     NA     NA Male   blue        <NA>  Blond       
##  8 Adam~ DC Comics     7    185     88 Male   blue        Human Blond       
##  9 Agen~ Marvel C~     8    173     61 Female blue        <NA>  Blond       
## 10 Agen~ Marvel C~     9    178     81 Male   brown       Human Brown       
## # ... with 724 more rows, and 2 more variables: `Skin color` <chr>,
## #   Alignment <chr>
\end{verbatim}

Последняя важная функция для выбора колонок --- \texttt{pull()}. Эта функция делает то же самое, что и индексирование с помощью \texttt{\$}, т.е. вытаскивает из тиббла вектор с выбранным названием. Это лучше вписывается в логику tidyverse, поскольку позволяет извлечь колонку из тиббла с использованием пайпа:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(Height) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pull}\NormalTok{() }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{head}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 203 191 185 203  NA 193
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pull}\NormalTok{(Height) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{head}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 203 191 185 203  NA 193
\end{verbatim}

У функции \texttt{pull()} есть аргумент \texttt{name\ =}, который позволяет создать проименованный вектор:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pull}\NormalTok{(Height, name) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{head}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        A-Bomb    Abe Sapien      Abin Sur   Abomination       Abraxas 
##           203           191           185           203            NA 
## Absorbing Man 
##           193
\end{verbatim}

В отличие от базового R, tidyverse нигде не сокращает имплицитно результат вычислений до вектора, поэтому функция \texttt{pull()} - это основной способ извлечения колонки из тиббла как вектора.

\hypertarget{tidy_select_rows}{%
\section{Работа со строками тиббла}\label{tidy_select_rows}}

\hypertarget{tidy_slice}{%
\subsection{\texorpdfstring{Выбор строк по номеру: \texttt{dplyr::slice()}}{Выбор строк по номеру: dplyr::slice()}}\label{tidy_slice}}

Начнем с выбора строк. Функция \texttt{dplyr::slice()} выбирает строчки по их числовому индексу.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 11
##      X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##   <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
## 1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
## 2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
## 3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
## # ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

\hypertarget{tidy_filter}{%
\subsection{\texorpdfstring{Выбор строк по условию: \texttt{dplyr::filter()}}{Выбор строк по условию: dplyr::filter()}}\label{tidy_filter}}

Функция \texttt{dplyr::filter()} делает то же самое, что и \texttt{slice()}, но уже по условию. Причем для условий нужно использовать не векторы из тиббла, а название колонок (без кавычек) как будто бы они были переменными в окружении.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{filter}\NormalTok{(Publisher }\OperatorTok{==}\StringTok{ "DC Comics"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 215 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  2     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  3    13 Alan~ Male   blue        <NA>  Blond           180 DC Comics
##  4    16 Alfr~ Male   blue        Human Black           178 DC Comics
##  5    19 Amazo Male   red         Andr~ <NA>            257 DC Comics
##  6    27 Anim~ Male   blue        Human Blond           183 DC Comics
##  7    31 Anti~ Male   yellow      God ~ No Hair          61 DC Comics
##  8    35 Aqua~ Male   blue        <NA>  Blond            NA DC Comics
##  9    36 Aqua~ Male   blue        Atla~ Black           178 DC Comics
## 10    37 Aqua~ Male   blue        Atla~ Blond           185 DC Comics
## # ... with 205 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

\hypertarget{slice_family}{%
\subsection{\texorpdfstring{Семейство функций \texttt{slice()}}{Семейство функций slice()}}\label{slice_family}}

У функции \texttt{slice()} есть множество родственников, которые объединяют функционал обычного \texttt{slice()} и \texttt{filter()}. Например, с помощью функций \texttt{dplyr::slice\_max()} и \texttt{dplyr::slice\_min()} можно выбрать заданное количество строк, содержащих наибольшие или наименьшие значения по колонке соответственно:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice_max}\NormalTok{(Weight, }\DataTypeTok{n =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 11
##      X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##   <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
## 1   575 Sasq~ Male   red         <NA>  Orange          305 Marvel C~
## 2   373 Jugg~ Male   blue        Human Red             287 Marvel C~
## 3   203 Dark~ Male   red         New ~ No Hair         267 DC Comics
## # ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice_min}\NormalTok{(Weight, }\DataTypeTok{n =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 11
##      X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##   <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
## 1   346 Iron~ Male   blue        <NA>  No Hair          NA Marvel C~
## 2   302 Groot Male   yellow      Flor~ <NA>            701 Marvel C~
## 3   350 Jack~ Male   blue        Human Brown            71 Dark Hor~
## # ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

Функция \texttt{slice\_sample()} позволяет выбирать заданное количество случайных строчек:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice_sample}\NormalTok{(}\DataTypeTok{n =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 11
##      X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##   <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
## 1   274 Gamo~ Female yellow      Zen-~ Black           183 Marvel C~
## 2    68 Batm~ Male   blue        Human black           188 DC Comics
## 3    76 Beet~ Male   <NA>        <NA>  <NA>             NA Marvel C~
## # ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

Или же долю строчек:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice_sample}\NormalTok{(}\DataTypeTok{prop =} \FloatTok{.01}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 7 x 11
##      X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##   <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
## 1    15 Alex~ Male   <NA>        <NA>  <NA>             NA "NBC - H~
## 2   126 Boba~ Male   brown       Huma~ Black           183 "George ~
## 3   119 Bloo~ Female blue        Human Brown           218 "Marvel ~
## 4   324 Herc~ Male   blue        Demi~ Brown           196 "Marvel ~
## 5   490 Nigh~ Male   yellow      <NA>  Indigo          175 "Marvel ~
## 6   164 Catw~ Female green       Human Black           175 "DC Comi~
## 7    86 Bion~ Female blue        Cybo~ Black            NA ""       
## # ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

Если поставить значение параметра \texttt{prop\ =} равным \texttt{1}, то таким образом можно перемешать порядок строчек в тиббле:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice_sample}\NormalTok{(}\DataTypeTok{prop =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1   240 Emma~ Female blue        <NA>  Blond           178 Marvel C~
##  2   374 Junk~ Male   <NA>        Muta~ <NA>             NA Marvel C~
##  3   661 Thor  Male   blue        Asga~ Blond           198 Marvel C~
##  4   235 Elas~ Female brown       Human Brown           168 Dark Hor~
##  5   310 Havok Male   blue        Muta~ Blond           183 Marvel C~
##  6   273 Gamb~ Male   red         Muta~ Brown           185 Marvel C~
##  7   597 Silk  Female brown       Human Black            NA Marvel C~
##  8   480 Myst~ Female yellow (wi~ Muta~ Red / Orange    178 Marvel C~
##  9   277 Gene~ Male   black       Kryp~ Black            NA DC Comics
## 10    42 Ares  Male   brown       <NA>  Brown           185 Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

\hypertarget{tidy_drop_na}{%
\subsection{\texorpdfstring{Удаление строчек с NA: \texttt{tidyr::drop\_na()}}{Удаление строчек с NA: tidyr::drop\_na()}}\label{tidy_drop_na}}

Если нужно выбрать только строчки без пропущенных значений, то можно воспользоваться удобной функцией \texttt{tidyr::drop\_na()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{drop_na}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 50 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  2     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  3    34 Apoc~ Male   red         Muta~ Black           213 Marvel C~
##  4    39 Arch~ Male   blue        Muta~ Blond           183 Marvel C~
##  5    41 Ardi~ Female white       Alien Orange          193 Marvel C~
##  6    56 Azaz~ Male   yellow      Neya~ Black           183 Marvel C~
##  7    74 Beast Male   blue        Muta~ Blue            180 Marvel C~
##  8    75 Beas~ Male   green       Human Green           173 DC Comics
##  9    92 Biza~ Male   black       Biza~ Black           191 DC Comics
## 10   108 Blac~ Male   red         Demon White           191 Marvel C~
## # ... with 40 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

Можно выбрать колонки, наличие \texttt{NA} в которых будет приводить к удалению соответствующих строчек (не затрагивая другие строчки, в которых есть \texttt{NA} в остальных столбцах).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{drop_na}\NormalTok{(Weight)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 495 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
##  2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  4     3 Abom~ Male   green       Huma~ No Hair         203 Marvel C~
##  5     5 Abso~ Male   blue        Human No Hair         193 Marvel C~
##  6     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  7     8 Agen~ Female blue        <NA>  Blond           173 Marvel C~
##  8     9 Agen~ Male   brown       Human Brown           178 Marvel C~
##  9    10 Agen~ Male   <NA>        <NA>  <NA>            191 Marvel C~
## 10    11 Air-~ Male   blue        <NA>  White           188 Marvel C~
## # ... with 485 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

Для выбора колонок в \texttt{drop\_na()} используется tidyselect, с которым мы недавно познакомились (\ref{tidyselect}).

\hypertarget{tidy_arrange}{%
\subsection{\texorpdfstring{Сортировка строк: \texttt{dplyr::arrange()}}{Сортировка строк: dplyr::arrange()}}\label{tidy_arrange}}

Функция \texttt{dplyr::arrange()} сортирует строчки от меньшего к большему (или по алфавиту - для текстовых значений) по выбранной колонке.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{arrange}\NormalTok{(Weight)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1   346 Iron~ Male   blue        <NA>  No Hair          NA Marvel C~
##  2   302 Groot Male   yellow      Flor~ <NA>            701 Marvel C~
##  3   350 Jack~ Male   blue        Human Brown            71 Dark Hor~
##  4   272 Gala~ Male   black       Cosm~ Black           876 Marvel C~
##  5   731 Yoda  Male   brown       Yoda~ White            66 George L~
##  6   255 Fin ~ Male   red         Kaka~ No Hair         975 Marvel C~
##  7   330 Howa~ Male   brown       <NA>  Yellow           79 Marvel C~
##  8   396 Kryp~ Male   blue        Kryp~ White            64 DC Comics
##  9   568 Rock~ Male   brown       Anim~ Brown           122 Marvel C~
## 10   208 Dash  Male   blue        Human Blond           122 Dark Hor~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

Чтобы отсортировать в обратном порядке, воспользуйтесь функцией \texttt{desc()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{arrange}\NormalTok{(}\KeywordTok{desc}\NormalTok{(Weight))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1   575 Sasq~ Male   red         <NA>  Orange        305   Marvel C~
##  2   373 Jugg~ Male   blue        Human Red           287   Marvel C~
##  3   203 Dark~ Male   red         New ~ No Hair       267   DC Comics
##  4   283 Giga~ Female green       <NA>  Red            62.5 DC Comics
##  5   331 Hulk  Male   green       Huma~ Green         244   Marvel C~
##  6   549 Red ~ Male   yellow      Huma~ Black         213   Marvel C~
##  7   119 Bloo~ Female blue        Human Brown         218   Marvel C~
##  8   718 Wolf~ Female green       <NA>  Auburn        366   Marvel C~
##  9   657 Than~ Male   red         Eter~ No Hair       201   Marvel C~
## 10     0 A-Bo~ Male   yellow      Human No Hair       203   Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

Можно сортировать по нескольким колонкам сразу. В таких случаях удобно в качестве первой переменной выбирать переменную, обозначающую принадлежность к группе, а в качестве второй --- континуальную числовую переменную:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{arrange}\NormalTok{(Gender, }\KeywordTok{desc}\NormalTok{(Weight))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1   283 Giga~ Female green       <NA>  Red            62.5 DC Comics
##  2   119 Bloo~ Female blue        Human Brown         218   Marvel C~
##  3   718 Wolf~ Female green       <NA>  Auburn        366   Marvel C~
##  4   591 She-~ Female green       Human Green         201   Marvel C~
##  5   320 Hela  Female green       Asga~ Black         213   Marvel C~
##  6   686 Valk~ Female blue        <NA>  Blond         191   Marvel C~
##  7   596 Sif   Female blue        Asga~ Black         188   Marvel C~
##  8   271 Frig~ Female blue        <NA>  White         180   Marvel C~
##  9   667 Thun~ Female green       <NA>  Red           218   Marvel C~
## 10   592 She-~ Female blue        Huma~ No Hair       183   Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

\hypertarget{tidy_mutate}{%
\section{\texorpdfstring{Создание колонок: \texttt{dplyr::mutate()} и \texttt{dplyr::transmute()}}{Создание колонок: dplyr::mutate() и dplyr::transmute()}}\label{tidy_mutate}}

Функция \texttt{dplyr::mutate()} позволяет создавать новые колонки в тиббле.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{imt =}\NormalTok{ Weight}\OperatorTok{/}\NormalTok{(Height}\OperatorTok{/}\DecValTok{100}\NormalTok{)}\OperatorTok{^}\DecValTok{2}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, imt) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{arrange}\NormalTok{(}\KeywordTok{desc}\NormalTok{(imt))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 2
##    name          imt
##    <chr>       <dbl>
##  1 Utgard-Loki 2510.
##  2 Giganta     1613.
##  3 Red Hulk     139.
##  4 Darkseid     115.
##  5 Machine Man  114.
##  6 Thanos       110.
##  7 Destroyer    108.
##  8 A-Bomb       107.
##  9 Abomination  107.
## 10 Hulk         106.
## # ... with 724 more rows
\end{verbatim}

\texttt{dplyr::transmute()} - это аналог \texttt{mutate()}, который не только создает новые колонки, но и сразу же выкидывает все старые:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{transmute}\NormalTok{(}\DataTypeTok{imt =}\NormalTok{ Weight}\OperatorTok{/}\NormalTok{(Height}\OperatorTok{/}\DecValTok{100}\NormalTok{)}\OperatorTok{^}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 1
##      imt
##    <dbl>
##  1 107. 
##  2  17.8
##  3  26.3
##  4 107. 
##  5  NA  
##  6  32.8
##  7  NA  
##  8  25.7
##  9  20.4
## 10  25.6
## # ... with 724 more rows
\end{verbatim}

Внутри \texttt{mutate()} и \texttt{transmute()} мы можем использовать либо векторизованные операции (длина новой колонки должна равняться длине датафрейма), либо операции, которые возвращают одно значение. В последнем случае значение будет одинаковым на всю колонку, т.е. будет работать правило ресайклинга (\ref{recycling}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{transmute}\NormalTok{(name, }\DataTypeTok{weight_mean =} \KeywordTok{mean}\NormalTok{(Weight, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 2
##    name          weight_mean
##    <chr>               <dbl>
##  1 A-Bomb               112.
##  2 Abe Sapien           112.
##  3 Abin Sur             112.
##  4 Abomination          112.
##  5 Abraxas              112.
##  6 Absorbing Man        112.
##  7 Adam Monroe          112.
##  8 Adam Strange         112.
##  9 Agent 13             112.
## 10 Agent Bob            112.
## # ... with 724 more rows
\end{verbatim}

Однако в функциях \texttt{mutate()} и \texttt{transmute()} правило ресайклинга не будет работать в остальных случаях: если полученный вектор будет не равен 1 или длине датафрейма, то мы получим ошибку.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{one_and_two =} \DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error: Problem with `mutate()` input `one_and_two`.
## x Input `one_and_two` can't be recycled to size 734.
## i Input `one_and_two` is `1:2`.
## i Input `one_and_two` must be size 734 or 1, not 2.
\end{verbatim}

Это не баг, а фича: авторы пакета \texttt{dplyr} считают, что ресайклинг кратных друг другу векторов --- это слишком удобное место для выстрелов себе в ногу. Поэтому в таких случаях разработчики \texttt{dplyr} рекомендуют использовать функцию \texttt{rep()}, знакомую нам уже очень давно (\ref{atomic}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{one_and_two =} \KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DataTypeTok{length.out =} \KeywordTok{nrow}\NormalTok{(.)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 12
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
##  2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  4     3 Abom~ Male   green       Huma~ No Hair         203 Marvel C~
##  5     4 Abra~ Male   blue        Cosm~ Black            NA Marvel C~
##  6     5 Abso~ Male   blue        Human No Hair         193 Marvel C~
##  7     6 Adam~ Male   blue        <NA>  Blond            NA NBC - He~
##  8     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  9     8 Agen~ Female blue        <NA>  Blond           173 Marvel C~
## 10     9 Agen~ Male   brown       Human Brown           178 Marvel C~
## # ... with 724 more rows, and 4 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>, one_and_two <int>
\end{verbatim}

\hypertarget{tidy_aggregate}{%
\section{Агрегация данных в тиббле}\label{tidy_aggregate}}

\hypertarget{summarise}{%
\subsection{\texorpdfstring{Подытоживание: \texttt{summarise()}}{Подытоживание: summarise()}}\label{summarise}}

Аггрегация по группам - это очень часто возникающая задача, например, это может использоваться для усреднения данных по испытуемым или условиям. Сделать аггрегацию в датафрейме удобной Хэдли Уикхэм пытался еще в предшественнике \texttt{dplyr}, пакете \texttt{plyr}. \texttt{dplyr} позволяет делать аггрегацию очень симпатичным и понятным способым. Аггрегация в \texttt{dplyr} состоит из двух этапов: группировки (\texttt{group\_by()}) и подытоживания (\texttt{summarise()}). Начнем с последнего.

Функция \texttt{dplyr::summarise()}\footnote{У функции \texttt{dplyr::summarise()} есть синоним \texttt{dplyr::summarize()}, которая делает абсолбтно то же самое. Просто потому что в американском английском и британском английском это слово пишется по-разному.} позволяет аггрегировать данные в тиббле. Работает она очень похоже на \texttt{mutate()}, но если внутри \texttt{mutate()} используются векторизованные функции, возвращающие вектор такой же длины, что и колонки, использовавшиеся для расчетов, то в \texttt{summarise()} используются функции, которые возвращают вектор длиной 1. Например, \texttt{min()}, \texttt{mean()}, \texttt{max()} и т.д. Можно создавать несколько колонок через запятую (это работает и для \texttt{mutate()}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{imt =}\NormalTok{ Weight}\OperatorTok{/}\NormalTok{(Height}\OperatorTok{/}\DecValTok{100}\NormalTok{)}\OperatorTok{^}\DecValTok{2}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{min}\NormalTok{(imt, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
            \KeywordTok{max}\NormalTok{(imt, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 1 x 2
##   `min(imt, na.rm = TRUE)` `max(imt, na.rm = TRUE)`
##                      <dbl>                    <dbl>
## 1                   0.0814                    2510.
\end{verbatim}

В \texttt{dplyr} есть дополнительные суммирующие функции для более удобного индексирования в стиле tidyverse. Например, функции \texttt{dplyr::nth()}, \texttt{dplyr::first()} и \texttt{dplyr::last()}, которые позволяют вытаскивать значения из вектора по индексу (что-то вроде \texttt{slice()}, но для векторов)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{imt =}\NormalTok{ Weight}\OperatorTok{/}\NormalTok{(Height}\OperatorTok{/}\DecValTok{100}\NormalTok{)}\OperatorTok{^}\DecValTok{2}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{arrange}\NormalTok{(imt) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{first =} \KeywordTok{first}\NormalTok{(imt),}
            \DataTypeTok{tenth =} \KeywordTok{nth}\NormalTok{(imt, }\DecValTok{10}\NormalTok{),}
            \DataTypeTok{last =} \KeywordTok{last}\NormalTok{(imt))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 1 x 3
##    first tenth  last
##    <dbl> <dbl> <dbl>
## 1 0.0814  16.7    NA
\end{verbatim}

В отличие от \texttt{mutate()}, функции внутри \texttt{summarise()} вполне позволяют функциям внутри возвращать вектор из нескольких значений, создавая тиббл такой же длины, как и получившийся вектор.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{imt =}\NormalTok{ Weight}\OperatorTok{/}\NormalTok{(Height}\OperatorTok{/}\DecValTok{100}\NormalTok{)}\OperatorTok{^}\DecValTok{2}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{imt_range =} \KeywordTok{range}\NormalTok{(imt, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)) }\CommentTok{#функция range() возвращает вектор из двух значений: минимальное и максимальное}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 2 x 1
##   imt_range
##       <dbl>
## 1    0.0814
## 2 2510.
\end{verbatim}

\hypertarget{tidy_group}{%
\subsection{\texorpdfstring{Группировка: \texttt{group\_by()}}{Группировка: group\_by()}}\label{tidy_group}}

\texttt{dplyr::group\_by()} - это функция для группировки данных в тиббле по дискретной переменной для дальнейшей аггрегации с помощью \texttt{summarise()}. После применения \texttt{group\_by()} тиббл будет выглядеть так же, но у него появятся атрибут \texttt{groups}\footnote{Снять группировку можно с помощью функции \texttt{ungroup()}.}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
## # Groups:   Gender [3]
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
##  1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
##  2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  4     3 Abom~ Male   green       Huma~ No Hair         203 Marvel C~
##  5     4 Abra~ Male   blue        Cosm~ Black            NA Marvel C~
##  6     5 Abso~ Male   blue        Human No Hair         193 Marvel C~
##  7     6 Adam~ Male   blue        <NA>  Blond            NA NBC - He~
##  8     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  9     8 Agen~ Female blue        <NA>  Blond           173 Marvel C~
## 10     9 Agen~ Male   brown       Human Brown           178 Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <chr>,
## #   Alignment <chr>, Weight <dbl>
\end{verbatim}

Если после этого применить на тиббле функцию \texttt{summarise()}, то мы получим не тиббл длиной один, а тиббл со значением для каждой из групп.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{imt =}\NormalTok{ Weight}\OperatorTok{/}\NormalTok{(Height}\OperatorTok{/}\DecValTok{100}\NormalTok{)}\OperatorTok{^}\DecValTok{2}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{min}\NormalTok{(imt, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
            \KeywordTok{max}\NormalTok{(imt, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 3
##   Gender `min(imt, na.rm = TRUE)` `max(imt, na.rm = TRUE)`
##   <chr>                     <dbl>                    <dbl>
## 1 Female                  15.5                       1613.
## 2 Male                     0.0814                    2510.
## 3 <NA>                    16.3                        114.
\end{verbatim}

Схематически это выглядит вот так:

\includegraphics[width=4.16667in,height=\textheight]{images/group_by_s.png}

\hypertarget{tidy_count}{%
\subsection{\texorpdfstring{Подсчет строк: \texttt{dplyr::n()}, \texttt{dplyr::count()}}{Подсчет строк: dplyr::n(), dplyr::count()}}\label{tidy_count}}

Для подсчет количества значений можно воспользоваться функцией \texttt{n()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{n =} \KeywordTok{n}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 2
##   Gender     n
##   <chr>  <int>
## 1 Female   200
## 2 Male     505
## 3 <NA>      29
\end{verbatim}

Функция \texttt{n()} вместе с \texttt{group\_by()} внутри \texttt{filter()} позволяет удобным образом ``отрезать'' от тиббла редкие группы\ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Race) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(}\KeywordTok{n}\NormalTok{() }\OperatorTok{>}\StringTok{ }\DecValTok{10}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, Race)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 611 x 2
## # Groups:   Race [6]
##    name          Race             
##    <chr>         <chr>            
##  1 A-Bomb        Human            
##  2 Abomination   Human / Radiation
##  3 Absorbing Man Human            
##  4 Adam Monroe   <NA>             
##  5 Adam Strange  Human            
##  6 Agent 13      <NA>             
##  7 Agent Bob     Human            
##  8 Agent Zero    <NA>             
##  9 Air-Walker    <NA>             
## 10 Ajax          Cyborg           
## # ... with 601 more rows
\end{verbatim}

или же наоборот, выделить только маленькие группы:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Race) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(}\KeywordTok{n}\NormalTok{() }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, Race)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 34 x 2
## # Groups:   Race [34]
##    name          Race              
##    <chr>         <chr>             
##  1 Abe Sapien    Icthyo Sapien     
##  2 Abin Sur      Ungaran           
##  3 Alien         Xenomorph XX121   
##  4 Azazel        Neyaphem          
##  5 Bizarro       Bizarro           
##  6 Boba Fett     Human / Clone     
##  7 Darth Maul    Dathomirian Zabrak
##  8 Fin Fang Foom Kakarantharaian   
##  9 Gamora        Zen-Whoberian     
## 10 Gladiator     Strontian         
## # ... with 24 more rows
\end{verbatim}

Таблицу частот можно создать без \texttt{group\_by()} и \texttt{summarise(n\ =\ n())}. Функция \texttt{count()} заменяет эту конструкцию:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{count}\NormalTok{(Gender)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 2
##   Gender     n
##   <chr>  <int>
## 1 Female   200
## 2 Male     505
## 3 <NA>      29
\end{verbatim}

Эту таблицу частот удобно сразу проранжировать, указав в параметре \texttt{sort\ =} значение \texttt{TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{count}\NormalTok{(Gender, }\DataTypeTok{sort =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 2
##   Gender     n
##   <chr>  <int>
## 1 Male     505
## 2 Female   200
## 3 <NA>      29
\end{verbatim}

\begin{quote}
Функция \texttt{count()}, несмотря на свою простоту, является одной из наиболее используемых в tidyverse.
\end{quote}

\hypertarget{tidy_distinct}{%
\subsection{\texorpdfstring{Уникальные значения: \texttt{dplyr::distinct()}}{Уникальные значения: dplyr::distinct()}}\label{tidy_distinct}}

\texttt{dplyr::distinct()} - это более быстрый аналог \texttt{unique()}, позволяет извлекать уникальные значения для одной или нескольких колонок.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{distinct}\NormalTok{(Gender)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 1
##   Gender
##   <chr> 
## 1 Male  
## 2 Female
## 3 <NA>
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{distinct}\NormalTok{(Gender, Race)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 81 x 2
##    Gender Race             
##    <chr>  <chr>            
##  1 Male   Human            
##  2 Male   Icthyo Sapien    
##  3 Male   Ungaran          
##  4 Male   Human / Radiation
##  5 Male   Cosmic Entity    
##  6 Male   <NA>             
##  7 Female <NA>             
##  8 Male   Cyborg           
##  9 Male   Xenomorph XX121  
## 10 Male   Android          
## # ... with 71 more rows
\end{verbatim}

Иногда нужно аггрегировать данные, но при этом сохранить исходную структуру тиббла. Например, нужно посчитать размер групп или посчитать средние значения по группе для последующего сравнения с индивидуальными значениями.

\hypertarget{tidy_group_mutate}{%
\subsection{Создание колонок с группировкой}\label{tidy_group_mutate}}

В tidyverse это можно сделать с помощью сочетания \texttt{group\_by()} и \texttt{mutate()} (вместо \texttt{summarise()}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Race) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{Race_n =} \KeywordTok{n}\NormalTok{()) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(Race, name, Gender, Race_n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 4
## # Groups:   Race [62]
##    Race              name          Gender Race_n
##    <chr>             <chr>         <chr>   <int>
##  1 Human             A-Bomb        Male      208
##  2 Icthyo Sapien     Abe Sapien    Male        1
##  3 Ungaran           Abin Sur      Male        1
##  4 Human / Radiation Abomination   Male       11
##  5 Cosmic Entity     Abraxas       Male        4
##  6 Human             Absorbing Man Male      208
##  7 <NA>              Adam Monroe   Male      304
##  8 Human             Adam Strange  Male      208
##  9 <NA>              Agent 13      Female    304
## 10 Human             Agent Bob     Male      208
## # ... with 724 more rows
\end{verbatim}

Результаты аггрегации были записаны в отдельную колонку, при этом значения этой колонки внутри одной группы повторяются:

\includegraphics[width=4.16667in,height=\textheight]{images/group_by_m.png}

\hypertarget{ux442ux440ux430ux43dux441ux444ux43eux440ux43cux430ux446ux438ux44f-ux43dux435ux441ux43aux43eux43bux44cux43aux438ux445-ux43aux43eux43bux43eux43dux43eux43a-dplyracross}{%
\section{\texorpdfstring{Трансформация нескольких колонок: \texttt{dplyr::across()}}{Трансформация нескольких колонок: dplyr::across()}}\label{ux442ux440ux430ux43dux441ux444ux43eux440ux43cux430ux446ux438ux44f-ux43dux435ux441ux43aux43eux43bux44cux43aux438ux445-ux43aux43eux43bux43eux43dux43eux43a-dplyracross}}

Допустим, вы хотите посчитать среднюю массу и рост, группируя по полу супергероев. Можно посчитать это внутри одного \texttt{summarise()}, использую запятую:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{height =} \KeywordTok{mean}\NormalTok{(Height, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
            \DataTypeTok{weight =} \KeywordTok{mean}\NormalTok{(Weight, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 3
##   Gender height weight
##   <chr>   <dbl>  <dbl>
## 1 Female   175.   78.8
## 2 Male     192.  126. 
## 3 <NA>     177.  129.
\end{verbatim}

Если таких колонок будет много, то это уже станет сильно неудобным, нам придется много копировать код, а это чревато ошибками и очень скучно.

Поэтому в \texttt{dplyr} есть функция для операций над несколькими колонками сразу: \texttt{dplyr::across()}\footnote{Функция \texttt{across()} появилась в пакете \texttt{dplyr} относительно недавно, до этого для работы с множественными колонками в tidyverse использовались многочисленные функции \texttt{*\_at()}, \texttt{*\_if()}, \texttt{*\_all()}, например, \texttt{summarise\_at()}, \texttt{summarise\_if()}, \texttt{summarize\_all()}. Эти функции до сих пор присутствуют в \texttt{dplyr}, но считаются устаревшими. Другая альтернатива - использование пакета \texttt{purrr} (\ref{purrr}) или семейства функций \texttt{apply()} (@ref(apply\_f)).}. Эта функция работает похожим образом на функции семейства \texttt{apply()} и использует tidyselect для выбора колонок.

Таким образом, конструкции с функцией \texttt{across()} можно разбить на три части:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Выбор колонок с помощью tidyselect. Здесь работают все те приемы, которые мы изучили при выборе колонок (\ref{tidyselect}).
\item
  Собственно применение функции \texttt{across()}. Первый аргумент \texttt{.col} --- колонки, выбранные на первом этапе с помощью tidyselect, по умолчанию это \texttt{everything()}, т.е. все колонки. Второй аргумент \texttt{.fns} --- это функция или целый список из функций, которые будут применены к выбранным колонкам. Если функции требуют дополнительных аргументов, то они могут быть перечислены внутри \texttt{across()}.
\item
  Использование \texttt{summarise()} или другой функции \texttt{dplyr}. В этом случае в качестве аргумента для функции используется результат работы функции \texttt{across()}.
\end{enumerate}

Вот такой вот бутерброд выходит. Давайте посмотрим, как это работает на практике и посчитаем среднее значение по колонкам \texttt{Height} и \texttt{Weight}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{c}\NormalTok{(Height,Weight), mean))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 3
##   Gender Height Weight
##   <chr>   <dbl>  <dbl>
## 1 Female     NA     NA
## 2 Male       NA     NA
## 3 <NA>       NA     NA
\end{verbatim}

Здесь мы столкнулись с уже известной нам проблемой: функция \texttt{mean()} при столкновении хотя бы с одним \texttt{NA} будет возвращать \texttt{NA}, если мы не изменим параметр \texttt{na.rm\ =}. Как и в случае с функциями семейства \texttt{apply()} (@ref(apply\_f)), дополнительные параметры для функции можно перечислить через запятую после самой функции:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{c}\NormalTok{(Height, Weight), mean, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 3
##   Gender Height Weight
##   <chr>   <dbl>  <dbl>
## 1 Female   175.   78.8
## 2 Male     192.  126. 
## 3 <NA>     177.  129.
\end{verbatim}

До этого мы просто использовали выбор колонок по их названию. Но именно внутри \texttt{across()} использование tidyselect раскрывается как удивительно элегантный и мощный инструмент. Например, можно посчитать среднее для всех numeric колонок:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{drop_na}\NormalTok{(Height, Weight) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{where}\NormalTok{(is.numeric), mean, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 4
##   Gender    X1 Height Weight
##   <chr>  <dbl>  <dbl>  <dbl>
## 1 Female  394.   174.   78.3
## 2 Male    369.   193.  126. 
## 3 <NA>    375.   182   129.
\end{verbatim}

Или длину строк для строковых колонок. Для этого нам понадобится вспомнить, как создавать анонимные функции (@ref(anon\_f)).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{where}\NormalTok{(is.character), }
                   \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{mean}\NormalTok{(}\KeywordTok{nchar}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 8
##   Gender  name `Eye color`  Race `Hair color` Publisher `Skin color` Alignment
##   <chr>  <dbl>       <dbl> <dbl>        <dbl>     <dbl>        <dbl>     <dbl>
## 1 Female  9.04        4.68  6.42         5.05      11.5         4.57      3.88
## 2 Male    9.05        4.53  6.75         5.48      11.4         5.02      3.78
## 3 <NA>    9.48        5.16 10.1          6.44      11.9         4         3.96
\end{verbatim}

Или же даже посчитать и то, и другое внутри одного \texttt{summarise()}!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{where}\NormalTok{(is.numeric), mean, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
            \KeywordTok{across}\NormalTok{(}\KeywordTok{where}\NormalTok{(is.character), }
                   \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{mean}\NormalTok{(}\KeywordTok{nchar}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 11
##   Gender    X1 Height Weight  name `Eye color`  Race `Hair color` Publisher
##   <chr>  <dbl>  <dbl>  <dbl> <dbl>       <dbl> <dbl>        <dbl>     <dbl>
## 1 Female  395.   175.   78.8  9.04        4.68  6.42         5.05      11.5
## 2 Male    357.   192.  126.   9.05        4.53  6.75         5.48      11.4
## 3 <NA>    329    177.  129.   9.48        5.16 10.1          6.44      11.9
## # ... with 2 more variables: `Skin color` <dbl>, Alignment <dbl>
\end{verbatim}

Внутри одного \texttt{across()} можно применить не одну функцию к каждой из выбранных колонок, а сразу несколько функций для каждой из колонок. Для этого нам нужно использовать список функций (желательно - проименованный).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{c}\NormalTok{(Height, Weight), }
                   \KeywordTok{list}\NormalTok{(}\DataTypeTok{minimum =}\NormalTok{ min,}
                        \DataTypeTok{average =}\NormalTok{ mean,}
                        \DataTypeTok{maximum =}\NormalTok{ max), }
                   \DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 7
##   Gender Height_minimum Height_average Height_maximum Weight_minimum
##   <chr>           <dbl>          <dbl>          <dbl>          <dbl>
## 1 Female           62.5           175.            366             41
## 2 Male             15.2           192.            975              2
## 3 <NA>            108             177.            198             39
## # ... with 2 more variables: Weight_average <dbl>, Weight_maximum <dbl>
\end{verbatim}

\begin{quote}
Вот нам и понадобился список функций (@ref(functions\_objects))!
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{c}\NormalTok{(Height, Weight),}
                   \KeywordTok{list}\NormalTok{(}\DataTypeTok{min =} \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{min}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
                        \DataTypeTok{mean =} \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
                        \DataTypeTok{max =} \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{max}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
                        \DataTypeTok{na_n =} \ControlFlowTok{function}\NormalTok{(x, ...) }\KeywordTok{sum}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x)))}
\NormalTok{                   )}
\NormalTok{            )}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 9
##   Gender Height_min Height_mean Height_max Height_na_n Weight_min Weight_mean
##   <chr>       <dbl>       <dbl>      <dbl>       <int>      <dbl>       <dbl>
## 1 Female       62.5        175.        366          56         41        78.8
## 2 Male         15.2        192.        975         147          2       126. 
## 3 <NA>        108          177.        198          14         39       129. 
## # ... with 2 more variables: Weight_max <dbl>, Weight_na_n <int>
\end{verbatim}

Хотя основное применение функции \texttt{across()} --- это массовое подытоживание с помощью \texttt{summarise()}, \texttt{across()} можно использовать и с другими функциями \texttt{dplyr}. Например, можно делать массовые операции с колонками с помощью \texttt{mutate()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{where}\NormalTok{(is.character), as.factor))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 11
##       X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
##    <dbl> <fct> <fct>  <fct>       <fct> <fct>         <dbl> <fct>    
##  1     0 A-Bo~ Male   yellow      Human No Hair         203 Marvel C~
##  2     1 Abe ~ Male   blue        Icth~ No Hair         191 Dark Hor~
##  3     2 Abin~ Male   blue        Unga~ No Hair         185 DC Comics
##  4     3 Abom~ Male   green       Huma~ No Hair         203 Marvel C~
##  5     4 Abra~ Male   blue        Cosm~ Black            NA Marvel C~
##  6     5 Abso~ Male   blue        Human No Hair         193 Marvel C~
##  7     6 Adam~ Male   blue        <NA>  Blond            NA NBC - He~
##  8     7 Adam~ Male   blue        Human Blond           185 DC Comics
##  9     8 Agen~ Female blue        <NA>  Blond           173 Marvel C~
## 10     9 Agen~ Male   brown       Human Brown           178 Marvel C~
## # ... with 724 more rows, and 3 more variables: `Skin color` <fct>,
## #   Alignment <fct>, Weight <dbl>
\end{verbatim}

Менее очевидный способ применения \texttt{across()} - использование \texttt{across()} внутри \texttt{count()} вместе с функцией \texttt{n\_distinct()}, которая считает количество уникальных значений в векторе. Это позволяет посмотреть таблицу частот для группирующих переменных:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\KeywordTok{where}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{n_distinct}\NormalTok{(x) }\OperatorTok{<=}\StringTok{ }\DecValTok{6}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 734 x 2
##    Gender Alignment
##    <chr>  <chr>    
##  1 Male   good     
##  2 Male   good     
##  3 Male   good     
##  4 Male   bad      
##  5 Male   bad      
##  6 Male   bad      
##  7 Male   good     
##  8 Male   good     
##  9 Female good     
## 10 Male   good     
## # ... with 724 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{count}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{where}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{n_distinct}\NormalTok{(x) }\OperatorTok{<=}\StringTok{ }\DecValTok{6}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 11 x 3
##    Gender Alignment     n
##    <chr>  <chr>     <int>
##  1 Female bad          35
##  2 Female good        161
##  3 Female neutral       4
##  4 Male   bad         165
##  5 Male   good        316
##  6 Male   neutral      18
##  7 Male   <NA>          6
##  8 <NA>   bad           7
##  9 <NA>   good         19
## 10 <NA>   neutral       2
## 11 <NA>   <NA>          1
\end{verbatim}

\hypertarget{tidy_several}{%
\section{Объединение нескольких датафреймов}\label{tidy_several}}

\hypertarget{tidy_bind}{%
\subsection{Соединение структурно схожих датафреймов: bind\_rows(), bind\_cols()}\label{tidy_bind}}

Для начала создадим следующие тибблы и сохраним их как \texttt{dc}, \texttt{marvel} и \texttt{other\_publishers}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dc <-}\StringTok{ }\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(Publisher }\OperatorTok{==}\StringTok{ "DC Comics"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{weight_mean =} \KeywordTok{mean}\NormalTok{(Weight, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dc}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 2
##   Gender weight_mean
##   <chr>        <dbl>
## 1 Female        76.8
## 2 Male         113. 
## 3 <NA>         NaN
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{marvel <-}\StringTok{ }\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(Publisher }\OperatorTok{==}\StringTok{ "Marvel Comics"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{weight_mean =} \KeywordTok{mean}\NormalTok{(Weight, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{marvel}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 2
##   Gender weight_mean
##   <chr>        <dbl>
## 1 Female        80.1
## 2 Male         134. 
## 3 <NA>         129.
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{other_publishers <-}\StringTok{ }\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(}\OperatorTok{!}\NormalTok{(Publisher }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"DC Comics"}\NormalTok{,}\StringTok{"Marvel Comics"}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{weight_mean =} \KeywordTok{mean}\NormalTok{(Weight, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{other_publishers}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 2
##   Gender weight_mean
##   <chr>        <dbl>
## 1 Female        70.8
## 2 Male         111. 
## 3 <NA>         NaN
\end{verbatim}

Несколько тибблов можно объединить вертикально с помощью функции \texttt{bind\_rows()}. Для корректного объединения тибблы должны иметь одинаковые названия колонок.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{bind_rows}\NormalTok{(dc, marvel)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 2
##   Gender weight_mean
##   <chr>        <dbl>
## 1 Female        76.8
## 2 Male         113. 
## 3 <NA>         NaN  
## 4 Female        80.1
## 5 Male         134. 
## 6 <NA>         129.
\end{verbatim}

Чтобы соединить тибблы горизонтально, воспользуйтесь функцией \texttt{bind\_cols()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{bind_cols}\NormalTok{(dc, marvel)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## New names:
## * Gender -> Gender...1
## * weight_mean -> weight_mean...2
## * Gender -> Gender...3
## * weight_mean -> weight_mean...4
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 4
##   Gender...1 weight_mean...2 Gender...3 weight_mean...4
##   <chr>                <dbl> <chr>                <dbl>
## 1 Female                76.8 Female                80.1
## 2 Male                 113.  Male                 134. 
## 3 <NA>                 NaN   <NA>                 129.
\end{verbatim}

Функции \texttt{bind\_rows()} и \texttt{bind\_cols()} могут работать не только с двумя, но сразу с несколькими датафреймами.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{bind_rows}\NormalTok{(dc, marvel, other_publishers)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 9 x 2
##   Gender weight_mean
##   <chr>        <dbl>
## 1 Female        76.8
## 2 Male         113. 
## 3 <NA>         NaN  
## 4 Female        80.1
## 5 Male         134. 
## 6 <NA>         129. 
## 7 Female        70.8
## 8 Male         111. 
## 9 <NA>         NaN
\end{verbatim}

На входе в функции \texttt{bind\_rows()} и \texttt{bind\_cold()} можно подавать как сами датафреймы или тибблы через запятую, так и список из датафреймов/тибблов.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes_list_of_df <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{DC =}\NormalTok{ dc, }
                          \DataTypeTok{Marvel =}\NormalTok{ marvel, }
                          \DataTypeTok{Other =}\NormalTok{ other_publishers)}
\KeywordTok{bind_rows}\NormalTok{(heroes_list_of_df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 9 x 2
##   Gender weight_mean
##   <chr>        <dbl>
## 1 Female        76.8
## 2 Male         113. 
## 3 <NA>         NaN  
## 4 Female        80.1
## 5 Male         134. 
## 6 <NA>         129. 
## 7 Female        70.8
## 8 Male         111. 
## 9 <NA>         NaN
\end{verbatim}

Чтобы не потерять, из какого датафрейма какие данные, можно указать любое строковое значение (название будущей колонки) для необязательного аргумента \texttt{.id\ =}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{bind_rows}\NormalTok{(heroes_list_of_df, }\DataTypeTok{.id =} \StringTok{"Publisher"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 9 x 3
##   Publisher Gender weight_mean
##   <chr>     <chr>        <dbl>
## 1 DC        Female        76.8
## 2 DC        Male         113. 
## 3 DC        <NA>         NaN  
## 4 Marvel    Female        80.1
## 5 Marvel    Male         134. 
## 6 Marvel    <NA>         129. 
## 7 Other     Female        70.8
## 8 Other     Male         111. 
## 9 Other     <NA>         NaN
\end{verbatim}

\texttt{bind\_rows()} обычно используется, когда ваши данные находятся в разных файлах с одинаковой структурой. Тогда вы можете прочитать все таблицы в папке, сохранить их в качестве списка из датафреймов и объединить в один датафрейм с помощью \texttt{bind\_rows()}.

\hypertarget{tidy_join}{%
\subsection{\texorpdfstring{Реляционные данные: \texttt{*\_join()}}{Реляционные данные: *\_join()}}\label{tidy_join}}

В реальности иногда возникает ситуация, когда нужно соединить две таблички, у которых есть общий столбец (или несколько столбцов), но все остальные столбцы различаются. Табличек может быть и больше, это может быть целая сеть таблиц, некоторые из которых содержат основные данные, а некоторые - дополнительные, которые необходимо на определенном этапе ``включить'' в анализ. Например, таблица с расшифровкой аббревиатур или сокращений вроде коротких названий стран или таблица телефонных кодов разных стран. Совокупность нескольких связанных друг с другом таблиц называют реляционными данными.

В случае с реляционными данными простых \texttt{bind\_rows()} и \texttt{bind\_cols()} становится недостаточно.

Эти две таблички нужно объединить (\emph{join}). Эта задача обычно возникает не очень часто, обычно это происходит один-два раза в одном проекте, когда нужно дополнить имеющиеся данные дополнительной информацией извне или объединить два набора данных, обрабатывавшихся в разных программах. Всякий раз, когда такая задача возникает, это доставляет много боли. \texttt{dplyr} предлагает интуитивно понятный инструмент для объединения реляционных данных - семейство функций \texttt{*\_join()}.

Возьмем для примера два тиббла \texttt{band\_members} и \texttt{band\_instruments}, встроенных в \texttt{dplyr} специально для демонстрации работы функций \texttt{*\_join()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{band_members}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 2
##   name  band   
##   <chr> <chr>  
## 1 Mick  Stones 
## 2 John  Beatles
## 3 Paul  Beatles
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{band_instruments}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 2
##   name  plays 
##   <chr> <chr> 
## 1 John  guitar
## 2 Paul  bass  
## 3 Keith guitar
\end{verbatim}

У этих двух тибблов есть колонка с одинаковым названием, которая по своему смыслу соединяет данные обоих тибблов. Такая колонка называется \textbf{ключом}. Ключ должен однозначно идентифицировать наблюдения\footnote{Если ключи будут неуникальными, то функции \texttt{*\_join()} не будут выдавать ошибку. Вместо этого они добавят в итоговую таблицу все возможные пересечения повторяющихся ключей. С этим нужно быть очень осторожным, поэтому рекомендуется, во-первых, проверять уникальность ключей на входе и, во-вторых, проверять тиббл на выходе. Ну или использовать эту особенность работы функции \texttt{*\_join()} себе во благо.}.

Давайте попробуем посоединять \texttt{band\_members} и \texttt{band\_instruments} разными вариантами \texttt{*\_join()} и посмотрим, что у нас получится. Все эти функции имеют на входе два обязательных аргумента (\texttt{x\ =} и \texttt{y\ =}) в которые мы должны подставить два датафрейма/тиббла которые мы хотим объединить. Главное различие между этими функциями заключается в том, что они будут делать, если уникальные значения в ключах \texttt{x} и \texttt{y} не соответствуют друг другу.

\includegraphics[width=4.16667in,height=\textheight]{images/joins.png}

\begin{itemize}
\tightlist
\item
  \texttt{left\_join()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{band_members }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{left_join}\NormalTok{(band_instruments)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Joining, by = "name"
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 3
##   name  band    plays 
##   <chr> <chr>   <chr> 
## 1 Mick  Stones  <NA>  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass
\end{verbatim}

\texttt{left\_join()} - это самая простая для понимания и самая используемая функция из семейства \texttt{*\_join()}. Она как бы ``дополняет'' информацию из первого тиббла вторым тибблом. В этом случае сохраняются все уникальные наблюдения в \texttt{x}, но отбрасываются лишние наблюдения в тиббле \texttt{y}. Тем значениям, которым не нашлось соотвествия в \texttt{y}, в колонках, взятых их \texttt{y}, ставятся значения \texttt{NA}.

Вы можете сами задать колонки-ключи параметром \texttt{by\ =}, по умолчанию это все колонки с одинаковыми названиями в двух тибблах.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{band_members }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{left_join}\NormalTok{(band_instruments, }\DataTypeTok{by =} \StringTok{"name"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 3
##   name  band    plays 
##   <chr> <chr>   <chr> 
## 1 Mick  Stones  <NA>  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass
\end{verbatim}

Часто случается, что колонки-ключи называются по-разному в двух тибблах. Их необязательно переименовывать, можно поставить соответстие вручную используя проименованный вектор:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{band_members }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{left_join}\NormalTok{(band_instruments2, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{"name"}\NormalTok{ =}\StringTok{ "artist"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 3
##   name  band    plays 
##   <chr> <chr>   <chr> 
## 1 Mick  Stones  <NA>  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{right\_join()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{band_members }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{right_join}\NormalTok{(band_instruments)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Joining, by = "name"
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 3
##   name  band    plays 
##   <chr> <chr>   <chr> 
## 1 John  Beatles guitar
## 2 Paul  Beatles bass  
## 3 Keith <NA>    guitar
\end{verbatim}

\texttt{right\_join()} отбрасывает строчки в \texttt{x}, которых не было в \texttt{y}, но сохраняет соответствующие строчки \texttt{y} - \texttt{left\_join()} наоборот.

\begin{itemize}
\tightlist
\item
  \texttt{full\_join()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{band_members }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{full_join}\NormalTok{(band_instruments)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Joining, by = "name"
\end{verbatim}

\begin{verbatim}
## # A tibble: 4 x 3
##   name  band    plays 
##   <chr> <chr>   <chr> 
## 1 Mick  Stones  <NA>  
## 2 John  Beatles guitar
## 3 Paul  Beatles bass  
## 4 Keith <NA>    guitar
\end{verbatim}

Функция \texttt{full\_join()} сохраняет все строчки и из \texttt{x} и \texttt{y}. Пожалуй, наиболее используемая функция после \texttt{left\_join()} --- благодаря \texttt{full\_join()} вы точно ничего не потеряете при объединении.

\begin{itemize}
\tightlist
\item
  \texttt{inner\_join()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{band_members }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{inner_join}\NormalTok{(band_instruments)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Joining, by = "name"
\end{verbatim}

\begin{verbatim}
## # A tibble: 2 x 3
##   name  band    plays 
##   <chr> <chr>   <chr> 
## 1 John  Beatles guitar
## 2 Paul  Beatles bass
\end{verbatim}

Функция \texttt{full\_join()} сохраняет только строчки, которые присутствуют и в \texttt{x}, и в \texttt{y}.

\begin{itemize}
\tightlist
\item
  \texttt{semi\_join()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{band_members }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{semi_join}\NormalTok{(band_instruments)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Joining, by = "name"
\end{verbatim}

\begin{verbatim}
## # A tibble: 2 x 2
##   name  band   
##   <chr> <chr>  
## 1 John  Beatles
## 2 Paul  Beatles
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \texttt{anti\_join()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{band_members }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{anti_join}\NormalTok{(band_instruments)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Joining, by = "name"
\end{verbatim}

\begin{verbatim}
## # A tibble: 1 x 2
##   name  band  
##   <chr> <chr> 
## 1 Mick  Stones
\end{verbatim}

Функции \texttt{semi\_join()} и \texttt{anti\_join()} не присоединяют второй датафрейм/тиббл (\texttt{y}) к первому. Вместо этого они используются как некоторый словарь-фильтр для отделения только тех значений в \texttt{x}, которые есть в \texttt{y} (\texttt{semi\_join()}) или, наоборот, которых нет в \texttt{y} (\texttt{anti\_join()}).

\hypertarget{tidy_data}{%
\section{\texorpdfstring{Tidy data: \texttt{tidyr::pivot\_longer()}, \texttt{tidyr::pivot\_wider()}}{Tidy data: tidyr::pivot\_longer(), tidyr::pivot\_wider()}}\label{tidy_data}}

Принцип tidy data предполагает, что каждая строчка содержит в себе одно измерение, а каждая колонка - одну характеристику. Тем не менее, это не говорит однозначно о том, как именно хранить повторные измерения. Их можно хранить как одну колонку для каждого измерения (широкий формат) и как две колонки: одна колонка - для идентификатора измерения, другая колонка - для записи самого измерения.

Это лучше понять на примере. Например, вес до и после прохождения курса. Как это лучше записать - как два числовых столбца (один испытуемый - одна строка) или же создать отдельную ``группирующую'' колонку, в которой будет написано время измерения, а в другой - измеренные значения (одно измерение - одна строка)?

\begin{itemize}
\tightlist
\item
  \textbf{Широкий формат:}
\end{itemize}

\begin{longtable}[]{@{}lll@{}}
\toprule
Студент & До курса по R & После курса по R\tabularnewline
\midrule
\endhead
Маша & 70 & 63\tabularnewline
Рома & 80 & 74\tabularnewline
Антонина & 86 & 71\tabularnewline
\bottomrule
\end{longtable}

\begin{itemize}
\tightlist
\item
  \textbf{Длинный" формат:}
\end{itemize}

\begin{longtable}[]{@{}lll@{}}
\toprule
Студент & Время измерения & Масса (кг)\tabularnewline
\midrule
\endhead
Маша & До курса по R & 70\tabularnewline
Рома & До курса по R & 80\tabularnewline
Антонина & До курса по R & 86\tabularnewline
Маша & После курса по R & 63\tabularnewline
Рома & После курса по R & 74\tabularnewline
Антонина & После курса по R & 71\tabularnewline
\bottomrule
\end{longtable}

На самом деле, оба варианта приемлимы, оба варианта возможны в реальных данных, а разные функции и статистические пакеты могут требовать от вас как длинный, так и широкий форматы.

Таким образом, нам нужно научиться переводить из широкого формата в длинный и наоборот.

\begin{itemize}
\item
  \texttt{tidyr::pivot\_longer()}: из \emph{широкого} в \emph{длинный} формат
\item
  \texttt{tidyr::pivot\_wider()}: из \emph{длинного} в \emph{широкий} формат
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_diet <-}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{student =} \KeywordTok{c}\NormalTok{(}\StringTok{"Маша"}\NormalTok{, }\StringTok{"Рома"}\NormalTok{, }\StringTok{"Антонина"}\NormalTok{),}
  \DataTypeTok{before_r_course =} \KeywordTok{c}\NormalTok{(}\DecValTok{70}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{86}\NormalTok{),}
  \DataTypeTok{after_r_course =} \KeywordTok{c}\NormalTok{(}\DecValTok{63}\NormalTok{, }\DecValTok{74}\NormalTok{, }\DecValTok{71}\NormalTok{)}
\NormalTok{)}
\NormalTok{new_diet}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 3
##   student  before_r_course after_r_course
##   <chr>              <dbl>          <dbl>
## 1 Маша                  70             63
## 2 Рома                  80             74
## 3 Антонина              86             71
\end{verbatim}

Тиббл \texttt{new\_diet} - это пример широкого формата данных.

Превратим тиббл \texttt{new\_diet} длинный:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_diet }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pivot_longer}\NormalTok{(}\DataTypeTok{cols =}\NormalTok{ before_r_course}\OperatorTok{:}\NormalTok{after_r_course,}
               \DataTypeTok{names_to =} \StringTok{"measurement_time"}\NormalTok{, }
               \DataTypeTok{values_to =} \StringTok{"weight_kg"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 3
##   student  measurement_time weight_kg
##   <chr>    <chr>                <dbl>
## 1 Маша     before_r_course         70
## 2 Маша     after_r_course          63
## 3 Рома     before_r_course         80
## 4 Рома     after_r_course          74
## 5 Антонина before_r_course         86
## 6 Антонина after_r_course          71
\end{verbatim}

А теперь обратно в короткий:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_diet }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pivot_longer}\NormalTok{(}\DataTypeTok{cols =}\NormalTok{ before_r_course}\OperatorTok{:}\NormalTok{after_r_course,}
               \DataTypeTok{names_to =} \StringTok{"measurement_time"}\NormalTok{, }
               \DataTypeTok{values_to =} \StringTok{"weight_kg"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pivot_wider}\NormalTok{(}\DataTypeTok{names_from =} \StringTok{"measurement_time"}\NormalTok{,}
              \DataTypeTok{values_from =} \StringTok{"weight_kg"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 3 x 3
##   student  before_r_course after_r_course
##   <chr>              <dbl>          <dbl>
## 1 Маша                  70             63
## 2 Рома                  80             74
## 3 Антонина              86             71
\end{verbatim}

\hypertarget{viz_1}{%
\chapter{Визуализация данных}\label{viz_1}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"tidyverse"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux437ux430ux447ux435ux43c-ux432ux438ux437ux443ux430ux43bux438ux437ux438ux440ux43eux432ux430ux442ux44c-ux434ux430ux43dux43dux44bux435}{%
\section{Зачем визуализировать данные?}\label{ux437ux430ux447ux435ux43c-ux432ux438ux437ux443ux430ux43bux438ux437ux438ux440ux43eux432ux430ux442ux44c-ux434ux430ux43dux43dux44bux435}}

\hypertarget{ux43aux432ux430ux440ux442ux435ux442-ux430ux43dux441ux43aux43eux43cux431ux430}{%
\subsection{Квартет Анскомба}\label{ux43aux432ux430ux440ux442ux435ux442-ux430ux43dux441ux43aux43eux43cux431ux430}}

В работе Anscombe, F. J. (1973). ``Graphs in Statistical Analysis'' представлен следующий датасет:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{quartet <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\StringTok{"https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/anscombe.csv"}\NormalTok{)}
\NormalTok{quartet}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 44 x 4
##       id dataset     x     y
##    <dbl>   <dbl> <dbl> <dbl>
##  1     1       1    10  8.04
##  2     1       2    10  9.14
##  3     1       3    10  7.46
##  4     1       4     8  6.58
##  5     2       1     8  6.95
##  6     2       2     8  8.14
##  7     2       3     8  6.77
##  8     2       4     8  5.76
##  9     3       1    13  7.58
## 10     3       2    13  8.74
## # ... with 34 more rows
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{quartet }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{group_by}\NormalTok{(dataset) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{mean_X =} \KeywordTok{mean}\NormalTok{(x),}
            \DataTypeTok{mean_Y =} \KeywordTok{mean}\NormalTok{(y),}
            \DataTypeTok{sd_X =} \KeywordTok{sd}\NormalTok{(x),}
            \DataTypeTok{sd_Y =} \KeywordTok{sd}\NormalTok{(y),}
            \DataTypeTok{cor =} \KeywordTok{cor}\NormalTok{(x, y),}
            \DataTypeTok{n_obs =} \KeywordTok{n}\NormalTok{()) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{select}\NormalTok{(}\OperatorTok{-}\NormalTok{dataset) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{round}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 4 x 6
##   mean_X mean_Y  sd_X  sd_Y   cor n_obs
##    <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl>
## 1      9    7.5  3.32  2.03  0.82    11
## 2      9    7.5  3.32  2.03  0.82    11
## 3      9    7.5  3.32  2.03  0.82    11
## 4      9    7.5  3.32  2.03  0.82    11
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-238-1.pdf}

\hypertarget{ux434ux430ux442ux430ux437ux430ux443ux440ux443ux441}{%
\subsection{Датазаурус}\label{ux434ux430ux442ux430ux437ux430ux443ux440ux443ux441}}

В работе \href{https://www.autodeskresearch.com/sites/default/files/SameStats-DifferentGraphs.pdf}{Matejka and Fitzmaurice (2017) ``Same Stats, Different Graphs''} были представлены следующие датасеты:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datasaurus <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\StringTok{"https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/datasaurus.csv"}\NormalTok{)}
\NormalTok{datasaurus}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 1,846 x 3
##    dataset     x     y
##    <chr>   <dbl> <dbl>
##  1 dino     55.4  97.2
##  2 dino     51.5  96.0
##  3 dino     46.2  94.5
##  4 dino     42.8  91.4
##  5 dino     40.8  88.3
##  6 dino     38.7  84.9
##  7 dino     35.6  79.9
##  8 dino     33.1  77.6
##  9 dino     29.0  74.5
## 10 dino     26.2  71.4
## # ... with 1,836 more rows
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-240-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{datasaurus }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{group_by}\NormalTok{(dataset) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{mean_X =} \KeywordTok{mean}\NormalTok{(x),}
            \DataTypeTok{mean_Y =} \KeywordTok{mean}\NormalTok{(y),}
            \DataTypeTok{sd_X =} \KeywordTok{sd}\NormalTok{(x),}
            \DataTypeTok{sd_Y =} \KeywordTok{sd}\NormalTok{(y),}
            \DataTypeTok{cor =} \KeywordTok{cor}\NormalTok{(x, y),}
            \DataTypeTok{n_obs =} \KeywordTok{n}\NormalTok{()) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{select}\NormalTok{(}\OperatorTok{-}\NormalTok{dataset) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{round}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 13 x 6
##    mean_X mean_Y  sd_X  sd_Y   cor n_obs
##     <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl>
##  1   54.3   47.8  16.8  26.9  -0.1   142
##  2   54.3   47.8  16.8  26.9  -0.1   142
##  3   54.3   47.8  16.8  26.9  -0.1   142
##  4   54.3   47.8  16.8  26.9  -0.1   142
##  5   54.3   47.8  16.8  26.9  -0.1   142
##  6   54.3   47.8  16.8  26.9  -0.1   142
##  7   54.3   47.8  16.8  26.9  -0.1   142
##  8   54.3   47.8  16.8  26.9  -0.1   142
##  9   54.3   47.8  16.8  26.9  -0.1   142
## 10   54.3   47.8  16.8  26.9  -0.1   142
## 11   54.3   47.8  16.8  26.9  -0.1   142
## 12   54.3   47.8  16.8  26.9  -0.1   142
## 13   54.3   47.8  16.8  26.9  -0.1   142
\end{verbatim}

\hypertarget{ux43eux441ux43dux43eux432ux44b-ggplot2}{%
\section{\texorpdfstring{Основы \texttt{ggplot2}}{Основы ggplot2}}\label{ux43eux441ux43dux43eux432ux44b-ggplot2}}

Пакет \texttt{ggplot2} -- современный стандарт для создания графиков в R. Для этого пакета пишут \href{http://www.ggplot2-exts.org/gallery/}{массу расширений}. В сжатом виде информация про ggplot2 \href{https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf}{содержиться здесь}.

\hypertarget{ux434ux438ux430ux433ux440ux430ux43cux43cux430-ux440ux430ux441ux441ux435ux44fux43dux438ux44f-scaterplot}{%
\subsection{Диаграмма рассеяния (Scaterplot)}\label{ux434ux438ux430ux433ux440ux430ux43cux43cux430-ux440ux430ux441ux441ux435ux44fux43dux438ux44f-scaterplot}}

\begin{itemize}
\tightlist
\item
  ggplot2
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ diamonds, }\KeywordTok{aes}\NormalTok{(carat, price)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-242-1.pdf}

\begin{itemize}
\tightlist
\item
  dplyr, ggplot2
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-243-1.pdf}

\hypertarget{ux441ux43bux43eux438}{%
\subsection{Слои}\label{ux441ux43bux43eux438}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_smooth}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = "cs")'
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-244-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_smooth}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = "cs")'
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-245-1.pdf}

\hypertarget{aes}{%
\subsection{\texorpdfstring{\texttt{aes()}}{aes()}}\label{aes}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price, }\DataTypeTok{color =}\NormalTok{ cut))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-246-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{color =} \StringTok{"green"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-247-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color =}\NormalTok{ cut))}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-248-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price, }\DataTypeTok{shape =}\NormalTok{ cut))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-249-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price, }\DataTypeTok{label =}\NormalTok{ color))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_text}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-250-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price, }\DataTypeTok{label =}\NormalTok{ color))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_label}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-251-1.pdf}

Иногда аннотации налезают друг на друга:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ggrepel)}
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price, }\DataTypeTok{label =}\NormalTok{ color))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_text_repel}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-252-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price, }\DataTypeTok{label =}\NormalTok{ color))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_text_repel}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-253-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price, }\DataTypeTok{label =}\NormalTok{ color, }\DataTypeTok{fill =}\NormalTok{ cut))}\OperatorTok{+}\StringTok{ }\CommentTok{# fill отвечает за закрашивание}
\StringTok{  }\KeywordTok{geom_label_repel}\NormalTok{(}\DataTypeTok{alpha =} \FloatTok{0.5}\NormalTok{)}\OperatorTok{+}\StringTok{ }\CommentTok{# alpha отвечает за прозрачность}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-254-1.pdf}

\hypertarget{ux43eux444ux43eux440ux43cux43bux435ux43dux438ux435}{%
\subsection{Оформление}\label{ux43eux444ux43eux440ux43cux43bux435ux43dux438ux435}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price, }\DataTypeTok{color =}\NormalTok{ cut))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{x =} \StringTok{"вес (в каратах)"}\NormalTok{,}
       \DataTypeTok{y =} \StringTok{"цена (в долларах)"}\NormalTok{,}
       \DataTypeTok{title =} \StringTok{"Связь цены и веса бриллиантов"}\NormalTok{,}
       \DataTypeTok{subtitle =} \StringTok{"Данные взяты из датасеты diamonds"}\NormalTok{,}
       \DataTypeTok{caption =} \StringTok{"график сделан при помощи пакета ggplot2"}\NormalTok{)}\OperatorTok{+}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"bottom"}\NormalTok{) }\CommentTok{# у функции theme() огромный функционал}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-255-1.pdf}

\hypertarget{ux43bux43eux433ux430ux440ux438ux444ux43cux438ux447ux435ux441ux43aux438ux435-ux448ux43aux430ux43bux44b}{%
\subsection{Логарифмические шкалы}\label{ux43bux43eux433ux430ux440ux438ux444ux43cux438ux447ux435ux441ux43aux438ux435-ux448ux43aux430ux43bux44b}}

\includegraphics{images/log_scales.png}

Рассмотрим словарь {[}Ляшевской, Шарова 2011{]}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{freqdict <-}\StringTok{ }\KeywordTok{read_tsv}\NormalTok{(}\StringTok{"https://github.com/agricolamz/2020-2021-ds4dh/raw/master/data/freq_dict_2011.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## -- Column specification --------------------------------------------------------
## cols(
##   lemma = col_character(),
##   pos = col_character(),
##   freq_ipm = col_double()
## )
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{freqdict }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{arrange}\NormalTok{(}\KeywordTok{desc}\NormalTok{(freq_ipm)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{id =} \DecValTok{1}\OperatorTok{:}\KeywordTok{n}\NormalTok{()) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{150}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(id, freq_ipm))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/freqdict_download-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{freqdict }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{arrange}\NormalTok{(}\KeywordTok{desc}\NormalTok{(freq_ipm)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{id =} \DecValTok{1}\OperatorTok{:}\KeywordTok{n}\NormalTok{()) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{150}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(id, freq_ipm, }\DataTypeTok{label =}\NormalTok{ lemma))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_text_repel}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{scale_y_log10}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/freqdict_visualise-1.pdf}

\hypertarget{annotate}{%
\subsection{\texorpdfstring{\texttt{annotate()}}{annotate()}}\label{annotate}}

Функция \texttt{annotate} добавляет \texttt{geom} к графику.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price, }\DataTypeTok{color =}\NormalTok{ cut))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{annotate}\NormalTok{(}\DataTypeTok{geom =} \StringTok{"rect"}\NormalTok{, }\DataTypeTok{xmin =} \FloatTok{4.8}\NormalTok{, }\DataTypeTok{xmax =} \FloatTok{5.2}\NormalTok{,}
           \DataTypeTok{ymin =} \DecValTok{17500}\NormalTok{, }\DataTypeTok{ymax =} \DecValTok{18500}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{alpha =} \FloatTok{0.2}\NormalTok{) }\OperatorTok{+}\StringTok{ }
\StringTok{  }\KeywordTok{annotate}\NormalTok{(}\DataTypeTok{geom =} \StringTok{"text"}\NormalTok{, }\DataTypeTok{x =} \FloatTok{4.7}\NormalTok{, }\DataTypeTok{y =} \DecValTok{16600}\NormalTok{,}
           \DataTypeTok{label =} \StringTok{"помогите...}\CharTok{\textbackslash{}n}\StringTok{ я в розовом}\CharTok{\textbackslash{}n}\StringTok{квадратике"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-256-1.pdf}

\begin{rmdtask}
Скачайте
\href{https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/first_scatterplot.csv}{вот
этот датасет} и постройте диаграмму рассеяния.
\end{rmdtask}

\hypertarget{ux441ux442ux43eux43bux431ux447ux430ux442ux44bux435-ux434ux438ux430ux433ux440ux430ux43cux43cux44b-barplots}{%
\section{Столбчатые диаграммы (barplots)}\label{ux441ux442ux43eux43bux431ux447ux430ux442ux44bux435-ux434ux438ux430ux433ux440ux430ux43cux43cux44b-barplots}}

Одна и та же информация может быть представлена в агрегированном и не агрегированном варианте:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{misspelling <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\StringTok{"https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/misspelling_dataset.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## -- Column specification --------------------------------------------------------
## cols(
##   correct = col_character(),
##   spelling = col_character(),
##   count = col_double()
## )
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{misspelling }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 15,477 x 3
##    correct   spelling    count
##    <chr>     <chr>       <dbl>
##  1 deschanel deschanel   18338
##  2 deschanel dechanel     1550
##  3 deschanel deschannel    934
##  4 deschanel deschenel     404
##  5 deschanel deshanel      364
##  6 deschanel dechannel     359
##  7 deschanel deschanelle   316
##  8 deschanel dechanelle    192
##  9 deschanel deschanell    174
## 10 deschanel deschenal     165
## # ... with 15,467 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  переменные spelling \textbf{аггрегирована}: для каждого значения представлено значение в столбце count, которое обозначает количество каждого из написаний
\item
  переменные correct \textbf{неаггрегированы}: в этом столбце она повторяется, для того, чтобы сделать вывод, нужно отдельно посчитать количество вариантов
\end{itemize}

Для аггрегированных данных используется \texttt{geom\_col()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{misspelling }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(spelling, count))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_col}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-260-1.pdf}

Перевернем оси:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{misspelling }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(spelling, count))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_col}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{coord_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-261-1.pdf}

Для неаггрегированных данных используется \texttt{geom\_bar()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{misspelling }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(correct))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_bar}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-262-1.pdf}

Перевернем оси:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{misspelling }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(correct))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_bar}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{coord_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-263-1.pdf}

Неаггрегированный вариант можно перевести в аггрегированный:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{count}\NormalTok{(cut)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 5 x 2
##   cut           n
##   <ord>     <int>
## 1 Fair       1610
## 2 Good       4906
## 3 Very Good 12082
## 4 Premium   13791
## 5 Ideal     21551
\end{verbatim}

Аггрегированный вариант можно перевести в неаггрегированный:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{count}\NormalTok{(cut) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{uncount}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 53,940 x 1
##    cut  
##    <ord>
##  1 Fair 
##  2 Fair 
##  3 Fair 
##  4 Fair 
##  5 Fair 
##  6 Fair 
##  7 Fair 
##  8 Fair 
##  9 Fair 
## 10 Fair 
## # ... with 53,930 more rows
\end{verbatim}

\hypertarget{ux444ux430ux43aux442ux43eux440ux44b}{%
\section{Факторы}\label{ux444ux430ux43aux442ux43eux440ux44b}}

Как можно заметить по предыдущему разделу, переменные на графике упорядочены по алфавиту. Чтобы это исправить нужно обсудить факторы:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_factor <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(misspelling}\OperatorTok{$}\NormalTok{correct)}
\KeywordTok{head}\NormalTok{(my_factor)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] deschanel deschanel deschanel deschanel deschanel deschanel
## 15 Levels: deschanel galifianakis johansson kaepernick labeouf ... shyamalan
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{levels}\NormalTok{(my_factor)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "deschanel"    "galifianakis" "johansson"    "kaepernick"   "labeouf"     
##  [6] "macaulay"     "mcconaughey"  "mcgwire"      "mclachlan"    "minaj"       
## [11] "morissette"   "palahniuk"    "picabo"       "poehler"      "shyamalan"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{levels}\NormalTok{(my_factor) <-}\StringTok{ }\KeywordTok{rev}\NormalTok{(}\KeywordTok{levels}\NormalTok{(my_factor))}
\KeywordTok{head}\NormalTok{(my_factor)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] shyamalan shyamalan shyamalan shyamalan shyamalan shyamalan
## 15 Levels: shyamalan poehler picabo palahniuk morissette minaj ... deschanel
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{misspelling }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{correct =} \KeywordTok{factor}\NormalTok{(correct, }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"deschanel"}\NormalTok{,}
                                              \StringTok{"galifianakis"}\NormalTok{,}
                                              \StringTok{"johansson"}\NormalTok{,}
                                              \StringTok{"kaepernick"}\NormalTok{,}
                                              \StringTok{"labeouf"}\NormalTok{,}
                                              \StringTok{"macaulay"}\NormalTok{,}
                                              \StringTok{"mcgwire"}\NormalTok{,}
                                              \StringTok{"mclachlan"}\NormalTok{,}
                                              \StringTok{"minaj"}\NormalTok{,}
                                              \StringTok{"morissette"}\NormalTok{,}
                                              \StringTok{"palahniuk"}\NormalTok{,}
                                              \StringTok{"picabo"}\NormalTok{,}
                                              \StringTok{"poehler"}\NormalTok{,}
                                              \StringTok{"shyamalan"}\NormalTok{,}
                                              \StringTok{"mcconaughey"}\NormalTok{))) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(correct))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_bar}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{coord_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-266-1.pdf}

Для работы с факторами удобно использовать пакет \texttt{forcats} (входит в \texttt{tidyverse}, вот \href{https://github.com/rstudio/cheatsheets/raw/master/factors.pdf}{ссылка на cheatsheet}).

Иногда полезной бывает функция \texttt{fct\_reorder()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{misspelling }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{count}\NormalTok{(correct)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 15 x 2
##    correct          n
##    <chr>        <int>
##  1 deschanel     1015
##  2 galifianakis  2633
##  3 johansson      392
##  4 kaepernick     779
##  5 labeouf        449
##  6 macaulay      1458
##  7 mcconaughey   2897
##  8 mcgwire        262
##  9 mclachlan     1054
## 10 minaj          200
## 11 morissette     478
## 12 palahniuk     1541
## 13 picabo         460
## 14 poehler        386
## 15 shyamalan     1473
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{misspelling }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{count}\NormalTok{(correct) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\KeywordTok{fct_reorder}\NormalTok{(correct, n), n))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_col}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{coord_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-267-1.pdf}

Кроме того, в функцию \texttt{fct\_reorder()} можно добавит функцию, которая будет считаться на векторе, по которому группируют:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{cut =} \KeywordTok{fct_reorder}\NormalTok{(cut, price, mean)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(cut)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_bar}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-268-1.pdf}

В этом примере переменная \texttt{cut} упорядочена по средней \texttt{mean} цене \texttt{price}. Естественно, вместо \texttt{mean} можно использовать другие функции (\texttt{median}, \texttt{min}, \texttt{max} или даже собственные функции).

Можно совмещать разные \texttt{geom\_...}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{misspelling }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{count}\NormalTok{(correct) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\KeywordTok{fct_reorder}\NormalTok{(correct, n), n, }\DataTypeTok{label =}\NormalTok{ n))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_col}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_text}\NormalTok{(}\DataTypeTok{nudge_y =} \DecValTok{150}\NormalTok{)}\OperatorTok{+}
\StringTok{  }\KeywordTok{coord_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-269-1.pdf}

\begin{rmdtask}
На Pudding вышла \href{https://pudding.cool/2019/10/pubs/}{статья про
английские пабы}.
\href{https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/UK_pubs.csv}{Здесь}
лежит немного обработанный датасет, которые они использовали.
Визуализируйте 30 самых частотоных названий пабов в Великобритании.
\end{rmdtask}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-271-1.pdf}

\begin{rmdtask}
На новостном портале meduza.io недавно вышла
\href{https://meduza.io/short/2019/09/30/pervye-polgoda-primeneniya-zakona-o-neuvazhenii-k-vlasti-v-internete-doklad-agory}{новость
о применения закона ``о неуважении к власти в интернете''}. Постройте
графики из этой новости. При построении графиков я использовал цвет
\texttt{"tan3"}.
\end{rmdtask}

\includegraphics{images/visualisation_task.png}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-274-1.pdf}

\hypertarget{ux434ux43eux442ux43fux43bux43eux442}{%
\section{Дотплот}\label{ux434ux43eux442ux43fux43bux43eux442}}

Иногда для случаев, когда мы исследуем числовую переменную подходит простой график, который отображает распределение наших наблюдений на одной соответствующей числовой шкале.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(mpg)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_dotplot}\NormalTok{(}\DataTypeTok{method =} \StringTok{"histodot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-276-1.pdf}

По оси x отложена наша переменная, каждая точка -- одно наблюдение, а отложенное по оси y стоит игнорировать -- оно появляется из-за ограничений пакета \texttt{ggplot2}. Возможно чуть понятнее будет, если добавить \texttt{geom\_rug()}, который непосредственно отображает \textbf{каждое} наблюдение.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(mpg)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_rug}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_dotplot}\NormalTok{(}\DataTypeTok{method =} \StringTok{"histodot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-277-1.pdf}

Больший смысл имеет раскрашенный вариант:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{cyl =} \KeywordTok{factor}\NormalTok{(cyl)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(mpg, }\DataTypeTok{fill =}\NormalTok{ cyl)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_rug}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_dotplot}\NormalTok{(}\DataTypeTok{method =} \StringTok{"histodot"}\NormalTok{)}\OperatorTok{+}
\StringTok{  }\KeywordTok{scale_y_continuous}\NormalTok{(}\OtherTok{NULL}\NormalTok{, }\DataTypeTok{breaks =} \OtherTok{NULL}\NormalTok{) }\CommentTok{# чтобы убрать ось y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-278-1.pdf}
Как видно, на графике, одна синяя точка попала под одну зеленую: значит они имеют общее наблюдение.

\hypertarget{ux433ux438ux441ux442ux43eux433ux440ux430ux43cux43cux44b}{%
\section{Гистограммы}\label{ux433ux438ux441ux442ux43eux433ux440ux430ux43cux43cux44b}}

Если наблюдений слишком много, дотплот не имеем много смысла:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(price)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_dotplot}\NormalTok{(}\DataTypeTok{method =} \StringTok{"histodot"}\NormalTok{)}\OperatorTok{+}
\StringTok{  }\KeywordTok{scale_y_continuous}\NormalTok{(}\OtherTok{NULL}\NormalTok{, }\DataTypeTok{breaks =} \OtherTok{NULL}\NormalTok{) }\CommentTok{# чтобы убрать ось y}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-279-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(price)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-279-2.pdf}

Обсудим на предыдущем примере

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(mpg))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_rug}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-280-1.pdf}

По оси x отложена наша переменная, а высота столбца говорит, сколько наблюдений имеют такое же наблюдение. Однако многое зависит от того, что мы считаем одинаковым значением:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(mpg)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_rug}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{bins =} \DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-281-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(mpg)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_rug}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{bins =} \DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-281-2.pdf}

Существует три алгоритма встроенные в R, которые можно использовать и снимать с себя ответственность:

\begin{itemize}
\tightlist
\item
  {[}Sturgers 1926{]} \texttt{nclass.Sturges(mtcars\$mpg)}
\item
  {[}Scott 1979{]} \texttt{nclass.scott(mtcars\$mpg)}
\item
  {[}Freedman, Diaconis 1981{]} \texttt{nclass.FD(mtcars\$mpg)}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(mpg)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{bins =} \KeywordTok{nclass.FD}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{mpg))}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-282-1.pdf}

\begin{rmdtask}
Какой из методов использовался при создании следующего графика на основе
встроенного датасета \texttt{iris}?
\end{rmdtask}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-284-1.pdf}

В этом типе графика точно так же можно раскрашивать на основании другой переменной:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(Petal.Length, }\DataTypeTok{fill =}\NormalTok{ Species)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_rug}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-285-1.pdf}

\hypertarget{ux444ux443ux43dux43aux446ux438ux438-ux43fux43bux43eux442ux43dux43eux441ux442ux438}{%
\section{Функции плотности}\label{ux444ux443ux43dux43aux446ux438ux438-ux43fux43bux43eux442ux43dux43eux441ux442ux438}}

Кроме того, существует способ использовать не такой рубленный график, а его сглаженную вариант, ыйторый строиться при помои функции плотядерной оценки ности. Важное свойство, которое стоит понимать про функцию плотности --- что кривая, получаемая ядерной оценкой плотности, не зависит от величины коробки гистделения (хотя есть аргумент, который от \texttt{adjust}вечает за степень ``близости'' функции плотности к гистограмме).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(Petal.Length)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_rug}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_density}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-286-1.pdf}

Таким образом мы можем сравнивать распределения:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(Petal.Length, }\DataTypeTok{fill =}\NormalTok{ Species)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_rug}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_density}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-287-1.pdf}

Часто имеет смысл настроить прозрачность:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(Petal.Length, }\DataTypeTok{fill =}\NormalTok{ Species)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_rug}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_density}\NormalTok{(}\DataTypeTok{alpha =} \FloatTok{0.6}\NormalTok{) }\CommentTok{# значение прозрачности изменяется от 0 до 1}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-288-1.pdf}

Кроме того, иногда удобно разделять группы на разные уровни:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# install.packages(ggridges)}
\KeywordTok{library}\NormalTok{(ggridges)}
\NormalTok{iris }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(Petal.Length, Species, }\DataTypeTok{fill =}\NormalTok{ Species)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_density_ridges}\NormalTok{(}\DataTypeTok{alpha =} \FloatTok{0.6}\NormalTok{) }\CommentTok{# значение прозрачности изменяется от 0 до 1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Picking joint bandwidth of 0.155
\end{verbatim}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-289-1.pdf}

\begin{rmdtask}
В длинный список ``2015 Kantar Information is Beautiful Awards'' попала
\href{https://www.informationisbeautifulawards.com/showcase/818-perceptions-of-probability}{визуализация
Perceptions of Probability}, сделанная пользователем
\href{https://github.com/zonination}{zonination} в \texttt{ggplot2}.
Попробуйте воспроизвести ее
\href{https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/perceptions_of_probability.csv}{с
этими данными}.
\end{rmdtask}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-291-1.pdf}

\hypertarget{ux442ux43eux447ux43aux438-ux434ux436ux438ux442ux442ux435ux440-jitter-ux432ux430ux439ux43eux43bux438ux43dux43fux43bux43eux442-violinplot-ux44fux449ux438ux43aux438-ux441-ux443ux441ux430ux43cux438-boxplot}{%
\section{Точки, джиттер (jitter), вайолинплот (violinplot), ящики с усами (boxplot),}\label{ux442ux43eux447ux43aux438-ux434ux436ux438ux442ux442ux435ux440-jitter-ux432ux430ux439ux43eux43bux438ux43dux43fux43bux43eux442-violinplot-ux44fux449ux438ux43aux438-ux441-ux443ux441ux430ux43cux438-boxplot}}

Вот другие способы показать распределение числовой переменной:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(Species, Petal.Length))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-293-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(Species, Petal.Length))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_jitter}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-293-2.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(Species, Petal.Length))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_jitter}\NormalTok{(}\DataTypeTok{width =} \FloatTok{0.3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-293-3.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"ggbeeswarm"}\NormalTok{)}
\NormalTok{iris }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(Species, Petal.Length))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_quasirandom}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-293-4.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(cut, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_violin}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-293-5.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(cut, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_boxplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-293-6.pdf}

\includegraphics{images/boxplot.png}

\hypertarget{ux444ux430ux441ux435ux442ux438ux437ux430ux446ux438ux44f}{%
\section{Фасетизация}\label{ux444ux430ux441ux435ux442ux438ux437ux430ux446ux438ux44f}}

Достаточно мощным инструментом анализа данных является фасетизация, которая позволяет разбивать графики на основе какой-то переменной.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \FloatTok{0.3}\NormalTok{)}\OperatorTok{+}
\StringTok{  }\KeywordTok{facet_wrap}\NormalTok{(}\OperatorTok{~}\NormalTok{cut)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-294-1.pdf}
При этом иногда так бывает, что наличие какой-то одного значение в одном из фасетов, заставляет иметь одну и ту же шкалу для всех остальных. Это можно изменить при помощи аргумента \texttt{scales}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \FloatTok{0.3}\NormalTok{)}\OperatorTok{+}
\StringTok{  }\KeywordTok{facet_wrap}\NormalTok{(}\OperatorTok{~}\NormalTok{cut, }\DataTypeTok{scales =} \StringTok{"free"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-295-1.pdf}

Кроме того, можно добавлять дополнительные аргументы:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \FloatTok{0.3}\NormalTok{)}\OperatorTok{+}
\StringTok{  }\KeywordTok{facet_wrap}\NormalTok{(}\OperatorTok{~}\NormalTok{cut}\OperatorTok{+}\NormalTok{color)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-296-1.pdf}

Кроме того, можно создавать сетки переменных используя geom\_grid(), они \texttt{facet\_grid()}ньше места, чем \texttt{facet\_wrap()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \FloatTok{0.3}\NormalTok{)}\OperatorTok{+}
\StringTok{  }\KeywordTok{facet_grid}\NormalTok{(cut}\OperatorTok{~}\NormalTok{color, }\DataTypeTok{scales =} \StringTok{"free"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-297-1.pdf}

Кроме того \texttt{facet\_grid()} позволяет делать обощающие поля, где представлены все данные по какой-то строчке или столбцу:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diamonds }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(carat, price))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \FloatTok{0.3}\NormalTok{)}\OperatorTok{+}
\StringTok{  }\KeywordTok{facet_grid}\NormalTok{(cut}\OperatorTok{~}\NormalTok{color, }\DataTypeTok{scales =} \StringTok{"free"}\NormalTok{, }\DataTypeTok{margins =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-298-1.pdf}

\hypertarget{ux432ux438ux437ux443ux430ux43bux438ux437ux430ux446ux438ux44f-ux43aux43eux43cux431ux438ux43dux430ux446ux438ux439-ux43fux440ux438ux437ux43dux430ux43aux43eux432}{%
\section{Визуализация комбинаций признаков}\label{ux432ux438ux437ux443ux430ux43bux438ux437ux430ux446ux438ux44f-ux43aux43eux43cux431ux438ux43dux430ux446ux438ux439-ux43fux440ux438ux437ux43dux430ux43aux43eux432}}

\hypertarget{ux43fux43eux442ux43eux43aux43eux432ux430ux44f-ux434ux438ux430ux433ux440ux430ux43cux43cux430-sankey-diagram}{%
\subsection{Потоковая Диаграмма (Sankey diagram)}\label{ux43fux43eux442ux43eux43aux43eux432ux430ux44f-ux434ux438ux430ux433ux440ux430ux43cux43cux430-sankey-diagram}}

Один из способов визуализации отношений между признаками называется \href{https://en.wikipedia.org/wiki/Sankey_diagram}{потоковая диаграмма}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"ggforce"}\NormalTok{)}
\NormalTok{zhadina <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\StringTok{"https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/zhadina.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## -- Column specification --------------------------------------------------------
## cols(
##   word_1 = col_character(),
##   word_2 = col_character(),
##   word_3 = col_character(),
##   type = col_character(),
##   n = col_double()
## )
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zhadina }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{gather_set_data}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(x, }\DataTypeTok{id =}\NormalTok{ id, }\DataTypeTok{split =}\NormalTok{ y, }\DataTypeTok{value =}\NormalTok{ n))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_parallel_sets}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{fill =}\NormalTok{ type), }\DataTypeTok{alpha =} \FloatTok{0.6}\NormalTok{, }\DataTypeTok{axis.width =} \FloatTok{0.5}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_parallel_sets_axes}\NormalTok{(}\DataTypeTok{axis.width =} \FloatTok{0.5}\NormalTok{, }\DataTypeTok{color =} \StringTok{"lightgrey"}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"white"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_parallel_sets_labels}\NormalTok{(}\DataTypeTok{angle =} \DecValTok{0}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{theme_no_axes}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"bottom"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-299-1.pdf}

А как поменять порядок? Снова факторы.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zhadina }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{gather_set_data}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{y =} \KeywordTok{fct_reorder}\NormalTok{(y, n, mean)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(x, }\DataTypeTok{id =}\NormalTok{ id, }\DataTypeTok{split =}\NormalTok{ y, }\DataTypeTok{value =}\NormalTok{ n))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_parallel_sets}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{fill =}\NormalTok{ type), }\DataTypeTok{alpha =} \FloatTok{0.6}\NormalTok{, }\DataTypeTok{axis.width =} \FloatTok{0.5}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_parallel_sets_axes}\NormalTok{(}\DataTypeTok{axis.width =} \FloatTok{0.5}\NormalTok{, }\DataTypeTok{color =} \StringTok{"lightgrey"}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"white"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_parallel_sets_labels}\NormalTok{(}\DataTypeTok{angle =} \DecValTok{0}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{theme_no_axes}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"bottom"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-300-1.pdf}

Можно донастроить, задав собственный порядок в аргументе \texttt{levels} функции \texttt{factor()}.

\hypertarget{upset-plot}{%
\subsection{UpSet Plot}\label{upset-plot}}

Если диаграмма Sankey визуализирует попарные отношения между переменными, то график UpSet потенциально может визуализировать все возможные комбинации и является хорошей альтернативой диаграмме Вена, с большим количеством переменных (см. \href{https://www.littlemissdata.com/blog/set-analysis}{эту статью Лауры Эллис}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(UpSetR)}
\NormalTok{movies <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{( }\KeywordTok{system.file}\NormalTok{(}\StringTok{"extdata"}\NormalTok{, }\StringTok{"movies.csv"}\NormalTok{, }\DataTypeTok{package =} \StringTok{"UpSetR"}\NormalTok{), }\DataTypeTok{header=}\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{sep=}\StringTok{";"}\NormalTok{ )}
\KeywordTok{str}\NormalTok{(movies)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    3883 obs. of  21 variables:
##  $ Name       : chr  "Toy Story (1995)" "Jumanji (1995)" "Grumpier Old Men (1995)" "Waiting to Exhale (1995)" ...
##  $ ReleaseDate: int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
##  $ Action     : int  0 0 0 0 0 1 0 0 1 1 ...
##  $ Adventure  : int  0 1 0 0 0 0 0 1 0 1 ...
##  $ Children   : int  1 1 0 0 0 0 0 1 0 0 ...
##  $ Comedy     : int  1 0 1 1 1 0 1 0 0 0 ...
##  $ Crime      : int  0 0 0 0 0 1 0 0 0 0 ...
##  $ Documentary: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ Drama      : int  0 0 0 1 0 0 0 0 0 0 ...
##  $ Fantasy    : int  0 1 0 0 0 0 0 0 0 0 ...
##  $ Noir       : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ Horror     : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ Musical    : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ Mystery    : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ Romance    : int  0 0 1 0 0 0 1 0 0 0 ...
##  $ SciFi      : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ Thriller   : int  0 0 0 0 0 1 0 0 0 1 ...
##  $ War        : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ Western    : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ AvgRating  : num  4.15 3.2 3.02 2.73 3.01 3.88 3.41 3.01 2.66 3.54 ...
##  $ Watches    : int  2077 701 478 170 296 940 458 68 102 888 ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{upset}\NormalTok{(movies[,}\DecValTok{3}\OperatorTok{:}\DecValTok{19}\NormalTok{], }\DataTypeTok{nsets =} \DecValTok{16}\NormalTok{, }\DataTypeTok{order.by =} \StringTok{"freq"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-301-1.pdf}

\hypertarget{strings}{%
\chapter{Работа со строками}\label{strings}}

\hypertarget{ux440ux430ux431ux43eux442ux430-ux441ux43e-ux441ux442ux440ux43eux43aux430ux43cux438-ux432-r}{%
\section{Работа со строками в R}\label{ux440ux430ux431ux43eux442ux430-ux441ux43e-ux441ux442ux440ux43eux43aux430ux43cux438-ux432-r}}

Для работы со строками можно использовать:

\begin{itemize}
\tightlist
\item
  базовый R
\item
  пакет \texttt{stringr} (часть \texttt{tidyverse})
\item
  пакет \texttt{stringi} -- отдельный пакет, так что не забудьте его установить:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"stringi"}\NormalTok{)}
\KeywordTok{library}\NormalTok{(tidyverse)}
\KeywordTok{library}\NormalTok{(stringi)}
\end{Highlighting}
\end{Shaded}

Мы будем пользоваться в основном пакетами \texttt{stingr} и \texttt{stringi}, так как они в большинстве случаях удобнее. К счастью функции этих пакетов легко отличить от остальных: функции пакет \texttt{stringr} всегда начинаются с \texttt{str\_}, а функции пакета \texttt{stringi} --- c \texttt{stri\_}.

Существует \href{https://github.com/rstudio/cheatsheets/raw/master/strings.pdf}{cheat sheet по \texttt{stringr}}.

\hypertarget{ux43aux430ux43a-ux43fux43eux43bux443ux447ux438ux442ux44c-ux441ux442ux440ux43eux43aux443}{%
\section{Как получить строку?}\label{ux43aux430ux43a-ux43fux43eux43bux443ux447ux438ux442ux44c-ux441ux442ux440ux43eux43aux443}}

\begin{itemize}
\tightlist
\item
  следите за кавычками
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"the quick brown fox jumps over the lazy dog"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "the quick brown fox jumps over the lazy dog"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{'the quick brown fox jumps over the lazy dog'}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "the quick brown fox jumps over the lazy dog"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"the quick 'brown' fox jumps over the lazy dog"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "the quick 'brown' fox jumps over the lazy dog"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{'the quick "brown" fox jumps over the lazy dog'}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "the quick \"brown\" fox jumps over the lazy dog"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  пустая строка
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{""}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] ""
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{''}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] ""
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{character}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "" "" ""
\end{verbatim}

\begin{itemize}
\tightlist
\item
  преобразование
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(}\DecValTok{4}\OperatorTok{:}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "integer"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(}\DecValTok{4}\OperatorTok{:}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "4" "5" "6" "7"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  встроенные векторы
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{letters}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
## [20] "t" "u" "v" "w" "x" "y" "z"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{LETTERS}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
## [20] "T" "U" "V" "W" "X" "Y" "Z"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{month.name}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "January"   "February"  "March"     "April"     "May"       "June"     
##  [7] "July"      "August"    "September" "October"   "November"  "December"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создание рандомных строк
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{42}\NormalTok{)}
\KeywordTok{stri_rand_strings}\NormalTok{(}\DataTypeTok{n =} \DecValTok{10}\NormalTok{, }\DataTypeTok{length =} \DecValTok{5}\OperatorTok{:}\DecValTok{14}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "uwHpd"          "Wj8ehS"         "ivFSwy7"        "TYu8zw5V"      
##  [5] "OuRpjoOg0"      "p0CubNR2yQ"     "xtdycKLOm2k"    "fAGVfylZqBGp"  
##  [9] "gE28DTCi0NV0a"  "9MemYE55If0Cvv"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Перемешивает символы внутри строки
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stri_rand_shuffle}\NormalTok{(}\StringTok{"любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] ",цо м,пюзгу   сл аиъ—в кжряд,ыщьчебэн х—штё фй"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stri_rand_shuffle}\NormalTok{(month.name)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "aJayunr"   "eyrbraFu"  "achMr"     "Aplri"     "ayM"       "Jnue"     
##  [7] "uJly"      "usuAgt"    "tpebermSe" "tOecrbo"   "oeNembvr"  "Dmceerbe"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Генерирует псевдорандомный текст \footnote{Lorem ipsum --- классический текст-заполнитель на основе трактата Марка Туллия Цицерона ``О пределах добра и зла''. Его используют, чтобы посмотреть, как страница смотриться, когда заполнена текстом}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stri_rand_lipsum}\NormalTok{(}\DataTypeTok{nparagraphs =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Lorem ipsum dolor sit amet, donec sit nunc urna sed ultricies ac pharetra orci luctus iaculis, ac tincidunt cum. Neque eu semper at sociosqu hendrerit. Eu aliquet lacus, eu hendrerit donec aliquam eros. Risus nibh, quam in sit facilisi ipsum. Amet sem sed donec sed molestie scelerisque tincidunt. Nisl donec et facilisis interdum non sed dolor purus. In ipsum dignissim torquent velit nec aliquam pellentesque. Ac, adipiscing, neque et at torquent, vestibulum ullamcorper. Ad dictumst enim velit non nulla felis habitant. Egestas placerat consectetur, dictum nostra sed nec. Erat phasellus dolor libero aliquam viverra. Vestibulum leo et. Suscipit egestas in in montes, sapien gravida? Conubia purus varius ut nec feugiat."
## [2] "Risus eleifend magnis neque diam, suspendisse ullamcorper nulla adipiscing malesuada massa, nisi sociosqu velit id et. Aliquam facilisis et aenean. Parturient vel ac in convallis, massa diam nibh. Nulla interdum cursus et. Natoque amet, ut praesent. Tortor ultrices a consectetur, augue natoque class faucibus? Ut sed arcu elementum magna. Dignissim ac facilisi quis ut nisl eu, massa."
\end{verbatim}

\hypertarget{ux441ux43eux435ux434ux438ux43dux435ux43dux438ux435-ux438-ux440ux430ux437ux434ux435ux43bux435ux43dux438ux435-ux441ux442ux440ux43eux43a}{%
\section{Соединение и разделение строк}\label{ux441ux43eux435ux434ux438ux43dux435ux43dux438ux435-ux438-ux440ux430ux437ux434ux435ux43bux435ux43dux438ux435-ux441ux442ux440ux43eux43a}}

Соединенить строки можно используя функцию \texttt{str\_c()}, в которую, как и в функции \texttt{с()}, можно перечислять элементы через запятую:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{upper =} \KeywordTok{rev}\NormalTok{(LETTERS), }\DataTypeTok{smaller =}\NormalTok{ letters) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{merge =} \KeywordTok{str_c}\NormalTok{(upper, smaller))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 26 x 3
##    upper smaller merge
##    <chr> <chr>   <chr>
##  1 Z     a       Za   
##  2 Y     b       Yb   
##  3 X     c       Xc   
##  4 W     d       Wd   
##  5 V     e       Ve   
##  6 U     f       Uf   
##  7 T     g       Tg   
##  8 S     h       Sh   
##  9 R     i       Ri   
## 10 Q     j       Qj   
## # ... with 16 more rows
\end{verbatim}

Кроме того, если хочется, можно использовать особенный разделитель, указав его в аргументе \texttt{sep}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{upper =} \KeywordTok{rev}\NormalTok{(LETTERS), }\DataTypeTok{smaller =}\NormalTok{ letters) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{merge =} \KeywordTok{str_c}\NormalTok{(upper, smaller, }\DataTypeTok{sep =} \StringTok{"_"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 26 x 3
##    upper smaller merge
##    <chr> <chr>   <chr>
##  1 Z     a       Z_a  
##  2 Y     b       Y_b  
##  3 X     c       X_c  
##  4 W     d       W_d  
##  5 V     e       V_e  
##  6 U     f       U_f  
##  7 T     g       T_g  
##  8 S     h       S_h  
##  9 R     i       R_i  
## 10 Q     j       Q_j  
## # ... with 16 more rows
\end{verbatim}

Аналогичным образом, для разделение строки на подстроки можно использовать функцию \texttt{separate()}. Это функция разносит разделенные элементы строки в соответствующие столбцы. У функции три обязательных аргумента: \texttt{col} --- колонка, которую следует разделить, \texttt{into} --- вектор названий новых столбец, \texttt{sep} --- разделитель.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{upper =} \KeywordTok{rev}\NormalTok{(LETTERS), }\DataTypeTok{smaller =}\NormalTok{ letters) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{merge =} \KeywordTok{str_c}\NormalTok{(upper, smaller, }\DataTypeTok{sep =} \StringTok{"_"}\NormalTok{)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{separate}\NormalTok{(}\DataTypeTok{col =}\NormalTok{ merge, }\DataTypeTok{into =} \KeywordTok{c}\NormalTok{(}\StringTok{"column_1"}\NormalTok{, }\StringTok{"column_2"}\NormalTok{), }\DataTypeTok{sep =} \StringTok{"_"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 26 x 4
##    upper smaller column_1 column_2
##    <chr> <chr>   <chr>    <chr>   
##  1 Z     a       Z        a       
##  2 Y     b       Y        b       
##  3 X     c       X        c       
##  4 W     d       W        d       
##  5 V     e       V        e       
##  6 U     f       U        f       
##  7 T     g       T        g       
##  8 S     h       S        h       
##  9 R     i       R        i       
## 10 Q     j       Q        j       
## # ... with 16 more rows
\end{verbatim}

Кроме того, есть инструмент \texttt{str\_split()}, которая позволяет разбивать строки на подстроки, но возвращает \emph{список}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_split}\NormalTok{(month.name, }\StringTok{"r"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "Janua" "y"    
## 
## [[2]]
## [1] "Feb" "ua"  "y"  
## 
## [[3]]
## [1] "Ma" "ch"
## 
## [[4]]
## [1] "Ap" "il"
## 
## [[5]]
## [1] "May"
## 
## [[6]]
## [1] "June"
## 
## [[7]]
## [1] "July"
## 
## [[8]]
## [1] "August"
## 
## [[9]]
## [1] "Septembe" ""        
## 
## [[10]]
## [1] "Octobe" ""      
## 
## [[11]]
## [1] "Novembe" ""       
## 
## [[12]]
## [1] "Decembe" ""
\end{verbatim}

\hypertarget{ux43aux43eux43bux438ux447ux435ux441ux442ux432ux43e-ux441ux438ux43cux432ux43eux43bux43eux432}{%
\section{Количество символов}\label{ux43aux43eux43bux438ux447ux435ux441ux442ux432ux43e-ux441ux438ux43cux432ux43eux43bux43eux432}}

\hypertarget{ux43fux43eux434ux441ux447ux435ux442-ux43aux43eux43bux438ux447ux435ux441ux442ux432ux430-ux441ux438ux43cux432ux43eux43bux43eux432}{%
\subsection{Подсчет количества символов}\label{ux43fux43eux434ux441ux447ux435ux442-ux43aux43eux43bux438ux447ux435ux441ux442ux432ux430-ux441ux438ux43cux432ux43eux43bux43eux432}}

\includegraphics{images/5.01_str_length.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{n_charactars =} \KeywordTok{str_count}\NormalTok{(mn))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        n_charactars
##    <chr>            <int>
##  1 January              7
##  2 February             8
##  3 March                5
##  4 April                5
##  5 May                  3
##  6 June                 4
##  7 July                 4
##  8 August               6
##  9 September            9
## 10 October              7
## 11 November             8
## 12 December             8
\end{verbatim}

\hypertarget{ux43fux43eux434ux433ux43eux43dux43aux430-ux43aux43eux43bux438ux447ux435ux441ux442ux432ux430-ux441ux438ux43cux432ux43eux43bux43eux432}{%
\subsection{Подгонка количества символов}\label{ux43fux43eux434ux433ux43eux43dux43aux430-ux43aux43eux43bux438ux447ux435ux441ux442ux432ux430-ux441ux438ux43cux432ux43eux43bux43eux432}}

Можно обрезать строки, используя функцию \texttt{str\_trunc()}:

\includegraphics{images/5.02_str_trunc.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mn_new =} \KeywordTok{str_trunc}\NormalTok{(mn, }\DecValTok{6}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mn_new
##    <chr>     <chr> 
##  1 January   Jan...
##  2 February  Feb...
##  3 March     March 
##  4 April     April 
##  5 May       May   
##  6 June      June  
##  7 July      July  
##  8 August    August
##  9 September Sep...
## 10 October   Oct...
## 11 November  Nov...
## 12 December  Dec...
\end{verbatim}

Можно решить с какой стороны обрезать, используя аргумент \texttt{side}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mn_new =} \KeywordTok{str_trunc}\NormalTok{(mn, }\DecValTok{6}\NormalTok{, }\DataTypeTok{side =} \StringTok{"left"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mn_new
##    <chr>     <chr> 
##  1 January   ...ary
##  2 February  ...ary
##  3 March     March 
##  4 April     April 
##  5 May       May   
##  6 June      June  
##  7 July      July  
##  8 August    August
##  9 September ...ber
## 10 October   ...ber
## 11 November  ...ber
## 12 December  ...ber
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mn_new =} \KeywordTok{str_trunc}\NormalTok{(mn, }\DecValTok{6}\NormalTok{, }\DataTypeTok{side =} \StringTok{"center"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mn_new
##    <chr>     <chr> 
##  1 January   Ja...y
##  2 February  Fe...y
##  3 March     March 
##  4 April     April 
##  5 May       May   
##  6 June      June  
##  7 July      July  
##  8 August    August
##  9 September Se...r
## 10 October   Oc...r
## 11 November  No...r
## 12 December  De...r
\end{verbatim}

Можно заменить многоточие, используя аргумент \texttt{ellipsis}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mn_new =} \KeywordTok{str_trunc}\NormalTok{(mn, }\DecValTok{3}\NormalTok{, }\DataTypeTok{ellipsis =} \StringTok{""}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mn_new
##    <chr>     <chr> 
##  1 January   Jan   
##  2 February  Feb   
##  3 March     Mar   
##  4 April     Apr   
##  5 May       May   
##  6 June      Jun   
##  7 July      Jul   
##  8 August    Aug   
##  9 September Sep   
## 10 October   Oct   
## 11 November  Nov   
## 12 December  Dec
\end{verbatim}

Можно наоборот ``раздуть'' строку:

\includegraphics{images/5.03_str_pad.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mn_new =} \KeywordTok{str_pad}\NormalTok{(mn, }\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mn_new      
##    <chr>     <chr>       
##  1 January   "   January"
##  2 February  "  February"
##  3 March     "     March"
##  4 April     "     April"
##  5 May       "       May"
##  6 June      "      June"
##  7 July      "      July"
##  8 August    "    August"
##  9 September " September"
## 10 October   "   October"
## 11 November  "  November"
## 12 December  "  December"
\end{verbatim}

Опять же есть аргумент \texttt{side}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mn_new =} \KeywordTok{str_pad}\NormalTok{(mn, }\DecValTok{10}\NormalTok{,  }\DataTypeTok{side =} \StringTok{"right"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mn_new      
##    <chr>     <chr>       
##  1 January   "January   "
##  2 February  "February  "
##  3 March     "March     "
##  4 April     "April     "
##  5 May       "May       "
##  6 June      "June      "
##  7 July      "July      "
##  8 August    "August    "
##  9 September "September "
## 10 October   "October   "
## 11 November  "November  "
## 12 December  "December  "
\end{verbatim}

Также можно выбрать, чем ``раздувать строку'':

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mn_new =} \KeywordTok{str_pad}\NormalTok{(mn, }\DecValTok{10}\NormalTok{,  }\DataTypeTok{pad =} \StringTok{"."}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mn_new    
##    <chr>     <chr>     
##  1 January   ...January
##  2 February  ..February
##  3 March     .....March
##  4 April     .....April
##  5 May       .......May
##  6 June      ......June
##  7 July      ......July
##  8 August    ....August
##  9 September .September
## 10 October   ...October
## 11 November  ..November
## 12 December  ..December
\end{verbatim}

\begin{rmdtask}
На Pudding вышла \href{https://pudding.cool/2019/10/pubs/}{статья про
английские пабы}.
\href{https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/UK_pubs.csv}{Здесь}
лежит немного обработанный датасет, которые они использовали.
Визуализируйте 40 самых частотоных названий пабов в Великобритании,
отложив по оси x количество символов, а по оси y -- количество баров с
таким названием.
\end{rmdtask}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-323-1.pdf}

📋 список подсказок ➡

👁 Датасет скачался, что дальше? ➡
Перво-наперво следует создать переменную, в которой бы хранилось количество каждого из баров.

👁 А как посчитать количество баров? ➡
Это можно сделать при помощи функции \texttt{count()}.

👁 Бары пересчитали, что дальше? ➡
Теперь нужно создать новую переменную, где бы хранилась информация о количестве символов.

👁 Все переменные есть, теперь рисуем? ➡
Не совсем. Перед тем как рисовать нужно отфильтровать 50 самых популярных.

👁 Так, все готово, а какие \texttt{geom\_()}? ➡
На графике \texttt{geom\_point()} и \texttt{geom\_text\_repel()} из пакета \texttt{ggrepel}.

👁 А-а-а-а! \texttt{could\ not\ find\ function\ "geom\_text\_repel"} ➡
А вы включили библиотеку \texttt{ggrepel}? Если не включили, то функция, естественно будет недоступна.

👁 А-а-а-а! \texttt{geom\_text\_repel\ requires\ the\ following\ missing\ aesthetics:\ label"} ➡
Все, как написала программа: чтобы писать какой-то текст в функции \texttt{aes()} нужно добавить аргумент \texttt{label\ =\ pub\_name}. Иначе откуда он узнает, что ему писать?

👁 Фуф! Все готово! ➡
А оси подписаны? А заголовок? А подпись про источник данных?

\hypertarget{ux441ux43eux440ux442ux438ux440ux43eux432ux43aux430}{%
\section{Сортировка}\label{ux441ux43eux440ux442ux438ux440ux43eux432ux43aux430}}

Для сортировки существует базовая функция \texttt{sort()} и функция из \texttt{stringr} \texttt{str\_sort()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unsorted_latin <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"I"}\NormalTok{, }\StringTok{"♥"}\NormalTok{, }\StringTok{"N"}\NormalTok{, }\StringTok{"Y"}\NormalTok{)}
\KeywordTok{sort}\NormalTok{(unsorted_latin)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "♥" "I" "N" "Y"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_sort}\NormalTok{(unsorted_latin)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "♥" "I" "N" "Y"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_sort}\NormalTok{(unsorted_latin, }\DataTypeTok{locale =} \StringTok{"lt"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "♥" "I" "Y" "N"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unsorted_cyrillic <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"я"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"ж"}\NormalTok{)}
\KeywordTok{str_sort}\NormalTok{(unsorted_cyrillic)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "i" "ж" "я"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_sort}\NormalTok{(unsorted_cyrillic, }\DataTypeTok{locale =} \StringTok{"ru_UA"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ж" "я" "i"
\end{verbatim}

Список локалей на копмьютере можно посмотреть командой \texttt{stringi::stri\_locale\_list()}. Список всех локалей вообще приведен \href{https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes}{на этой странице}. Еще полезные команды: \texttt{stringi::stri\_locale\_info} и \texttt{stringi::stri\_locale\_set}.

Не углубляясь в \href{https://www.youtube.com/watch?v=BeoCbJPuvSE}{разнообразие алгоритмов сортировки}, отмечу, что алгоритм по-умолчанию хуже работает с большими данными:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{42}\NormalTok{)}
\NormalTok{huge <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(letters, }\FloatTok{1e7}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{head}\NormalTok{(huge)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "q" "e" "a" "y" "j" "d"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{system.time}\NormalTok{(}
  \KeywordTok{sort}\NormalTok{(huge)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##   6.785   0.020   6.806
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{system.time}\NormalTok{(}
  \KeywordTok{sort}\NormalTok{(huge, }\DataTypeTok{method =} \StringTok{"radix"}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##   0.277   0.028   0.305
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{system.time}\NormalTok{(}
  \KeywordTok{str_sort}\NormalTok{(huge)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##   5.949   0.050   5.999
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{huge_tbl <-}\StringTok{ }\KeywordTok{tibble}\NormalTok{(huge)}
\KeywordTok{system.time}\NormalTok{(}
\NormalTok{  huge_tbl }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{arrange}\NormalTok{(huge)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    user  system elapsed 
##  34.201   0.043  34.246
\end{verbatim}

Предварительный вывод: для больших данных -- \texttt{sort(...,\ method\ =\ "radix")}.

\hypertarget{ux43fux43eux438ux441ux43a-ux43fux43eux434ux441ux442ux440ux43eux43aux438}{%
\section{Поиск подстроки}\label{ux43fux43eux438ux441ux43a-ux43fux43eux434ux441ux442ux440ux43eux43aux438}}

Можно использовать функцию \texttt{str\_detect()}:

\includegraphics{images/5.04_str_detect.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{has_r =} \KeywordTok{str_detect}\NormalTok{(mn, }\StringTok{"r"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        has_r
##    <chr>     <lgl>
##  1 January   TRUE 
##  2 February  TRUE 
##  3 March     TRUE 
##  4 April     TRUE 
##  5 May       FALSE
##  6 June      FALSE
##  7 July      FALSE
##  8 August    FALSE
##  9 September TRUE 
## 10 October   TRUE 
## 11 November  TRUE 
## 12 December  TRUE
\end{verbatim}

Кроме того, существует функция, которая возвращает индексы, а не значения \texttt{TRUE}/\texttt{FALSE}:
\includegraphics{images/5.05_str_which.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\KeywordTok{str_which}\NormalTok{(mn, }\StringTok{"r"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 8 x 1
##   mn       
##   <chr>    
## 1 January  
## 2 February 
## 3 March    
## 4 April    
## 5 September
## 6 October  
## 7 November 
## 8 December
\end{verbatim}

Также можно посчитать количество вхождений какой-то подстроки:

\includegraphics{images/5.06_str_count.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{has_r =} \KeywordTok{str_count}\NormalTok{(mn, }\StringTok{"r"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        has_r
##    <chr>     <int>
##  1 January       1
##  2 February      2
##  3 March         1
##  4 April         1
##  5 May           0
##  6 June          0
##  7 July          0
##  8 August        0
##  9 September     1
## 10 October       1
## 11 November      1
## 12 December      1
\end{verbatim}

\hypertarget{ux438ux437ux43cux435ux43dux435ux43dux438ux435-ux441ux442ux440ux43eux43a}{%
\section{Изменение строк}\label{ux438ux437ux43cux435ux43dux435ux43dux438ux435-ux441ux442ux440ux43eux43a}}

\hypertarget{ux438ux437ux43cux435ux43dux435ux43dux438ux435-ux440ux435ux433ux438ux441ux442ux440ux430}{%
\subsection{Изменение регистра}\label{ux438ux437ux43cux435ux43dux435ux43dux438ux435-ux440ux435ux433ux438ux441ux442ux440ux430}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latin <-}\StringTok{ "tHe QuIcK BrOwN fOx JuMpS OvEr ThE lAzY dOg"}
\NormalTok{cyrillic <-}\StringTok{ "лЮбЯ, сЪеШь ЩиПцЫ, — вЗдОхНёТ мЭр, — кАйФ жГуЧ"}
\KeywordTok{str_to_upper}\NormalTok{(latin)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_to_lower}\NormalTok{(cyrillic)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_to_title}\NormalTok{(latin)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "The Quick Brown Fox Jumps Over The Lazy Dog"
\end{verbatim}

\hypertarget{ux432ux44bux434ux435ux43bux435ux43dux438ux435-ux43fux43eux434ux441ux442ux440ux43eux43aux438}{%
\subsection{Выделение подстроки}\label{ux432ux44bux434ux435ux43bux435ux43dux438ux435-ux43fux43eux434ux441ux442ux440ux43eux43aux438}}

Подстроку в строке можно выделить двумя способами: по индексам функцией \texttt{str\_sub()}, и по подстроке функцией \texttt{str\_png()}.

extract(images/5.07\_str\_sub.png)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mutate =} \KeywordTok{str_sub}\NormalTok{(mn, }\DataTypeTok{start =} \DecValTok{1}\NormalTok{, }\DataTypeTok{end =} \DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mutate
##    <chr>     <chr> 
##  1 January   Ja    
##  2 February  Fe    
##  3 March     Ma    
##  4 April     Ap    
##  5 May       Ma    
##  6 June      Ju    
##  7 July      Ju    
##  8 August    Au    
##  9 September Se    
## 10 October   Oc    
## 11 November  No    
## 12 December  De
\end{verbatim}

\includegraphics{images/5.08_str_extract.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mutate =} \KeywordTok{str_extract}\NormalTok{(mn, }\StringTok{"r"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mutate
##    <chr>     <chr> 
##  1 January   r     
##  2 February  r     
##  3 March     r     
##  4 April     r     
##  5 May       <NA>  
##  6 June      <NA>  
##  7 July      <NA>  
##  8 August    <NA>  
##  9 September r     
## 10 October   r     
## 11 November  r     
## 12 December  r
\end{verbatim}

По умолчанию функция \texttt{str\_extract()} возвращает первое вхождение подстроки, соответствующей шаблону. Также существует функция \texttt{str\_extract\_all()}, которая возвращает все вхождения подстрок, соответствующих шаблону, однако возвращает объект типа список.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_extract_all}\NormalTok{(month.name, }\StringTok{"r"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "r"
## 
## [[2]]
## [1] "r" "r"
## 
## [[3]]
## [1] "r"
## 
## [[4]]
## [1] "r"
## 
## [[5]]
## character(0)
## 
## [[6]]
## character(0)
## 
## [[7]]
## character(0)
## 
## [[8]]
## character(0)
## 
## [[9]]
## [1] "r"
## 
## [[10]]
## [1] "r"
## 
## [[11]]
## [1] "r"
## 
## [[12]]
## [1] "r"
\end{verbatim}

\hypertarget{ux437ux430ux43cux435ux43dux430-ux43fux43eux434ux441ux442ux440ux43eux43aux438}{%
\subsection{Замена подстроки}\label{ux437ux430ux43cux435ux43dux430-ux43fux43eux434ux441ux442ux440ux43eux43aux438}}

Существует функция \texttt{str\_replace()}, которая позволяет заменить одну подстроку в строке на другую:

\includegraphics{images/5.11_str_replace.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mutate =} \KeywordTok{str_replace}\NormalTok{(mn, }\StringTok{"r"}\NormalTok{, }\StringTok{"R"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mutate   
##    <chr>     <chr>    
##  1 January   JanuaRy  
##  2 February  FebRuary 
##  3 March     MaRch    
##  4 April     ApRil    
##  5 May       May      
##  6 June      June     
##  7 July      July     
##  8 August    August   
##  9 September SeptembeR
## 10 October   OctobeR  
## 11 November  NovembeR 
## 12 December  DecembeR
\end{verbatim}

Как и другие функции \texttt{str\_replace()} делает лишь одну замену, чтобы заменить все вхождения подстроки следует использовать функцию \texttt{str\_replace\_all()}:

\includegraphics{images/5.12_str_replace_all.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{mn =}\NormalTok{ month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mutate =} \KeywordTok{str_replace_all}\NormalTok{(mn, }\StringTok{"r"}\NormalTok{, }\StringTok{"R"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    mn        mutate   
##    <chr>     <chr>    
##  1 January   JanuaRy  
##  2 February  FebRuaRy 
##  3 March     MaRch    
##  4 April     ApRil    
##  5 May       May      
##  6 June      June     
##  7 July      July     
##  8 August    August   
##  9 September SeptembeR
## 10 October   OctobeR  
## 11 November  NovembeR 
## 12 December  DecembeR
\end{verbatim}

\hypertarget{ux443ux434ux430ux43bux435ux43dux438ux435-ux43fux43eux434ux441ux442ux440ux43eux43aux438}{%
\subsection{Удаление подстроки}\label{ux443ux434ux430ux43bux435ux43dux438ux435-ux43fux43eux434ux441ux442ux440ux43eux43aux438}}

Для удаления подстроки на основе шаблона, используется функция \texttt{str\_remove()} и \texttt{str\_remove\_all()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mutate =} \KeywordTok{str_remove}\NormalTok{(month.name, }\StringTok{"r"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    month.name mutate  
##    <chr>      <chr>   
##  1 January    Januay  
##  2 February   Febuary 
##  3 March      Mach    
##  4 April      Apil    
##  5 May        May     
##  6 June       June    
##  7 July       July    
##  8 August     August  
##  9 September  Septembe
## 10 October    Octobe  
## 11 November   Novembe 
## 12 December   Decembe
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tibble}\NormalTok{(month.name) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{mutate =} \KeywordTok{str_remove_all}\NormalTok{(month.name, }\StringTok{"r"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 12 x 2
##    month.name mutate  
##    <chr>      <chr>   
##  1 January    Januay  
##  2 February   Febuay  
##  3 March      Mach    
##  4 April      Apil    
##  5 May        May     
##  6 June       June    
##  7 July       July    
##  8 August     August  
##  9 September  Septembe
## 10 October    Octobe  
## 11 November   Novembe 
## 12 December   Decembe
\end{verbatim}

\hypertarget{ux442ux440ux430ux43dux441ux43bux438ux442ux435ux440ux430ux446ux438ux44f-ux441ux442ux440ux43eux43a}{%
\subsection{Транслитерация строк}\label{ux442ux440ux430ux43dux441ux43bux438ux442ux435ux440ux430ux446ux438ux44f-ux441ux442ux440ux43eux43a}}

В пакете \texttt{stringi} сууществует достаточно много методов транслитераций строк, которые можно вывести командой \texttt{stri\_trans\_list()}. Вот пример использования некоторых из них:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stri_trans_general}\NormalTok{(}\StringTok{"stringi"}\NormalTok{, }\StringTok{"latin-cyrillic"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "стринги"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stri_trans_general}\NormalTok{(}\StringTok{"сырники"}\NormalTok{, }\StringTok{"cyrillic-latin"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "syrniki"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stri_trans_general}\NormalTok{(}\StringTok{"stringi"}\NormalTok{, }\StringTok{"latin-greek"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "στριγγι"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stri_trans_general}\NormalTok{(}\StringTok{"stringi"}\NormalTok{, }\StringTok{"latin-armenian"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ստրինգի"
\end{verbatim}

\begin{rmdtask}
Вот два датасета:

\begin{itemize}
\tightlist
\item
  \href{https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/cities_of_russia.csv}{список
  городов России}
\item
  \href{https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/freq_dict_2011.csv}{частотный
  словарь русского языка {[}Шаров, Ляшевская 2011{]}}
\end{itemize}

Определите сколько городов называется обычным словом русского языка
(например, город Орёл)? Не забудьте поменять ё на е.
\end{rmdtask}

📋 список подсказок ➡

👁 Датасеты скачались, что дальше? ➡
Надо их преобразовать к нужному виду и объединить.

👁 А как их соединить? Что у них общего? ➡ \\
В одном датасете есть переменная \texttt{city}, в другом -- переменная \texttt{lemma}. Все города начинаются с большой буквы, все леммы с маленькой буквы. Я бы уменьшил букву в датасете с городами, сделал бы новый столбец в датасете с городами (например, \texttt{town}), соединил бы датасеты и посчитал бы сколько в результирующем датасете значений \texttt{town}.

👁 А как соеднить? ➡
Я бы использовал \texttt{dict\ \%\textgreater{}\%\ ...\ \%\textgreater{}\%\ inner\_join(cities)}. Если в датасетах разные названия столбцов, то следует указывать какие столбцы, каким соответствуют:\texttt{dict\ \%\textgreater{}\%\ ...\ \%\textgreater{}\%\ inner\_join(cities,\ by\ =\ c("lemma"\ =\ "city"))}

👁 Соединилось вроде\ldots{} А как посчитать? ➡
Я бы, как обычно, использовал функцию \texttt{count()}.

\hypertarget{ux440ux435ux433ux443ux43bux44fux440ux43dux44bux435-ux432ux44bux440ux430ux436ux435ux43dux438ux44f}{%
\section{Регулярные выражения}\label{ux440ux435ux433ux443ux43bux44fux440ux43dux44bux435-ux432ux44bux440ux430ux436ux435ux43dux438ux44f}}

Большинство функций из раздела об операциях над векторами (\texttt{str\_detect()}, \texttt{str\_extract()}, \texttt{str\_remove()} и т. п.) имеют следующую структуру:

\begin{itemize}
\tightlist
\item
  строка, с которой работает функция
\item
  образец (pattern)
\end{itemize}

Дальше мы будем использовать функцию \texttt{str\_view\_all()}, которая позволяет показывать, выделенное образцом в исходной строке.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Я всегда путаю с и c"}\NormalTok{, }\StringTok{"c"}\NormalTok{) }\CommentTok{# я ищу латинскую c}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-339-1.pdf}

\hypertarget{ux44dux43aux440ux430ux43dux438ux440ux43eux432ux430ux43dux438ux435-ux43cux435ux442ux430ux441ux438ux43cux432ux43eux43bux43eux432}{%
\subsection{Экранирование метасимволов}\label{ux44dux43aux440ux430ux43dux438ux440ux43eux432ux430ux43dux438ux435-ux43cux435ux442ux430ux441ux438ux43cux432ux43eux43bux43eux432}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ "Всем известно, что 4$}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{2 + 3$ * 5 = 17$? Да? Ну хорошо (а то я не был уверен). [|\}^\{|]"}
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"$"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{$"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-2.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-3.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{*"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-4.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{+"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-5.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{?"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-6.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{("}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-7.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-8.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{|"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-9.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{^"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-10.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{["}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-11.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-12.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{\{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-13.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{\}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-14.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(a, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}}\StringTok{"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-340-15.pdf}

\hypertarget{ux43aux43bux430ux441ux441ux44b-ux437ux43dux430ux43aux43eux432}{%
\subsection{Классы знаков}\label{ux43aux43bux430ux441ux441ux44b-ux437ux43dux430ux43aux43eux432}}

\begin{itemize}
\tightlist
\item
  \texttt{\textbackslash{}\textbackslash{}d} -- цифры. \texttt{\textbackslash{}\textbackslash{}D} -- не цифры.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"два 15 42. 42 15. 37 08 5. 20 20 20!"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{d"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-341-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"два 15 42. 42 15. 37 08 5. 20 20 20!"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{D"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-341-2.pdf}

\begin{itemize}
\tightlist
\item
  \texttt{\textbackslash{}\textbackslash{}s} -- пробелы. \texttt{\textbackslash{}\textbackslash{}S} -- не пробелы.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"два 15 42. 42 15. 37 08 5. 20 20 20!"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{s"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-342-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"два 15 42. 42 15. 37 08 5. 20 20 20!"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{S"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-342-2.pdf}

\begin{itemize}
\tightlist
\item
  \texttt{\textbackslash{}\textbackslash{}w} -- не пробелы и не знаки препинания. \texttt{\textbackslash{}\textbackslash{}W} -- пробелы и знаки препинания.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"два 15 42. 42 15. 37 08 5. 20 20 20!"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{w"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-343-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"два 15 42. 42 15. 37 08 5. 20 20 20!"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{W"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-343-2.pdf}

\begin{itemize}
\tightlist
\item
  произвольная группа символов и обратная к ней
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Умей мечтать, не став рабом мечтанья"}\NormalTok{, }\StringTok{"[оауиыэёеяю]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-344-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"И мыслить, мысли не обожествив"}\NormalTok{, }\StringTok{"[^оауиыэёеяю]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-344-2.pdf}

\begin{itemize}
\tightlist
\item
  встроенные группы символов
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"два 15 42. 42 15. 37 08 5. 20 20 20!"}\NormalTok{, }\StringTok{"[0-9]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-345-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Карл у Клары украл кораллы, а Клара у Карла украла кларнет"}\NormalTok{, }\StringTok{"[а-я]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-345-2.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Карл у Клары украл кораллы, а Клара у Карла украла кларнет"}\NormalTok{, }\StringTok{"[А-Я]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-345-3.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Карл у Клары украл кораллы, а Клара у Карла украла кларнет"}\NormalTok{, }\StringTok{"[А-я]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-345-4.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"The quick brown Fox jumps over the lazy Dog"}\NormalTok{, }\StringTok{"[a-z]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-345-5.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"два 15 42. 42 15. 37 08 5. 20 20 20!"}\NormalTok{, }\StringTok{"[^0-9]"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-345-6.pdf}

\includegraphics{images/5.13_alternates.png}

\begin{itemize}
\tightlist
\item
  выбор из нескольких групп
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Карл у Клары украл кораллы, а Клара у Карла украла кларнет"}\NormalTok{, }\StringTok{"лар|рал|арл"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-346-1.pdf}

\begin{itemize}
\tightlist
\item
  произвольный символ
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Везет Сенька Саньку с Сонькой на санках. Санки скок, Сеньку с ног, Соньку в лоб, все — в сугроб"}\NormalTok{, }\StringTok{"[Сс].н"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-347-1.pdf}

\begin{itemize}
\tightlist
\item
  знак начала и конца строки
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"от топота копыт пыль по полю летит."}\NormalTok{, }\StringTok{"^о"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-348-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"У ежа — ежата, у ужа — ужата"}\NormalTok{, }\StringTok{"жата$"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-348-2.pdf}

\begin{itemize}
\tightlist
\item
  есть еще другие группы и другие обозначения уже приведенных групп, см. \texttt{?regex}
\end{itemize}

\includegraphics{images/5.14_anchors.png}

\hypertarget{ux43aux432ux430ux43dux442ux438ux444ux438ux43aux430ux446ux438ux44f}{%
\subsection{Квантификация}\label{ux43aux432ux430ux43dux442ux438ux444ux438ux43aux430ux446ux438ux44f}}

\begin{itemize}
\tightlist
\item
  \texttt{?} -- ноль или один раз
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"хорошее длинношеее животное"}\NormalTok{, }\StringTok{"еее?"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-349-1.pdf}

\begin{itemize}
\tightlist
\item
  \texttt{*} -- ноль и более раз
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"хорошее длинношеее животное"}\NormalTok{, }\StringTok{"ее*"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-350-1.pdf}

\begin{itemize}
\tightlist
\item
  \texttt{+} -- один и более раз
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"хорошее длинношеее животное"}\NormalTok{, }\StringTok{"е+"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-351-1.pdf}

\begin{itemize}
\tightlist
\item
  \texttt{\{n\}} -- \texttt{n} раз
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"хорошее длинношеее животное"}\NormalTok{, }\StringTok{"е\{2\}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-352-1.pdf}

\begin{itemize}
\tightlist
\item
  \texttt{\{n,\}} -- \texttt{n} раз и более
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"хорошее длинношеее животное"}\NormalTok{, }\StringTok{"е\{1,\}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-353-1.pdf}

\begin{itemize}
\tightlist
\item
  \texttt{\{n,m\}} -- от \texttt{n} до \texttt{m}. Отсутствие пробела важно: \texttt{\{1,2\}} -- правильно, \texttt{\{1,␣2\}} -- неправильно.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"хорошее длинношеее животное"}\NormalTok{, }\StringTok{"е\{2,3\}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-354-1.pdf}

\begin{itemize}
\tightlist
\item
  группировка символов
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Пушкиновед, Лермонтовед, Лермонтововед"}\NormalTok{, }\StringTok{"(ов)+"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-355-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"беловатый, розоватый, розововатый"}\NormalTok{, }\StringTok{"(ов)+"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-355-2.pdf}

\begin{itemize}
\tightlist
\item
  жадный vs.~нежадный алоритмы
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Пушкиновед, Лермонтовед, Лермонтововед"}\NormalTok{, }\StringTok{"в.*ед"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-356-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Пушкиновед, Лермонтовед, Лермонтововед"}\NormalTok{, }\StringTok{"в.*?ед"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-356-2.pdf}

\includegraphics{images/5.15_quantifiers.png}

\hypertarget{ux43fux43eux437ux438ux446ux438ux43eux43dux43dux430ux44f-ux43fux440ux43eux432ux435ux440ux43aux430-look-arounds}{%
\subsection{Позиционная проверка (look arounds)}\label{ux43fux43eux437ux438ux446ux438ux43eux43dux43dux430ux44f-ux43fux440ux43eux432ux435ux440ux43aux430-look-arounds}}

Позиционная проверка -- выглядит достаточно непоследовательно даже в свете остальных регулярных выражений.

Давайте найдем все \emph{а} \textbf{перед} \emph{р}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Карл у Клары украл кораллы, а Клара у Карла украла кларнет"}\NormalTok{, }\StringTok{"а(?=р)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-357-1.pdf}

А теперь все \emph{а} \textbf{перед} \emph{р} или \emph{л}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Карл у Клары украл кораллы, а Клара у Карла украла кларнет"}\NormalTok{, }\StringTok{"а(?=[рл])"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-358-1.pdf}

Давайте найдем все а \textbf{после} \emph{р}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Карл у Клары украл кораллы, а Клара у Карла украла кларнет"}\NormalTok{, }\StringTok{"(?<=р)а"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-359-1.pdf}

А теперь все \emph{а} \textbf{после} \emph{р} или \emph{л}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Карл у Клары украл кораллы, а Клара у Карла украла кларнет"}\NormalTok{, }\StringTok{"(?<=[рл])а"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-360-1.pdf}

Также у этих выражений есть формы с отрицанием. Давайте найдем все \emph{р} \textbf{не перед} \emph{а}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Карл у Клары украл кораллы, а Клара у Карла украла кларнет"}\NormalTok{, }\StringTok{"р(?!а)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-361-1.pdf}

А теперь все \emph{р} \textbf{не после} \emph{а}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_view_all}\NormalTok{(}\StringTok{"Карл у Клары украл кораллы, а Клара у Карла украла кларнет"}\NormalTok{, }\StringTok{"(?<!а)р"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-362-1.pdf}

Запомнить с ходу это достаточно сложно, так что подсматривайте сюда:

\includegraphics{images/5.16_lookarounds.png}

\begin{rmdtask}
\href{https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/zabolockiy_merknut_znaki_zodiaka.txt}{Вот
отсюда} можно скачать файл с текстом стихотворения Н. Заболоцкого
``Меркнут знаки задиака''. Посчитайте долю женских (ударение падает на
\textbf{предпоследний} слог рифмующихся слов) и мужских (ударение падает
на \textbf{последний} слог рифмующихся слов) рифм в стихотворении.
\end{rmdtask}

📋 список подсказок ➡

👁 Датасеты скачивается с ошибкой, почему? ➡
Дело в том, что исходный файл в формате \texttt{.txt}, а не \texttt{.csv}. Его нужно скачивать, например, командой \texttt{read\_lines()}

👁 Ошибка: \texttt{...applied\ to\ an\ object\ of\ class\ "character"} ➡ \\
Скачав файл Вы получили вектор со строками, где каждая элимент вектора -- строка стихотворения. Создайте \texttt{tibble()}, тогда можно будет применять стандартные инструменты \texttt{tidyverse}.

👁 Хорошо, \texttt{tibble()} создан, что дальше? ➡
Дальше нужно создать переменную, из которой будет понятно, мужская в каждой строке рифма, или женская.

👁 А как определить, какая рифма? Нужно с словарем сравнивать? ➡
Формально говоря, определять рифму можно по косвенным признакам. Все стихотворение написано четырехстопным хореем, значит в нем либо 7, либо 8 слогов. Значит, посчитав количество слогов, мы поймем, какая перед нами рифма.

👁 А как посчитать гласные? ➡
Нужно написать регулярное выражение\ldots{} вроде бы это тема нашего занятия\ldots{}

👁 Гласные посчитаны. А что дальше? ➡
Ну теперь нужно посчитать, сколько каких длин (в количестве слогов) бывает в стихотворении. Это можно сделать при помощи функции \texttt{count()}.

👁 А почему у меня есть строки длины 0 слогов ➡
Ну, видимо, в стихотворении были пустые строки. Они использовались для разделения строф.

👁 А почему у меня есть строки длины 6 слогов ➡
Ну, видимо, Вы написали регулярное выражение, которое не учитывает, что гласные буквы могут быть еще и в начале строки, а значит написаны с большой буквы.

\begin{rmdtask}
В ходе анализа данных чаще всего бороться со строками и регулярными
выражениями приходится в процессе обработки неаккуратнособранных анкет.
Предлагаю обработать переменные \texttt{sex} и \texttt{age}
\href{https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/mad_questionary.csv}{такой
вот неудачно собранной анкеты} и построить следующий график:
\end{rmdtask}

\includegraphics{images/mad_questionary_task.png}

📋 список подсказок ➡

👁 А что это за \texttt{geom\_...()}? ➡
Это \href{https://agricolamz.github.io/DS_for_DH/viz-1.html\#\%D0\%B4\%D0\%BE\%D1\%82\%D0\%BF\%D0\%BB\%D0\%BE\%D1\%82}{\texttt{geom\_dotplot()}} с аргументом \texttt{method\ =\ "histodot"} и с удаленной осью y при помощи команды \texttt{scale\_y\_continuous(NULL,\ breaks\ =\ NULL)}

👁 Почему на графике рисутеся каждое значение возраста? ➡
Если Вы все правильно преобразовали, должно помочь преобразование строковой переменной age в числовую при помощи функции as.integer().

\hypertarget{ux43eux43fux440ux435ux434ux435ux43bux435ux43dux438ux435-ux44fux437ux44bux43aux430}{%
\section{Определение языка}\label{ux43eux43fux440ux435ux434ux435ux43bux435ux43dux438ux435-ux44fux437ux44bux43aux430}}

Для определения языка существует два пакета \texttt{cld2} (вероятностный) и \texttt{cld3} (нейросеть).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{udhr_}\DecValTok{24}\NormalTok{ <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\StringTok{"https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/article_24_from_UDHR.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## -- Column specification --------------------------------------------------------
## cols(
##   article_text = col_character()
## )
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{udhr_}\DecValTok{24}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 1
##   article_text                                                                  
##   <chr>                                                                         
## 1 Каждый человек имеет право на отдых и досуг, включая право на разумное ограни~
## 2 Everyone has the right to rest and leisure, including reasonable limitation o~
## 3 Toute personne a droit au repos et aux loisirs et notamment à une limitation ~
## 4 Toda persona tiene derecho al descanso, al disfrute del tiempo libre, a una l~
## 5 لكلِّ شخص حقٌّ في الراحة وأوقات الفراغ، وخصوصًا في تحديد معقول لساعات العمل و~     
## 6 人人有享有休息和闲暇的权利，包括工作时间有合理限制和定期给薪休假的权利。
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld2}\OperatorTok{::}\KeywordTok{detect_language}\NormalTok{(udhr_}\DecValTok{24}\OperatorTok{$}\NormalTok{article_text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ru" "en" "fr" "es" "ar" "zh"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld2}\OperatorTok{::}\KeywordTok{detect_language}\NormalTok{(udhr_}\DecValTok{24}\OperatorTok{$}\NormalTok{article_text, }\DataTypeTok{lang_code =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "RUSSIAN" "ENGLISH" "FRENCH"  "SPANISH" "ARABIC"  "CHINESE"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld3}\OperatorTok{::}\KeywordTok{detect_language}\NormalTok{(udhr_}\DecValTok{24}\OperatorTok{$}\NormalTok{article_text)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ru" "en" "fr" "es" "ar" "zh"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld2}\OperatorTok{::}\KeywordTok{detect_language}\NormalTok{(}\StringTok{"Ты женат? Говорите ли по-английски?"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "bg"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld3}\OperatorTok{::}\KeywordTok{detect_language}\NormalTok{(}\StringTok{"Ты женат? Говорите ли по-английски?"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld2}\OperatorTok{::}\KeywordTok{detect_language}\NormalTok{(}\StringTok{"Варкалось. Хливкие шорьки пырялись по наве, и хрюкотали зелюки, как мюмзики в мове."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ru"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld3}\OperatorTok{::}\KeywordTok{detect_language}\NormalTok{(}\StringTok{"Варкалось. Хливкие шорьки пырялись по наве, и хрюкотали зелюки, как мюмзики в мове."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "ru"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld2}\OperatorTok{::}\KeywordTok{detect_language}\NormalTok{(}\StringTok{"Варчилось… Хлив'язкі тхурки викрули, свербчись навкрузі, жасумновілі худоки гривіли зехряки в чузі."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "uk"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld3}\OperatorTok{::}\KeywordTok{detect_language}\NormalTok{(}\StringTok{"Варчилось… Хлив'язкі тхурки викрули, свербчись навкрузі, жасумновілі худоки гривіли зехряки в чузі."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "uk"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld2}\OperatorTok{::}\KeywordTok{detect_language_mixed}\NormalTok{(}\StringTok{"Многие в нашей команде OpenDataScience занимаются state-of-the-art технологиями машинного обучения: DL-фреймворками, байесовскими методами машинного обучения, вероятностным программированием и не только."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $classification
##   language code latin proportion
## 1  RUSSIAN   ru FALSE       0.87
## 2  ENGLISH   en  TRUE       0.11
## 3  UNKNOWN   un  TRUE       0.00
## 
## $bytes
## [1] 353
## 
## $reliabale
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cld3}\OperatorTok{::}\KeywordTok{detect_language_mixed}\NormalTok{(}\StringTok{"Многие в нашей команде OpenDataScience занимаются state-of-the-art технологиями машинного обучения: DL-фреймворками, байесовскими методами машинного обучения, вероятностным программированием и не только."}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   language probability reliable proportion
## 1       ru   0.9983915     TRUE 0.88951844
## 2       en   0.9992564     TRUE 0.05099150
## 3       sr   0.4266235    FALSE 0.04815864
\end{verbatim}

\hypertarget{ux440ux430ux441ux441ux442ux43eux44fux43dux438ux44f-ux43cux435ux436ux434ux443-ux441ux442ux440ux43eux43aux430ux43cux438}{%
\section{Расстояния между строками}\label{ux440ux430ux441ux441ux442ux43eux44fux43dux438ux44f-ux43cux435ux436ux434ux443-ux441ux442ux440ux43eux43aux430ux43cux438}}

Существует много разных метрик для измерения расстояния между строками (см. ?{}`stringdist-metrics`), в примерах используется расстояние Дамерау --- Левенштейна. Данное расстояние получается при подсчете количества операций, которые нужно сделать, чтобы перевести одну строку в другую.

\begin{itemize}
\tightlist
\item
  вставка ab → aNb
\item
  удаление aOb → ab
\item
  замена символа aOb → aNb
\item
  перестановка символов ab → ba
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(stringdist)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Attaching package: 'stringdist'
\end{verbatim}

\begin{verbatim}
## The following object is masked from 'package:tidyr':
## 
##     extract
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stringdist}\NormalTok{(}\StringTok{"корова"}\NormalTok{,}\StringTok{"корова"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{stringdist}\NormalTok{(}\StringTok{"коровы"}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"курица"}\NormalTok{, }\StringTok{"бык"}\NormalTok{, }\StringTok{"утка"}\NormalTok{, }\StringTok{"корова"}\NormalTok{, }\StringTok{"осел"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 6 6 1 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{amatch}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"быки"}\NormalTok{, }\StringTok{"коровы"}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\StringTok{"курица"}\NormalTok{, }\StringTok{"бык"}\NormalTok{, }\StringTok{"утка"}\NormalTok{, }\StringTok{"корова"}\NormalTok{, }\StringTok{"осел"}\NormalTok{), }\DataTypeTok{maxDist =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 4
\end{verbatim}

\hypertarget{ux434ux43eux43fux43eux43bux43dux438ux442ux435ux43bux44cux43dux44bux435-ux437ux430ux434ux430ux43dux438ux44f}{%
\section{Дополнительные задания:}\label{ux434ux43eux43fux43eux43bux43dux438ux442ux435ux43bux44cux43dux44bux435-ux437ux430ux434ux430ux43dux438ux44f}}

\begin{rmdtask}
В
\href{https://github.com/agricolamz/2020-2021-ds4dh/raw/master/data/realdonaldtrump.csv}{датасет}
записаны твиты Донольда Трампа взятые с
\href{https://www.kaggle.com/austinreese/trump-tweets}{kaggle}.
Постройте график рассеяния, которые показывает связь количества ретвитов
и лайков. Чтобы убрать научную запись больших чисел используйте команду
\texttt{options(scipen\ =\ 999)}.
\end{rmdtask}

\includegraphics{DS_for_DH_files/figure-latex/trump-1.pdf}

\begin{rmdtask}
Постройте гистограмму, которая показывает распределения длины твитов в
символах. Какой метод определения размера ячейки использован на
приведенном графике? {[}Sturgers 1926{]}, {[}Scott 1979{]} или
{[}Freedman, Diaconis 1981{]}?
\end{rmdtask}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-371-1.pdf}

\begin{rmdtask}
Постройте график рассеивания, который бы показывал связь с длиной твита
во времени. Используя \texttt{geom\_hline()}, наложите две линии: 140
символов и 280. Сделайте прозрачность 0.1.
\end{rmdtask}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-373-1.pdf}

\begin{rmdtask}
Постройте график рассеивания, который бы показывал связь с длиной твита
во времени. Разбейте и раскрасьте твиты на основании наличия в них
интернет ссылок.
\end{rmdtask}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-375-1.pdf}

\begin{rmdtask}
Можно ли утверждать, что твиты со ссылками длиннее? Постройте
вайолинплот, которые показывает распределение значений длины твитов в
зависимости от наличия в них интернет ссылок.
\end{rmdtask}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-377-1.pdf}

\begin{rmdtask}
Найдите твиты которые содержат корень america, которые встречаются
больше одного раза, и фасетизируйте по таким словам.
\end{rmdtask}

\includegraphics{DS_for_DH_files/figure-latex/unnamed-chunk-379-1.pdf}

\hypertarget{data_presentation}{%
\chapter{\texorpdfstring{Представление данных: \texttt{rmarkdown}}{Представление данных: rmarkdown}}\label{data_presentation}}

Достаточно важной частью работы с данными является их представление. Мы рассмотрим наиболее распространенный варианты: \texttt{rmarkdown}, \texttt{flexdashboard} и \texttt{shiny}. Смотрите книжку \citep{xie19}(\url{https://bookdown.org/yihui/rmarkdown/}) или \href{https://rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf}{cheatsheet}.

\hypertarget{rmarkdown}{%
\section{\texorpdfstring{\texttt{rmarkdown}}{rmarkdown}}\label{rmarkdown}}

\texttt{rmarkdown} -- это пакет, который позволяет соединять R команды и их исполнения в один документ. В результате можно комбинировать текст и исполняемый код, что в свою очередь позволяет делать:
* докумунты в формате \texttt{.html}, \texttt{.pdf} (используя \LaTeX, мы почти не будем это обсуждать), \texttt{.docx}
* презентации в формате \texttt{.html}, \texttt{.pdf} (используя \LaTeX пакет \texttt{beamer}) \texttt{.pptx}-презентации
* набор связанных \texttt{.html} документов (полноценный сайт или книга)

\hypertarget{ux443ux441ux442ux430ux43dux43eux432ux43aux430}{%
\subsection{Установка}\label{ux443ux441ux442ux430ux43dux43eux432ux43aux430}}

Как и все пакеты \texttt{rmarkdown} можно установить из CRAN

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"rmarkdown"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{ux441ux43eux441ux442ux430ux432ux43bux44fux44eux449ux438ux435-rmarkdown-ux434ux43eux43aux443ux43cux435ux43dux442ux430}{%
\subsection{\texorpdfstring{Составляющие \texttt{rmarkdown}-документа}{Составляющие rmarkdown-документа}}\label{ux441ux43eux441ux442ux430ux432ux43bux44fux44eux449ux438ux435-rmarkdown-ux434ux43eux43aux443ux43cux435ux43dux442ux430}}

\begin{itemize}
\tightlist
\item
  \href{https://en.wikipedia.org/wiki/YAML}{yaml} шапка (факультативна)
\item
  обычный текст с \href{https://en.wikipedia.org/wiki/Markdown}{markdown} форматированием (расширенный при помощи \href{https://en.wikipedia.org/wiki/Pandoc}{Pandoc})
\item
  блоки кода (не обязательно на языке R), оформленные с двух сторон тройным бэктиком ``` (у меня на клавиатуре этот знак на букве ё).
\end{itemize}

\hypertarget{ux43fux440ux438ux43cux435ux440-rmarkdown-ux434ux43eux43aux443ux43cux435ux43dux442ux430}{%
\subsection{\texorpdfstring{Пример \texttt{rmarkdown}-документа}{Пример rmarkdown-документа}}\label{ux43fux440ux438ux43cux435ux440-rmarkdown-ux434ux43eux43aux443ux43cux435ux43dux442ux430}}

Создайте файл .Rmd в какой-нибудь папке (в RStudio, это можно сделать \texttt{File\ \textgreater{}\ New\ file\ \textgreater{}\ R\ Markdown}). Скомпелировать файл можно командой:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rmarkdown}\OperatorTok{::}\KeywordTok{render}\NormalTok{(}\StringTok{"ваш_файл.Rmd"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

или кнопкой \includegraphics{images/7.01_knit.png}. Вот пример кода:

\begin{verbatim}
---
output: html_document
---

## Данные
В документе можно вставлять R код

```{r}
summary(iris)
```

## График
И строить графики

```{r}
library(tidyverse)
iris %>% 
  ggplot(aes(Sepal.Length, Sepal.Width))+
  geom_point()
```
\end{verbatim}

\href{https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/rmd_examples/ex_01.html}{Результат}.

\begin{rmdtask}
Создайте и скомпелируйте свой \texttt{rmarkdown}-документ с заголовком,
текстом и кодом.
\end{rmdtask}

\hypertarget{markdown}{%
\subsection{\texorpdfstring{\texttt{Markdown}}{Markdown}}\label{markdown}}

Универсальны язык разметки, работает во многих современных он-лайн системах создания текста.

\hypertarget{ux437ux430ux433ux43eux43bux43eux432ux43aux438}{%
\subsubsection{Заголовки}\label{ux437ux430ux433ux43eux43bux43eux432ux43aux438}}

\begin{verbatim}
## Заголовок уровня 2
#### Заголовок уровня 4
\end{verbatim}

\hypertarget{ux444ux43eux440ux43cux430ux442ux438ux440ux43eux432ux430ux43dux438ux435}{%
\subsubsection{Форматирование}\label{ux444ux43eux440ux43cux430ux442ux438ux440ux43eux432ux430ux43dux438ux435}}

\begin{verbatim}
_италик_ или *другой италик*

__жирный__ или **другой жирный**

~~зачеркивание~~
\end{verbatim}

\emph{италик} или \emph{другой италик}

\textbf{жирный} или \textbf{другой жирный}

\sout{зачеркивание}

\hypertarget{ux441ux43fux438ux441ux43aux438}{%
\subsubsection{Списки}\label{ux441ux43fux438ux441ux43aux438}}

\begin{verbatim}
* кролик
* заяц
    * заяц серый

1. машины
    1. автобус
2. самолеты

+ можно еще ставить плюс
- и минус
\end{verbatim}

\begin{itemize}
\tightlist
\item
  кролик
\item
  заяц

  \begin{itemize}
  \tightlist
  \item
    заяц серый
  \end{itemize}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  машины

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    автобус
  \end{enumerate}
\item
  самолеты
\end{enumerate}

\begin{itemize}
\tightlist
\item
  можно еще ставить плюс
\item
  и минус
\end{itemize}

\hypertarget{ux441ux441ux44bux43bux43aux438-ux438-ux43aux430ux440ux442ux438ux43dux43aux438}{%
\subsubsection{Ссылки и картинки}\label{ux441ux441ux44bux43bux43aux438-ux438-ux43aux430ux440ux442ux438ux43dux43aux438}}

\begin{verbatim}
[Ссылка 1](https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html)

<https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html>

[Можно вставить ссылку потом, а пока отсавить метку][1]

Или даже просто голую [метку].

![](https://raw.githubusercontent.com/agricolamz/2018_ANDAN_course_winter/master/rmarkdown.png)

Опять же можно вставить только метку ![][2]

[1]: https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html
[метку]: https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html
[2]: https://raw.githubusercontent.com/agricolamz/2018_ANDAN_course_winter/master/rmarkdown.png
\end{verbatim}

\href{https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html}{Ссылка 1}

\url{https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html}

\href{https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html}{Можно вставить ссылку потом, а пока отсавить метку}

Или даже просто голую \href{https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html}{метку}.

\includegraphics{https://raw.githubusercontent.com/agricolamz/2018_ANDAN_course_winter/master/rmarkdown.png}

Опять же можно вставить только метку \includegraphics{https://raw.githubusercontent.com/agricolamz/2018_ANDAN_course_winter/master/rmarkdown.png}

\hypertarget{ux43aux43eux434}{%
\subsubsection{Код}\label{ux43aux43eux434}}

\begin{verbatim}
Код нужно оформалять вот так `rmarkdown::render()`
\end{verbatim}

Код нужно оформалять вот так \texttt{rmarkdown::render()}

\begin{verbatim}
```{python}
friends = ['john', 'pat', 'gary', 'michael']
for i, name in enumerate(friends):
    print "iteration {iteration} is {name}".format(iteration=i, name=name)
```
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{collection }\OperatorTok{=}\NormalTok{ [}\StringTok{'hey'}\NormalTok{, }\DecValTok{5}\NormalTok{, }\StringTok{'d'}\NormalTok{]}
\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ collection:}
    \BuiltInTok{print}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
hey
5
d
\end{verbatim}

Если хочется использовать результат работы кода в тексте, нужно в начале поставить язык, который будет исполнять код, например, в

Фигурные скобки не обязательны, но тогда RStudio подсветит.

\hypertarget{ux446ux438ux442ux430ux442ux44b}{%
\subsubsection{Цитаты}\label{ux446ux438ux442ux430ux442ux44b}}

\begin{verbatim}
> Цитаты нужно офрмлять так.
> Это попадет в тот же фрагмент.

> А вот тут произошел разрыв. Кстати, здесь тоже можно использовать *markdown*.
\end{verbatim}

\begin{quote}
Цитаты нужно офрмлять так.
Это попадет в тот же фрагмент.
\end{quote}

\begin{quote}
А вот тут произошел разрыв. Кстати, здесь тоже можно использовать \emph{markdown}.
\end{quote}

\hypertarget{ux440ux430ux437ux440ux44bux432-ux441ux442ux440ux430ux43dux438ux446ux44b}{%
\subsubsection{Разрыв страницы}\label{ux440ux430ux437ux440ux44bux432-ux441ux442ux440ux430ux43dux438ux446ux44b}}

\begin{verbatim}
***
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{html}{%
\subsubsection{HTML}\label{html}}

\begin{verbatim}
<dl>
  <dt>Чистый HTML</dt>
  <dd>Еще можно писать в HTML.</dd>

  <dt>и Markdown в  HTML </dt>
  <dd> даже работает **правильно**. Но можно использовать и <em>теги</em>.</dd>
</dl>
\end{verbatim}

Чистый HTML

Еще можно писать в HTML.

и Markdown в HTML

даже работает \textbf{правильно}. Но можно использовать и теги.

\hypertarget{ux442ux430ux431ux43bux438ux446ux44b}{%
\subsubsection{Таблицы}\label{ux442ux430ux431ux43bux438ux446ux44b}}

Еще есть целая наука как делать таблицы в Markdown, но я предпочитаю использовать \href{http://www.tablesgenerator.com/markdown_tables}{он-лайн генератор}.

\hypertarget{pandoc}{%
\subsection{\texorpdfstring{\texttt{Pandoc}}{Pandoc}}\label{pandoc}}

\href{https://pandoc.org/}{\texttt{Pandoc}} это программа, созданная \href{johnmacfarlane.net}{Дж. МакФарлэйном (J. MacFarlane)}, которая позволяет переходить из разных текстовых форматов в другие, а также смешивать их. Я покожу лишь несколько полезных расширений.

\hypertarget{ux432ux435ux440ux445ux43dux438ux435-ux438-ux43dux438ux436ux43dux438ux435-ux438ux43dux434ux435ux43aux441ux44b}{%
\subsubsection{Верхние и нижние индексы}\label{ux432ux435ux440ux445ux43dux438ux435-ux438-ux43dux438ux436ux43dux438ux435-ux438ux43dux434ux435ux43aux441ux44b}}

\begin{verbatim}
2^10^ C~n~^k^
\end{verbatim}

2\textsuperscript{10} C\textsubscript{n}\textsuperscript{k}

\hypertarget{ux43dux443ux43cux435ux440ux43eux432ux430ux43dux43dux44bux435-ux43fux440ux438ux43cux435ux440ux44b}{%
\subsubsection{Нумерованные примеры}\label{ux43dux443ux43cux435ux440ux43eux432ux430ux43dux43dux44bux435-ux43fux440ux438ux43cux435ux440ux44b}}

\begin{verbatim}
(@) Славный пример номер раз.
(@) Славный пример номер два.
(@three) Славный пример номер три, у которого есть *имя*.

Я могу сослаться на пример (@three)!
\end{verbatim}

\begin{enumerate}
\def\labelenumi{(\arabic{enumi})}
\tightlist
\item
  Славный пример номер раз.
\item
  Славный пример номер два.
\item
  Славный пример номер три, у которого есть \emph{имя}.
\end{enumerate}

Я могу сослаться на пример (3)!

\hypertarget{ux441ux43dux43eux441ux43aux438}{%
\subsubsection{Сноски}\label{ux441ux43dux43eux441ux43aux438}}

\begin{verbatim}
Вот и сноска[^1]

[^1]: Сноска, сноска, сноска.
\end{verbatim}

Вот и сноска\footnote{Сноска, сноска, сноска.}

\hypertarget{ux43cux430ux442ux435ux43cux430ux442ux438ux43aux430-latex}{%
\subsubsection{\texorpdfstring{Математика: \(\LaTeX\)}{Математика: \textbackslash LaTeX}}\label{ux43cux430ux442ux435ux43cux430ux442ux438ux43aux430-latex}}

\begin{verbatim}
$\LaTeX$  код может быть в тексте $\frac{\pi}{\sum{n+1}}$ или отдельной строчкой:

$$\frac{\pi}{\sum{n+1}}$$
\end{verbatim}

\(\LaTeX\) код может быть в тексте \(\frac{\pi}{\sum{n+1}}\) или отдельной строчкой:

\[\frac{\pi}{\sum{n+1}}\]

\hypertarget{code-chunks}{%
\subsection{Code chunks}\label{code-chunks}}

Фрагменты кода имеют свои наборы свойств, который можно записывать в фигурных скобках.

\hypertarget{ux44fux437ux44bux43a-ux43fux440ux43eux433ux440ux430ux43cux43cux438ux440ux43eux432ux430ux43dux438ux44f}{%
\subsubsection{Язык программирования}\label{ux44fux437ux44bux43a-ux43fux440ux43eux433ux440ux430ux43cux43cux438ux440ux43eux432ux430ux43dux438ux44f}}

\begin{verbatim}
```{r}
summary(cars)
```

```{python}
x = "my string"
print(x.split(" "))
```
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(cars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     speed           dist       
 Min.   : 4.0   Min.   :  2.00  
 1st Qu.:12.0   1st Qu.: 26.00  
 Median :15.0   Median : 36.00  
 Mean   :15.4   Mean   : 42.98  
 3rd Qu.:19.0   3rd Qu.: 56.00  
 Max.   :25.0   Max.   :120.00  
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \StringTok{"my string"}
\BuiltInTok{print}\NormalTok{(x.split(}\StringTok{" "}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
['my', 'string']
\end{verbatim}

\hypertarget{ux43fux43eux44fux432ux43bux435ux43dux438ux435-ux438-ux438ux441ux43fux43eux43bux43dux435ux43dux438ux435-ux43aux43eux434ux430}{%
\subsubsection{Появление и исполнение кода}\label{ux43fux43eux44fux432ux43bux435ux43dux438ux435-ux438-ux438ux441ux43fux43eux43bux43dux435ux43dux438ux435-ux43aux43eux434ux430}}

\begin{verbatim}
И код, и результат
```{r}
plot(mtcars$mpg)
```

Только результат
```{r, echo = FALSE}
plot(mtcars$mpg)
```

Только код
```{r, eval = FALSE}
plot(mtcars$mpg)
```

Исполняется, но не показывается ни код, ни результат
```{r, include = FALSE}
a <- mtcars$mpg
```

Обратимся к переменной, созданной в фрагменте с аргументом `include = FALSE`
```{r}
a
```
\end{verbatim}

\hypertarget{ux434ux440ux443ux433ux438ux435-ux43fux43eux43bux435ux437ux43dux44bux435-ux430ux440ux433ux443ux43cux435ux43dux442ux44b}{%
\subsubsection{Другие полезные аргументы}\label{ux434ux440ux443ux433ux438ux435-ux43fux43eux43bux435ux437ux43dux44bux435-ux430ux440ux433ux443ux43cux435ux43dux442ux44b}}

Существует достаточно \href{https://yihui.name/knitr/options/\#chunk_options}{много аргументов}, которые можно перечислить в фигурных скобках в фрагменте кода, вот некоторые из них:

\begin{itemize}
\tightlist
\item
  \texttt{error}: показывать ли ошибки.
\item
  \texttt{warning}: показывать ли предупреждения.
\item
  \texttt{message}: показывать ли сообщения (например, при подключении пакетов).
\item
  \texttt{comment}: по умолчанию, результат работы кода предваряется знаком \texttt{\#\#}, используйте \texttt{NA}, чтобы их не было, или любую другую строку.
\item
  \texttt{cache}: сохранить ли результат работы фрагмента кода. Очень полезно, если происходят какие-то операции, занимающая много времени. Сохранив результат, не нужно будет тратить время, на пересчет, при каждой новой компиляции.
\item
  \texttt{fig.width}, \texttt{fig.height} (по умолчанию, 7)
\end{itemize}

Все эти аргументы можно перечислить в функции \texttt{knitr::opts\_chunk\$set(...)}:

\hypertarget{pets-or-livestock}{%
\subsubsection{Pets or livestock?}\label{pets-or-livestock}}

В RMarkdown каждому фрагменту кода можно дать имя (но избегайте пробелов и точек):

\begin{verbatim}
```{r my_beautiful_graph, eval = FALSE}
library(tidyverse)
diamonds %>% 
  count(carat, color) %>%
  ggplot(aes(carat, n, color = color))+
  geom_point()
```
\end{verbatim}

Maëlle Salmon написал \href{http://www.masalmon.eu/2017/08/08/chunkpets/}{отличный пост}, почему полезно именовать фрагменты кода:

\begin{itemize}
\tightlist
\item
  проще ориентироваться
\item
  код более читаемый
\item
  ошибки при компеляции показывают имя, а не номер
\item
  если фрагмент кэшировался, то добавление одного фрагменты перед ним, не заставит все пересчитываться
\item
  в \texttt{blogdown} можно ссылаться
\end{itemize}

\hypertarget{yaml-ux448ux430ux43fux43aux430}{%
\subsection{YAML шапка}\label{yaml-ux448ux430ux43fux43aux430}}

Факультативная YAML шапка обычно содержит метаданные документа, и аргументы, необходимые для работы некоторых дополнений.

\begin{verbatim}
---
title: "Мой RMarkdown"
author: Славный Автор
date: 20 ноября 2019
---
\end{verbatim}

\hypertarget{ux442ux438ux43f-ux43fux43eux43bux443ux447ux438ux432ux448ux435ux433ux43eux441ux44f-ux444ux430ux439ux43bux430}{%
\subsubsection{Тип получившегося файла}\label{ux442ux438ux43f-ux43fux43eux43bux443ux447ux438ux432ux448ux435ux433ux43eux441ux44f-ux444ux430ux439ux43bux430}}

\begin{itemize}
\tightlist
\item
  \texttt{output:\ html\_document} (по умолчанию)
\item
  \texttt{output:\ word\_document}
\item
  \texttt{output:\ pdf\_document} (но нужно договориться с \(\LaTeX\)ом на вашем компьютере)
\item
  \texttt{output:\ ioslides\_presentation}
\item
  \texttt{output:\ slidy\_presentation}
\item
  \texttt{output:\ slidy\_presentation}
\item
  \texttt{output:\ beamer\_presentation}
\end{itemize}

и др.

\hypertarget{ux431ux438ux431ux43bux438ux43eux433ux440ux430ux444ux438ux44f}{%
\subsubsection{Библиография}\label{ux431ux438ux431ux43bux438ux43eux433ux440ux430ux444ux438ux44f}}

Существует \href{http://rmarkdown.rstudio.com/authoring_pandoc_markdown.html\#citations}{несколько сопособов} вставлять библиографию в RMarkdown. Я раскажу, как использовать пакет \texttt{Bibtex} (как видно из названия, сделанный для \(\LaTeX\)). Для начала нужно создать файл с раширением .bib, в который записать все источники, которые будут использоваться (библиографию в формате \texttt{BibTeX} выдает, например, \href{https://scholar.google.ru}{GoogleScholar}):

\begin{verbatim}
@book{ladefoged96,
  title={The sounds of the world's languages},
  author={Ladefoged, P. and Maddieson, I.},
  year={1996},
  publisher={Oxford Publishers}
}

@article{gordon02,
  title={A cross-linguistic acoustic study of voiceless fricatives},
  author={Gordon, M. and Barthmaier, P. and Sands, K.},
  journal={Journal of the International Phonetic Association},
  volume={32},
  number={2},
  pages={141--174},
  year={2002},
  publisher={Cambridge University Press}
}
\end{verbatim}

На следующем шаге нужно добавить название файла с раширением .bib в YAML шапку:

\begin{verbatim}
---
bibliography: bibliography.bib
---
\end{verbatim}

После этого, можно использовать сслыки в тексте

\begin{verbatim}
В своей работе @gordon02 раскрыл...
\end{verbatim}

В своей работе \citet{gordon02} раскрыл\ldots{}

\begin{verbatim}
Об этом можно узнать из [@ladefoged96; @gordon02], но ...
\end{verbatim}

Об этом можно узнать из \citep{ladefoged96, gordon02}, но \ldots{}

\begin{verbatim}
В своей работе [@gordon02] раскрыл...
\end{verbatim}

В своей работе \citep{gordon02} раскрыл\ldots{}

\begin{verbatim}
Об этом можно узнать из [см. @gordon02, с. 33--35; а также @ladefoged96, гл. 1]...
\end{verbatim}

Об этом можно узнать из \citetext{\citealp[см.][с. 33--35]{gordon02}; \citealp[а также][гл. 1]{ladefoged96}}\ldots{}

Список литературы автоматически появляется в конце.

\hypertarget{ux43eux433ux43bux430ux432ux43bux435ux43dux438ux435-ux438-ux43fux440.}{%
\subsubsection{Оглавление и пр.}\label{ux43eux433ux43bux430ux432ux43bux435ux43dux438ux435-ux438-ux43fux440.}}

Существует сразу несколько аргументов, отвечающих за оглавление.

\begin{itemize}
\tightlist
\item
  \texttt{toc} вставлять ли оглавление
\item
  \texttt{toc\_depth} глубина иерархии, которую отражать в огловлении
\item
  \texttt{toc\_float} должно ли оглавление все время следовать за текстом
\item
  \texttt{collapsed} должно ли оглавление быть все время полностью раскрыто
\item
  \texttt{collapsed} должно ли оглавление быть все время полностью раскрыто
\item
  \texttt{number\_sections} автоматическая нумерация секций
\item
  \texttt{code\_folding} (hide) --- делать ли кнопочку, показывающую/скрывающую весь код
\item
  \texttt{theme} одна из \href{https://bootswatch.com/}{Bootstrap тем}
\item
  \texttt{highlight}: ``default'', ``tango'', ``pygments'', ``kate'', ``monochrome'', ``espresso'', ``zenburn'', ``haddock'' или ``textmate''
\end{itemize}

\begin{verbatim}
---
html_document:
    theme: spacelab
    highlight: pygments
    toc: yes
    toc_position: right
    toc_depth: 3
    toc_float: yes
    smooth_scroll: false
---
\end{verbatim}

\hypertarget{ux43eux442ux43eux431ux440ux430ux436ux435ux43dux438ux435-ux434ux430ux442ux430ux444ux440ux435ux439ux43cux43eux432}{%
\subsubsection{Отображение датафреймов}\label{ux43eux442ux43eux431ux440ux430ux436ux435ux43dux438ux435-ux434ux430ux442ux430ux444ux440ux435ux439ux43cux43eux432}}

\begin{itemize}
\tightlist
\item
  \texttt{df\_print:\ default}
\item
  \texttt{df\_print:\ kable}
\item
  \texttt{df\_print:\ tibble}
\item
  \texttt{df\_print:\ paged}
\end{itemize}

\begin{verbatim}
---
output:
  html_document:
    df_print: paged
---
\end{verbatim}

\hypertarget{ux433ux434ux435-ux445ux43eux441ux442ux438ux442ux44c-.html}{%
\subsection{\texorpdfstring{Где хостить \texttt{.html}?}{Где хостить .html?}}\label{ux433ux434ux435-ux445ux43eux441ux442ux438ux442ux44c-.html}}

Полученные \texttt{.html} можно разместить в интернете:

\begin{itemize}
\item
  на каком-то вашем хосте
\item
  опубликовать на бесплатном хостинке Rpubs
\end{itemize}

\includegraphics{images/7.02_publish_rpubs.png}

\begin{itemize}
\tightlist
\item
  опубликовать на гитхабе и включить Github Pages
\end{itemize}

\begin{rmdtask}
Теперь создайте документ index.Rmd, в котором напишите код на R и на
Python, вставьте картинку, сноску, ссылку на литературу, таблицу и
оглавление. Скомпелируйте \texttt{.html} документ и опубликуйте его на
Github, пройдя \href{https://classroom.github.com/a/ypZeK32c}{по этой
ссылке}. Cделайте Github Pages и заполните \texttt{README.md} файл.
\end{rmdtask}

\hypertarget{ux431ux44bux432ux430ux44eux442-ux438-ux434ux440ux443ux433ux438ux435-ux441ux43fux43eux441ux43eux431ux44b-ux43fux440ux435ux434ux441ux442ux430ux432ux43bux435ux43dux438ux44f-ux434ux430ux43dux43dux44bux445}{%
\section{Бывают и другие способы представления данных}\label{ux431ux44bux432ux430ux44eux442-ux438-ux434ux440ux443ux433ux438ux435-ux441ux43fux43eux441ux43eux431ux44b-ux43fux440ux435ux434ux441ux442ux430ux432ux43bux435ux43dux438ux44f-ux434ux430ux43dux43dux44bux445}}

\begin{itemize}
\tightlist
\item
  \href{https://rmarkdown.rstudio.com/flexdashboard/examples.html}{\texttt{flexdashboard}} -- динамические дэшборды
\item
  \href{https://shiny.rstudio.com/gallery/}{\texttt{shiny}} -- динамические сайты, которые позволяют взаимодействовать с пользователем
\item
  \href{https://brentthorne.github.io/posterdown_html_showcase/}{\texttt{posterdown}} -- постеры в RMarkdown
\item
  \href{https://pagedown.rbind.io/}{\texttt{pagedown}} -- содержит много шаблонов: для книги, статьи, постера, резюме, визитки\ldots{} да хоть приглашение на свадьбу можно сделать.
\end{itemize}

\hypertarget{tasks}{%
\chapter{Задания}\label{tasks}}

\#\#Начало работы в R \{\#task\_begin\}

\begin{itemize}
\tightlist
\item
  Разделите 9801 на 9.
\end{itemize}

\begin{verbatim}
[1] 1089
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте логарифм от 8912162342 по основанию 6.
\end{itemize}

\begin{verbatim}
[1] 12
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь натуральный логарифм 10 и умножьте его на 5.
\end{itemize}

\begin{verbatim}
[1] 11.51293
\end{verbatim}

\begin{itemize}
\tightlist
\item
  С помощью функции \texttt{sin()} посчитайте \(\sin (\pi), \sin \left(\frac{\pi}{2}\right), \sin \left(\frac{\pi}{6}\right)\).
\end{itemize}

\begin{quote}
Значение \(\pi\) - зашитая в R константа (\texttt{pi}).
\end{quote}

\begin{verbatim}
[1] 1.224647e-16
\end{verbatim}

\begin{verbatim}
[1] 1
\end{verbatim}

\begin{verbatim}
[1] 0.5
\end{verbatim}

\#\#Создание векторов \{\#task\_new\_vecs\}

\begin{itemize}
\tightlist
\item
  Создайте вектор из значений 2, 30 и 4000.
\end{itemize}

\begin{verbatim}
[1]    2   30 4000
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 1 до 20.
\end{itemize}

\begin{verbatim}
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 20 до 1.
\end{itemize}

\begin{verbatim}
 [1] 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1
\end{verbatim}

Функция \texttt{sum()} возвращает сумму элементов вектора на входе. Посчитайте сумму первых 100 натуральных чисел (т.е. всех целых чисел от 1 до 100).

\begin{verbatim}
[1] 5050
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз!
\end{itemize}

\begin{verbatim}
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15
[26] 14 13 12 11 10  9  8  7  6  5  4  3  2  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор значений 5, 4, 3, 2, 2, 3, 4, 5:
\end{itemize}

\begin{verbatim}
[1] 5 4 3 2 2 3 4 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 2, 4, 6, \ldots{} , 18, 20.
\end{itemize}

\begin{verbatim}
 [1]  2  4  6  8 10 12 14 16 18 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 0.1, 0.2, 0.3, \ldots, 0.9, 1.
\end{itemize}

\begin{verbatim}
 [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
\end{verbatim}

\begin{itemize}
\tightlist
\item
  2020 год --- високосный. Следующий високосный год через 4 года --- это будет 2024 год. Составьте календарь всех високосных годов XXI века, начиная с 2020 года.
\end{itemize}

\begin{quote}
2100 год относится к XXI веку, а не к XXII.
\end{quote}

\begin{verbatim}
 [1] 2020 2024 2028 2032 2036 2040 2044 2048 2052 2056 2060 2064 2068 2072 2076
[16] 2080 2084 2088 2092 2096 2100
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор, состоящий из 20 повторений ``Хэй!''.
\end{itemize}

\begin{verbatim}
 [1] "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!"
[11] "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Как я и говорил, многие функции, работающие с одним значением на входе, так же прекрасно работают и с целыми векторами. Попробуйте посчитать квадратный корень чисел от 1 до 10 с помощью функции \texttt{sqrt()} и сохраните результат в векторе \texttt{roots}.
\end{itemize}

\begin{verbatim}
 [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
 [9] 3.000000 3.162278
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Давайте убедимся, что это действительно квадратные корни. Для этого возведите все значения вектора \texttt{roots} в квадрат!
\end{itemize}

\begin{verbatim}
 [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Если все верно, то того же самого можно добиться поэлементным умножением вектора \texttt{roots} на себя.
\end{itemize}

\begin{verbatim}
 [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте вектор из одной единицы, двух двоек, трех троек, \ldots. , девяти девяток.
\end{itemize}

\begin{verbatim}
 [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 9 9
[39] 9 9 9 9 9 9 9
\end{verbatim}

\hypertarget{task_coer}{%
\section{Приведение типов}\label{task_coer}}

\begin{itemize}
\tightlist
\item
  Сделайте вектор \texttt{vec1}, в котором соедините \texttt{3}, а также значения \texttt{"Мой"} и \texttt{"вектор"}.
\end{itemize}

\begin{verbatim}
[1] "3"      "Мой"    "вектор"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Попробуйте вычесть \texttt{TRUE} из 10.
\end{itemize}

\begin{verbatim}
[1] 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините значение \texttt{10} и \texttt{TRUE} в вектор \texttt{vec2}.
\end{itemize}

\begin{verbatim}
[1] 10  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините вектор \texttt{vec2} и значение \texttt{"r"}:
\end{itemize}

\begin{verbatim}
[1] "10" "1"  "r" 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините значения \texttt{10}, \texttt{TRUE}, \texttt{"r"} в вектор.
\end{itemize}

\begin{verbatim}
[1] "10"   "TRUE" "r"   
\end{verbatim}

\hypertarget{task_vec_ion}{%
\section{Векторизация}\label{task_vec_ion}}

\begin{itemize}
\tightlist
\item
  Создайте вектор \texttt{p}, состоящий из значений 4, 5, 6, 7, и вектор \texttt{q}, состоящий из 0, 1, 2, 3.
\end{itemize}

\begin{verbatim}
[1] 4 5 6 7
\end{verbatim}

\begin{verbatim}
[1] 0 1 2 3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте поэлементную сумму векторов \texttt{p} и \texttt{q}:
\end{itemize}

\begin{verbatim}
[1]  4  6  8 10
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте поэлементную разницу \texttt{p} и \texttt{q}:
\end{itemize}

\begin{verbatim}
[1] 4 4 4 4
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поделите каждый элемент вектора \texttt{p} на соответствующий ему элемент вектора \texttt{q}:
\end{itemize}

\begin{quote}
О, да, Вам нужно делить на 0!
\end{quote}

\begin{verbatim}
[1]      Inf 5.000000 3.000000 2.333333
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Возведите каждый элемент вектора \texttt{p} в степень соответствующего ему элемента вектора \texttt{q}:
\end{itemize}

\begin{verbatim}
[1]   1   5  36 343
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Умножьте каждое значение вектора \texttt{p} на 10.
\end{itemize}

\begin{verbatim}
[1] 40 50 60 70
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор квадратов чисел от 1 до 10:
\end{itemize}

\begin{verbatim}
 [1]   1   4   9  16  25  36  49  64  81 100
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 0, 2, 0, 4, \ldots{} , 18, 0, 20.
\end{itemize}

\begin{verbatim}
 [1]  0  2  0  4  0  6  0  8  0 10  0 12  0 14  0 16  0 18  0 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 1, 0, 3, 0, 5, \ldots, 17, 0, 19, 0.
\end{itemize}

\begin{verbatim}
 [1]  1  0  3  0  5  0  7  0  9  0 11  0 13  0 15  0 17  0 19  0
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте вектор, в котором будут содержаться первые 20 степеней двойки.
\end{itemize}

\begin{verbatim}
 [1]       2       4       8      16      32      64     128     256     512
[10]    1024    2048    4096    8192   16384   32768   65536  131072  262144
[19]  524288 1048576
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте вектор из чисел 1, 10, 100, 1000, 10000:
\end{itemize}

\begin{verbatim}
[1]     1    10   100  1000 10000
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Посчитать сумму последовательности \(\frac{1}{1 \cdot 2}+\frac{1}{2 \cdot 3}+\frac{1}{3 \cdot 4}+\ldots+\frac{1}{50 \cdot 51}\).
\end{itemize}

\begin{verbatim}
[1] 0.9803922
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Посчитать сумму последовательности \(\frac{1}{2^{0}}+\frac{1}{2^{1}}+\frac{1}{2^{2}}+\frac{1}{2^{3}}+\ldots \frac{1}{2^{20}}\).
\end{itemize}

\begin{verbatim}
[1] 1.999999
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Посчитать сумму последовательности \(1+\frac{4}{3}+\frac{7}{9}+\frac{10}{27}+\frac{13}{81}+\ldots+\frac{28}{19683}\).
\end{itemize}

\begin{verbatim}
[1] 3.749174
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Сколько чисел из последовательности \(1+\frac{4}{3}+\frac{7}{9}+\frac{10}{27}+\frac{13}{81}+\ldots+\frac{28}{19683}\) больше чем 0.5?
\end{itemize}

\begin{verbatim}
[1] 3
\end{verbatim}

\hypertarget{task_vec_ind}{%
\section{Индексирование векторов}\label{task_vec_ind}}

\begin{itemize}
\tightlist
\item
  Создайте вектор \texttt{troiki} со значениями 3, 6, 9, \ldots, 24, 27.
\end{itemize}

\begin{verbatim}
[1]  3  6  9 12 15 18 21 24 27
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките 2, 5 и 7 значения вектора \texttt{troiki}.
\end{itemize}

\begin{verbatim}
[1]  6 15 21
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките предпоследнее значение вектора \texttt{troiki}.
\end{itemize}

\begin{verbatim}
[1] 24
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките все значения вектора \texttt{troiki} \emph{кроме} предпоследнего:
\end{itemize}

\begin{verbatim}
[1]  3  6  9 12 15 18 21 27
\end{verbatim}

Создайте вектор \texttt{vec3}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Найдите второй элемент вектора \texttt{vec3}.
\end{itemize}

\begin{verbatim}
[1] 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Верните второй и пятый элемент вектора \texttt{vec3}.
\end{itemize}

\begin{verbatim}
[1] 5 8
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Попробуйте извлечь сотое значение вектора \texttt{vec3}:
\end{itemize}

\begin{verbatim}
[1] NA
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Верните все элементы вектора \texttt{vec3} \emph{кроме} второго элемента.
\end{itemize}

\begin{verbatim}
 [1]  3  2  1  8  4  9 10  3 15  1 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Верните все элементы вектора \texttt{vec3} \emph{кроме} второго и пятого элемента.
\end{itemize}

\begin{verbatim}
 [1]  3  2  1  4  9 10  3 15  1 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите последний элемент вектора \texttt{vec3}.
\end{itemize}

\begin{verbatim}
[1] 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Верните все значения вектора \texttt{vec3} кроме первого и последнего.
\end{itemize}

\begin{verbatim}
 [1]  5  2  1  8  4  9 10  3 15  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все значения вектора \texttt{vec3}, которые больше 4.
\end{itemize}

\begin{verbatim}
[1]  5  8  9 10 15 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все значения вектора \texttt{vec3}, которые больше 4, но меньше 10.
\end{itemize}

\begin{quote}
Если хотите сделать это в одну строчку, то вам помогут логические операторы!
\end{quote}

\begin{verbatim}
[1] 5 8 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все значения вектора \texttt{vec3}, которые меньше 4 или больше 10.
\end{itemize}

\begin{verbatim}
[1]  3  2  1  3 15  1 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Возведите в квадрат каждое значение вектора \texttt{vec3}.
\end{itemize}

\begin{verbatim}
 [1]   9  25   4   1  64  16  81 100   9 225   1 121
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Возведите в квадрат каждое значение вектора на нечетной позиции и извлеките корень из каждого значения на четной позиции вектора \texttt{vec3}.
\end{itemize}

\begin{quote}
Извлечение корня - это то же самое, что и возведение в степень 0.5.
\end{quote}

\begin{verbatim}
 [1]  9.000000  2.236068  4.000000  1.000000 64.000000  2.000000 81.000000
 [8]  3.162278  9.000000  3.872983  1.000000  3.316625
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 2, 4, 6, \ldots{} , 18, 20 как минимум 2 новыми способами.
\end{itemize}

\begin{quote}
Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше!
\end{quote}

\begin{verbatim}
 [1]  2  4  6  8 10 12 14 16 18 20
\end{verbatim}

\#\#Работа с пропущенными значениями \{\#task\_na\}

\begin{itemize}
\tightlist
\item
  Создайте вектор \texttt{vec4} со значениями 300, 15, 8, 2, 0, 1, 110:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec4 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{300}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{110}\NormalTok{)}
\NormalTok{vec4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 300  15   8  20   0   1 110
\end{verbatim}

\begin{itemize}
\item
  Замените все значения \texttt{vec4}, которые больше 20 на \texttt{NA}.
\item
  Проверьте полученный вектор \texttt{vec4}:
\end{itemize}

\begin{verbatim}
[1] NA 15  8 20  0  1 NA
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте сумму \texttt{vec4} с помощью функции \texttt{sum()}. Ответ \texttt{NA} не считается!
\end{itemize}

\begin{verbatim}
[1] 44
\end{verbatim}

\hypertarget{task_matrix}{%
\section{Матрицы}\label{task_matrix}}

\begin{itemize}
\tightlist
\item
  Создайте матрицу 4х4, состоящую из единиц. Назовите ее \texttt{M1}.
\end{itemize}

\begin{verbatim}
     [,1] [,2] [,3] [,4]
[1,]    1    1    1    1
[2,]    1    1    1    1
[3,]    1    1    1    1
[4,]    1    1    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поменяйте все некрайние значения матрицы \texttt{M1} (то есть значения на позициях {[}2,2{]}, {[}2,3{]}, {[}3,2{]} и {[}3,3{]}) на число 2.
\end{itemize}

\begin{verbatim}
     [,1] [,2] [,3] [,4]
[1,]    1    1    1    1
[2,]    1    2    2    1
[3,]    1    2    2    1
[4,]    1    1    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выделите второй и третий столбик из матрицы \texttt{M1}.
\end{itemize}

\begin{verbatim}
     [,1] [,2]
[1,]    1    1
[2,]    2    2
[3,]    2    2
[4,]    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сравните (\texttt{==}) вторую колонку и вторую строчку матрицы \texttt{M1}.
\end{itemize}

\begin{verbatim}
[1] TRUE TRUE TRUE TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную \texttt{mult\_tab}.
\end{itemize}

\begin{verbatim}
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
 [1,]    1    2    3    4    5    6    7    8    9
 [2,]    2    4    6    8   10   12   14   16   18
 [3,]    3    6    9   12   15   18   21   24   27
 [4,]    4    8   12   16   20   24   28   32   36
 [5,]    5   10   15   20   25   30   35   40   45
 [6,]    6   12   18   24   30   36   42   48   54
 [7,]    7   14   21   28   35   42   49   56   63
 [8,]    8   16   24   32   40   48   56   64   72
 [9,]    9   18   27   36   45   54   63   72   81
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Из матрицы \texttt{mult\_tab} выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7.
\end{itemize}

\begin{verbatim}
     [,1] [,2] [,3] [,4] [,5]
[1,]   18   24   30   36   42
[2,]   21   28   35   42   49
[3,]   24   32   40   48   56
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте матрицу с логическими значениями, где \texttt{TRUE}, если в этом месте в таблице умножения (\texttt{mult\_tab}) двузначное число и \texttt{FALSE}, если однозначное.
\end{itemize}

\begin{quote}
Матрица - это почти вектор. К нему можно обращаться с единственным индексом.
\end{quote}

\begin{verbatim}
       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]
 [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [2,] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
 [3,] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [4,] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [5,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [6,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [7,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [8,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [9,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте матрицу \texttt{mult\_tab2}, в которой все значения \texttt{tab} меньше 10 заменены на 0.
\end{itemize}

\begin{verbatim}
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
 [1,]    0    0    0    0    0    0    0    0    0
 [2,]    0    0    0    0   10   12   14   16   18
 [3,]    0    0    0   12   15   18   21   24   27
 [4,]    0    0   12   16   20   24   28   32   36
 [5,]    0   10   15   20   25   30   35   40   45
 [6,]    0   12   18   24   30   36   42   48   54
 [7,]    0   14   21   28   35   42   49   56   63
 [8,]    0   16   24   32   40   48   56   64   72
 [9,]    0   18   27   36   45   54   63   72   81
\end{verbatim}

\hypertarget{task_list}{%
\section{Списки}\label{task_list}}

Дан список \texttt{list1}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1 =}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{numbers =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{letters =}\NormalTok{ letters, }\DataTypeTok{logic =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{list1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
$numbers
[1] 1 2 3 4 5

$letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"

$logic
[1] TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите первый элемент списка \texttt{list1}. Ответ должен быть списком длиной один.
\end{itemize}

\begin{verbatim}
$numbers
[1] 1 2 3 4 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь найдите содержание первого элемента списка \texttt{list1} двумя разными способами. Ответ должен быть вектором.
\end{itemize}

\begin{verbatim}
[1] 1 2 3 4 5
\end{verbatim}

\begin{verbatim}
[1] 1 2 3 4 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь возьмите первый элемент содержания первого элемента списка \texttt{list1}. Ответ должен быть вектором.
\end{itemize}

\begin{verbatim}
[1] 1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте список \texttt{list2}, содержащий в себе два списка \texttt{list1}. Один из них будет иметь имя \texttt{pupa}, а другой --- \texttt{lupa}.
\end{itemize}

\begin{verbatim}
$pupa
$pupa$numbers
[1] 1 2 3 4 5

$pupa$letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"

$pupa$logic
[1] TRUE


$lupa
$lupa$numbers
[1] 1 2 3 4 5

$lupa$letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"

$lupa$logic
[1] TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Извлеките первый элемент списка \texttt{list2}, из него --- второй полэлемент, а из него --- третье значение.
\end{itemize}

\begin{verbatim}
[1] "c"
\end{verbatim}

\hypertarget{task_df}{%
\section{Датафрейм}\label{task_df}}

\begin{itemize}
\tightlist
\item
  Запустите команду \texttt{data(mtcars)} чтобы загрузить встроенный датафрейм с информацией про автомобили. Каждая строчка датафрейма - модель автомобиля, каждая колонка - отдельная характеристика. Подробнее см. \texttt{?mtcars}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(mtcars)}
\NormalTok{mtcars}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Изучите структуру датафрейма \texttt{mtcars} с помощью функции \texttt{str()}.
\end{itemize}

\begin{verbatim}
'data.frame':   32 obs. of  11 variables:
 $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
 $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
 $ disp: num  160 160 108 258 360 ...
 $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
 $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
 $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
 $ qsec: num  16.5 17 18.6 19.4 17 ...
 $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
 $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
 $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
 $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите значение третьей строчки четвертого столбца датафрейма \texttt{mtcars}.
\end{itemize}

\begin{verbatim}
[1] 93
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките первые шесть строчек и первые шесть столбцов датафрейма \texttt{mtcars}.
\end{itemize}

\begin{verbatim}
                   mpg cyl disp  hp drat    wt
Mazda RX4         21.0   6  160 110 3.90 2.620
Mazda RX4 Wag     21.0   6  160 110 3.90 2.875
Datsun 710        22.8   4  108  93 3.85 2.320
Hornet 4 Drive    21.4   6  258 110 3.08 3.215
Hornet Sportabout 18.7   8  360 175 3.15 3.440
Valiant           18.1   6  225 105 2.76 3.460
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките колонку \texttt{wt} датафрейма \texttt{mtcars} - массу автомобиля в тысячах фунтов.
\end{itemize}

\begin{verbatim}
 [1] 2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070
[13] 3.730 3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840
[25] 3.845 1.935 2.140 1.513 3.170 2.770 3.570 2.780
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките колонки из \texttt{mtcars} в следующем порядке: \texttt{hp}, \texttt{mpg}, \texttt{cyl}.
\end{itemize}

\begin{verbatim}
                     hp  mpg cyl
Mazda RX4           110 21.0   6
Mazda RX4 Wag       110 21.0   6
Datsun 710           93 22.8   4
Hornet 4 Drive      110 21.4   6
Hornet Sportabout   175 18.7   8
Valiant             105 18.1   6
Duster 360          245 14.3   8
Merc 240D            62 24.4   4
Merc 230             95 22.8   4
Merc 280            123 19.2   6
Merc 280C           123 17.8   6
Merc 450SE          180 16.4   8
Merc 450SL          180 17.3   8
Merc 450SLC         180 15.2   8
Cadillac Fleetwood  205 10.4   8
Lincoln Continental 215 10.4   8
Chrysler Imperial   230 14.7   8
Fiat 128             66 32.4   4
Honda Civic          52 30.4   4
Toyota Corolla       65 33.9   4
Toyota Corona        97 21.5   4
Dodge Challenger    150 15.5   8
AMC Javelin         150 15.2   8
Camaro Z28          245 13.3   8
Pontiac Firebird    175 19.2   8
Fiat X1-9            66 27.3   4
Porsche 914-2        91 26.0   4
Lotus Europa        113 30.4   4
Ford Pantera L      264 15.8   8
Ferrari Dino        175 19.7   6
Maserati Bora       335 15.0   8
Volvo 142E          109 21.4   4
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте \emph{количество} автомобилей с 4 цилиндрами (\texttt{cyl}) в датафрейме \texttt{mtcars}.
\end{itemize}

\begin{verbatim}
[1] 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте \emph{долю} автомобилей с 4 цилиндрами (\texttt{cyl}) в датафрейме \texttt{mtcars}.
\end{itemize}

\begin{verbatim}
[1] 0.34375
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все автомобили мощностью не менее 100 лошадиных сил (\texttt{hp}) в датафрейме \texttt{mtcars}.
\end{itemize}

\begin{verbatim}
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все автомобили мощностью не менее 100 лошадиных сил (\texttt{hp}) и 4 цилиндрами (\texttt{cyl}) в датафрейме \texttt{mtcars}.
\end{itemize}

\begin{verbatim}
              mpg cyl  disp  hp drat    wt qsec vs am gear carb
Lotus Europa 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2
Volvo 142E   21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте максимальную массу (\texttt{wt}) автомобиля в выборке, воспользовавшись функцией \texttt{max()}:
\end{itemize}

\begin{verbatim}
[1] 5.424
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте максимальную массу (\texttt{wt}) автомобиля в выборке, воспользовавшись функцией \texttt{min()}:
\end{itemize}

\begin{verbatim}
[1] 1.513
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите строчку датафрейма \texttt{mtcars} с самым легким автомобилем.
\end{itemize}

\begin{verbatim}
              mpg cyl disp  hp drat    wt qsec vs am gear carb
Lotus Europa 30.4   4 95.1 113 3.77 1.513 16.9  1  1    5    2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките строчки датафрейма \texttt{mtcars} с автомобилями, масса которых ниже средней массы.
\end{itemize}

\begin{verbatim}
                mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Масса автомобиля указана в тысячах фунтов. Создайте колонку \texttt{wt\_kg} с массой автомобиля в килограммах. Результат округлите до целых значений с помощью функции \texttt{round()}.
\end{itemize}

\begin{quote}
1 фунт = 0.45359237 кг.
\end{quote}

\begin{verbatim}
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb wt_kg
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4  1188
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4  1304
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1  1052
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1  1458
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2  1560
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1  1569
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4  1619
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2  1447
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2  1429
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4  1560
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4  1560
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3  1846
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3  1692
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3  1715
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4  2381
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4  2460
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4  2424
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1   998
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2   733
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1   832
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1  1118
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2  1597
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2  1558
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4  1742
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2  1744
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1   878
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2   971
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2   686
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4  1438
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6  1256
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8  1619
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2  1261
\end{verbatim}

\hypertarget{task_if}{%
\section{Условные конструкции}\label{task_if}}

\begin{itemize}
\tightlist
\item
  Создайте вектор \texttt{vec5}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec5 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Создайте новый строковый вектор, где на месте чисел больше 10 в \texttt{vec5} будет стоять ``большое число'', а на месте остальных чисел --- ``маленькое число''.
\end{itemize}

\begin{verbatim}
[1] "маленькое число" "большое число"   "большое число"   "маленькое число"
[5] "маленькое число" "маленькое число"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Загрузите файл heroes\_information.csv в переменную \texttt{heroes}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{, }
                   \DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{,}
                   \DataTypeTok{na.strings =} \KeywordTok{c}\NormalTok{(}\StringTok{"-"}\NormalTok{, }\StringTok{"-99"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Создайте новою колонку \texttt{hair} в \texttt{heroes}, в которой будет значение \texttt{"Bold"} для тех супергероев, у которых в колонке \texttt{Hair.color} стоит \texttt{"No\ Hair"}, и значение \texttt{"Hairy"} во всех остальных случаях.
\end{itemize}

\begin{verbatim}
  X          name Gender Eye.color              Race Hair.color Height
1 0        A-Bomb   Male    yellow             Human    No Hair    203
2 1    Abe Sapien   Male      blue     Icthyo Sapien    No Hair    191
3 2      Abin Sur   Male      blue           Ungaran    No Hair    185
4 3   Abomination   Male     green Human / Radiation    No Hair    203
5 4       Abraxas   Male      blue     Cosmic Entity      Black     NA
6 5 Absorbing Man   Male      blue             Human    No Hair    193
          Publisher Skin.color Alignment Weight  hair
1     Marvel Comics       <NA>      good    441  Bold
2 Dark Horse Comics       blue      good     65  Bold
3         DC Comics        red      good     90  Bold
4     Marvel Comics       <NA>       bad    441  Bold
5     Marvel Comics       <NA>       bad     NA Hairy
6     Marvel Comics       <NA>       bad    122  Bold
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте новою колонку \texttt{tall} в \texttt{heroes}, в которой будет значение \texttt{"tall"} для тех супергероев, у которых в колонке \texttt{Height} стоит число больше 190, значение \texttt{"short"} для тех супергероев, у которых в колонке \texttt{Height} стоит число меньше 170, и значение \texttt{"middle"} во всех остальных случаях.
\end{itemize}

\hypertarget{task_function}{%
\section{Создание функций}\label{task_function}}

\begin{itemize}
\item
  Создайте функцию \texttt{plus\_one()}, которая принимает число и возвращает это же число + 1.
\item
  Проверьте функцию \texttt{plus\_one()} на числе 41.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plus_one}\NormalTok{(}\DecValTok{41}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 42
\end{verbatim}

\begin{itemize}
\item
  Создайте функцию \texttt{circle\_area}, которая вычисляет площадь круга по радиусу согласно формуле \(\pi r^2\).
\item
  Посчитайте площадь круга с радиусом 5.
\end{itemize}

\begin{verbatim}
[1] 78.53982
\end{verbatim}

\begin{itemize}
\item
  Создайте функцию \texttt{cels2fahr()}, которая будет превращать градусы по Цельсию в градусы по Фаренгейту.
\item
  Проверьте на значениях -100, -40 и 0, что функция \texttt{cels2fahr()} работает корректно.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cels2fahr}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{100}\NormalTok{, }\DecValTok{-40}\NormalTok{, }\DecValTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] -148  -40   32
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Напишите функцию \texttt{highlight()}, которая принимает на входе строковый вектор, а возвращает тот же вектор, но дополненный значением \texttt{"***"} в начале и конце вектора. Лучше всего это рассмотреть на примере:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{highlight}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Я"}\NormalTok{, }\StringTok{"Бэтмен!"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "***"     "Я"       "Бэтмен!" "***"    
\end{verbatim}

\begin{itemize}
\item
  Теперь сделайте функцию \texttt{highlight} более гибкой. Добавьте в нее параметр \texttt{wrapper\ =}, который по умолчанию равен \texttt{"***"}. Значение параметра \texttt{wrapper\ =} и будет вставлено в начало и конец вектора.
\item
  Проверьте написанную функцию на векторе \texttt{c("Я",\ "Бэтмен!")}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{highlight}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Я"}\NormalTok{, }\StringTok{"Бэтмен!"}\NormalTok{)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "***"     "Я"       "Бэтмен!" "***"    
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{highlight}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Я"}\NormalTok{, }\StringTok{"Бэтмен!"}\NormalTok{), }\DataTypeTok{wrapper =} \StringTok{"__"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "__"      "Я"       "Бэтмен!" "__"     
\end{verbatim}

\begin{itemize}
\item
  Создайте функцию \texttt{trim()}, которая будет возвращать вектор без первого и последнего значения (вне зависимости от типа данных).
\item
  Проверьте, что функция \texttt{trim()} работает корректно:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2 3 4 5 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(letters)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t"
[20] "u" "v" "w" "x" "y"
\end{verbatim}

\begin{itemize}
\item
  Теперь добавьте в функцию \texttt{trim()} параметр \texttt{n\ =} со значением по умолчанию 1. Этот параметр будет обозначать сколько значений нужно отрезать слева и справа от вектора.
\item
  Проверьте полученную функцию:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(letters)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t"
[20] "u" "v" "w" "x" "y"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(letters, }\DataTypeTok{n =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u"
[20] "v" "w" "x"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сделайте так, чтобы функция \texttt{trim()} работала корректно с \texttt{n\ =\ 0}, т.е. функция возвращала бы исходный вектор без изменений.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(letters, }\DataTypeTok{n =} \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"
\end{verbatim}

\begin{itemize}
\item
  *Теперь добавьте проверку на адекватность входных данных: функция \texttt{trim()} должна выдавать ошибку, если \texttt{n\ =} меньше нуля или если \texttt{n\ =} слишком большой и отрезает все значения вектора:
\item
  *Проверьте полученную функцию \texttt{trim()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in trim(1:6, 3): n слишком большой!
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DecValTok{-1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in trim(1:6, -1): n не может быть меньше нуля!
\end{verbatim}

\begin{itemize}
\item
  Создайте функцию \texttt{na\_n()}, которая будет возвращать количество \texttt{NA} в векторе.
\item
  Проверьте функцию \texttt{na\_n()} на векторе:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{na_n}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{2}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Напишите функцию \texttt{factors()}, которая будет возвращать все делители числа в виде числового вектора.
\end{itemize}

\begin{quote}
Здесь может понадобиться оператор для получения остатка от деления: \texttt{\%\%}.
\end{quote}

\begin{itemize}
\tightlist
\item
  Проверьте функцию \texttt{factors()} на простых и сложных числах:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{factors}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{factors}\NormalTok{(}\DecValTok{161}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]   1   7  23 161
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{factors}\NormalTok{(}\DecValTok{1984}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]    1    2    4    8   16   31   32   62   64  124  248  496  992 1984
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Напишите функцию \texttt{is\_prime()}, которая проверяет, является ли число простым.
\end{itemize}

\begin{quote}
Здесь может пригодиться функция \texttt{any()} - она возвращает \texttt{TRUE}, если в векторе есть хотя бы один \texttt{TRUE}.
\end{quote}

\begin{itemize}
\tightlist
\item
  Проверьте какие года были для нас простыми, а какие нет:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2017}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2019}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2019}\OperatorTok{/}\DecValTok{3} \CommentTok{#2019 делится на 3 без остатка}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 673
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2020}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте функцию \texttt{monotonic()}, которая возвращает \texttt{TRUE}, если значения в векторе не убывают (то есть каждое следующее - больше или равно предыдущему) или не возврастают.
\end{itemize}

\begin{quote}
Полезная функция для этого --- \texttt{diff()} --- возвращает разницу соседних значений.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{,}\DecValTok{5}\OperatorTok{:}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\DecValTok{6}\OperatorTok{:-}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{rep}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{), }\DecValTok{5}\OperatorTok{:}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

Бинарные операторы типа \texttt{+} или \texttt{\%in\%} тоже представляют собой функции. Более того, мы можем создавать свои бинарные операторы! В этом нет особой сложности --- нужно все так же создавать функцию (для двух переменных), главное окружать их \texttt{\%} и название обрамлять обратными штрихами `. Например, можно сделать свой бинарный оператор \texttt{\%notin\%}, который будет выдавать \texttt{TRUE}, если значения слева \emph{нет} в векторе справа:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%notin%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) }\OperatorTok{!}\StringTok{ }\NormalTok{(x }\OperatorTok{%in%}\StringTok{ }\NormalTok{y)}
\DecValTok{1}\OperatorTok{:}\DecValTok{10} \OperatorTok{%notin%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте бинарный оператор \texttt{\%without\%}, который будет возвращать все значения вектора слева без значений вектора справа.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\StringTok{"а"}\NormalTok{, }\StringTok{"и"}\NormalTok{, }\StringTok{"б"}\NormalTok{, }\StringTok{"сидели"}\NormalTok{, }\StringTok{"на"}\NormalTok{, }\StringTok{"трубе"}\NormalTok{) }\OperatorTok{%without%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"а"}\NormalTok{, }\StringTok{"б"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "и"      "сидели" "на"     "трубе" 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте бинарный оператор \texttt{\%between\%}, который будет возвращать \texttt{TRUE}, если значение в векторе слева накходится в \emph{диапазоне} значений вектора справа:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{10} \OperatorTok{%between%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
\end{verbatim}

\hypertarget{task_apply}{%
\section{Семейство функций apply()}\label{task_apply}}

\begin{itemize}
\tightlist
\item
  Создайте матрицу \texttt{M2}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M2 <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{20}\OperatorTok{:}\DecValTok{11}\NormalTok{, }\DecValTok{11}\OperatorTok{:}\DecValTok{20}\NormalTok{), }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{)}
\NormalTok{M2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4]
[1,]   20   15   11   16
[2,]   19   14   12   17
[3,]   18   13   13   18
[4,]   17   12   14   19
[5,]   16   11   15   20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте максимальное значение матрицы \texttt{M2} по каждой строчке.
\end{itemize}

\begin{verbatim}
[1] 20 19 18 19 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте максимальное значение матрицы \texttt{M2} по каждому столбцу.
\end{itemize}

\begin{verbatim}
[1] 20 15 15 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте среднее значение матрицы \texttt{M2} по каждой строке.
\end{itemize}

\begin{verbatim}
[1] 15.5 15.5 15.5 15.5 15.5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте среднее значение матрицы \texttt{M2} по каждому столбцу.
\end{itemize}

\begin{verbatim}
[1] 18 13 13 18
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте список \texttt{list3}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list3 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{a =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{,}
  \DataTypeTok{b =} \DecValTok{0}\OperatorTok{:}\DecValTok{20}\NormalTok{,}
  \DataTypeTok{c =} \DecValTok{4}\OperatorTok{:}\DecValTok{24}\NormalTok{,}
  \DataTypeTok{d =} \DecValTok{6}\OperatorTok{:}\DecValTok{3}\NormalTok{,}
  \DataTypeTok{e =} \DecValTok{6}\OperatorTok{:}\DecValTok{25}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Найдите максимальное значение каждого вектора списка \texttt{list3}.
\end{itemize}

\begin{verbatim}
 a  b  c  d  e 
 5 20 24  6 25 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте сумму каждого вектора списка \texttt{list3}.
\end{itemize}

\begin{verbatim}
  a   b   c   d   e 
 15 210 294  18 310 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте длину каждого вектора списка \texttt{list3}.
\end{itemize}

\begin{verbatim}
 a  b  c  d  e 
 5 21 21  4 20 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Напишите функцию \texttt{max\_item()}, которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент.
\end{itemize}

\begin{quote}
Для этого вам может понадобиться функция \texttt{which.max()}, которая возвращает индекс максимального значения (первого, если их несколько).
\end{quote}

\begin{itemize}
\tightlist
\item
  Проверьте функцию \texttt{max\_item()} на списке \texttt{list3}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{max_item}\NormalTok{(list3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь мы сделаем сложный список \texttt{list4}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list4 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{40}\NormalTok{, list3)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри. Результат должен быть списком с такой же структорой, как и изначальный список \texttt{list4}.
\end{itemize}

\begin{quote}
Для этого может понадобиться функция \texttt{rapply()}: \textbf{recursive lapply}
\end{quote}

\begin{verbatim}
[[1]]
[1] 3

[[2]]
[1] 38

[[3]]
[[3]]$a
[1] 5

[[3]]$b
[1] 21

[[3]]$c
[1] 21

[[3]]$d
[1] 4

[[3]]$e
[1] 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Загрузите набор данных \texttt{heroes} и посчитайте, сколько \texttt{NA} в каждом из столбцов.
\end{itemize}

\begin{quote}
Для этого удобно использовать ранее написанную функцию \texttt{na\_n()}.
\end{quote}

\begin{verbatim}
         X       name     Gender  Eye.color       Race Hair.color     Height 
         0          0         29        172        304        172        217 
 Publisher Skin.color  Alignment     Weight       hair       tall 
         0        662          7        239        172        217 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Используя ранее написанную функцию \texttt{is\_prime()}, напишите функцию \texttt{prime\_numbers()}, которая будет возвращать все простые числа до выбранного числа.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{prime_numbers}\NormalTok{(}\DecValTok{200}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59  61  67  71
[20]  73  79  83  89  97 101 103 107 109 113 127 131 137 139 149 151 157 163 167
[39] 173 179 181 191 193 197 199
\end{verbatim}

\hypertarget{task_pipe}{%
\section{\texorpdfstring{magrittr::\texttt{\%\textgreater{}\%}}{magrittr::\%\textgreater\%}}\label{task_pipe}}

\begin{itemize}
\tightlist
\item
  Перепишите следующие выражения, используя \texttt{\%\textgreater{}\%}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 7.416198
\end{verbatim}

\begin{verbatim}
[1] 7.416198
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{abs}\NormalTok{(}\KeywordTok{min}\NormalTok{(}\OperatorTok{-}\DecValTok{5}\OperatorTok{:}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5
\end{verbatim}

\begin{verbatim}
[1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\StringTok{"Корень из"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\StringTok{"равен"}\NormalTok{, }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Корень из"       "2"               "равен"           "1.4142135623731"
\end{verbatim}

\begin{verbatim}
[1] "Корень из"       "2"               "равен"           "1.4142135623731"
\end{verbatim}

\#\#Выбор строк: \texttt{dplyr::slice()} и \texttt{dplyr::filter()} \{\#task\_filt\}

\begin{itemize}
\tightlist
\item
  Выберите только те строчки, в которых содержится информация о супергероях тяжелее 500 кг.
\end{itemize}

\begin{verbatim}
# A tibble: 6 x 11
     X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
  <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
1   203 Dark~ Male   red         New ~ No Hair       267   DC Comics
2   283 Giga~ Female green       <NA>  Red            62.5 DC Comics
3   331 Hulk  Male   green       Huma~ Green         244   Marvel C~
4   373 Jugg~ Male   blue        Human Red           287   Marvel C~
5   549 Red ~ Male   yellow      Huma~ Black         213   Marvel C~
6   575 Sasq~ Male   red         <NA>  Orange        305   Marvel C~
# ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите только те строчки, в которых содержится информация о \emph{женщинах}-супергероях тяжелее 500 кг.
\end{itemize}

\begin{verbatim}
# A tibble: 1 x 11
     X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
  <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
1   283 Giga~ Female green       <NA>  Red            62.5 DC Comics
# ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите только те строчки, в которых содержится информация о супергероях человеческой расы (\texttt{"Human"}) женского пола. Из этих супергероев возьмите первые 5.
\end{itemize}

\begin{verbatim}
# A tibble: 5 x 11
     X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
  <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
1    38 Arac~ Female blue        Human Blond           175 Marvel C~
2    63 Batg~ Female green       Human Red             170 DC Comics
3    65 Batg~ Female green       Human Black           165 DC Comics
4    72 Batw~ Female green       Human Red             178 DC Comics
5    96 Blac~ Female blue        Human Blond           165 DC Comics
# ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

\#\#Выбор столбцов: \texttt{dplyr::select()} \{\#task\_select\}

\begin{itemize}
\tightlist
\item
  Выберете первые 4 столбца в \texttt{powers}.
\end{itemize}

\begin{verbatim}
# A tibble: 667 x 4
   hero_names    Agility `Accelerated Healing` `Lantern Power Ring`
   <chr>         <lgl>   <lgl>                 <lgl>               
 1 3-D Man       TRUE    FALSE                 FALSE               
 2 A-Bomb        FALSE   TRUE                  FALSE               
 3 Abe Sapien    TRUE    TRUE                  FALSE               
 4 Abin Sur      FALSE   FALSE                 TRUE                
 5 Abomination   FALSE   TRUE                  FALSE               
 6 Abraxas       FALSE   FALSE                 FALSE               
 7 Absorbing Man FALSE   FALSE                 FALSE               
 8 Adam Monroe   FALSE   TRUE                  FALSE               
 9 Adam Strange  FALSE   FALSE                 FALSE               
10 Agent Bob     FALSE   FALSE                 FALSE               
# ... with 657 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите все столбцы от \texttt{Reflexes} до \texttt{Empathy} в тиббле \texttt{powers}:
\end{itemize}

\begin{verbatim}
# A tibble: 667 x 7
   Reflexes Invulnerability `Energy Constru~ `Force Fields` `Self-Sustenanc~
   <lgl>    <lgl>           <lgl>            <lgl>          <lgl>           
 1 FALSE    FALSE           FALSE            FALSE          FALSE           
 2 FALSE    FALSE           FALSE            FALSE          TRUE            
 3 TRUE     FALSE           FALSE            FALSE          FALSE           
 4 FALSE    FALSE           FALSE            FALSE          FALSE           
 5 FALSE    TRUE            FALSE            FALSE          FALSE           
 6 FALSE    TRUE            FALSE            FALSE          FALSE           
 7 FALSE    TRUE            FALSE            FALSE          FALSE           
 8 FALSE    FALSE           FALSE            FALSE          FALSE           
 9 FALSE    FALSE           FALSE            FALSE          FALSE           
10 FALSE    FALSE           FALSE            FALSE          FALSE           
# ... with 657 more rows, and 2 more variables: `Anti-Gravity` <lgl>,
#   Empathy <lgl>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите все столбцы тиббла \texttt{powers} кроме первого (\texttt{hero\_names}):
\end{itemize}

\begin{verbatim}
# A tibble: 667 x 167
   Agility `Accelerated He~ `Lantern Power ~ `Dimensional Aw~ `Cold Resistanc~
   <lgl>   <lgl>            <lgl>            <lgl>            <lgl>           
 1 TRUE    FALSE            FALSE            FALSE            FALSE           
 2 FALSE   TRUE             FALSE            FALSE            FALSE           
 3 TRUE    TRUE             FALSE            FALSE            TRUE            
 4 FALSE   FALSE            TRUE             FALSE            FALSE           
 5 FALSE   TRUE             FALSE            FALSE            FALSE           
 6 FALSE   FALSE            FALSE            TRUE             FALSE           
 7 FALSE   FALSE            FALSE            FALSE            TRUE            
 8 FALSE   TRUE             FALSE            FALSE            FALSE           
 9 FALSE   FALSE            FALSE            FALSE            FALSE           
10 FALSE   FALSE            FALSE            FALSE            FALSE           
# ... with 657 more rows, and 162 more variables: Durability <lgl>,
#   Stealth <lgl>, `Energy Absorption` <lgl>, Flight <lgl>, `Danger
#   Sense` <lgl>, `Underwater breathing` <lgl>, Marksmanship <lgl>, `Weapons
#   Master` <lgl>, `Power Augmentation` <lgl>, `Animal Attributes` <lgl>,
#   Longevity <lgl>, Intelligence <lgl>, `Super Strength` <lgl>,
#   Cryokinesis <lgl>, Telepathy <lgl>, `Energy Armor` <lgl>, `Energy
#   Blasts` <lgl>, Duplication <lgl>, `Size Changing` <lgl>, `Density
#   Control` <lgl>, Stamina <lgl>, `Astral Travel` <lgl>, `Audio
#   Control` <lgl>, Dexterity <lgl>, Omnitrix <lgl>, `Super Speed` <lgl>,
#   Possession <lgl>, `Animal Oriented Powers` <lgl>, `Weapon-based
#   Powers` <lgl>, Electrokinesis <lgl>, `Darkforce Manipulation` <lgl>, `Death
#   Touch` <lgl>, Teleportation <lgl>, `Enhanced Senses` <lgl>,
#   Telekinesis <lgl>, `Energy Beams` <lgl>, Magic <lgl>, Hyperkinesis <lgl>,
#   Jump <lgl>, Clairvoyance <lgl>, `Dimensional Travel` <lgl>, `Power
#   Sense` <lgl>, Shapeshifting <lgl>, `Peak Human Condition` <lgl>,
#   Immortality <lgl>, Camouflage <lgl>, `Element Control` <lgl>,
#   Phasing <lgl>, `Astral Projection` <lgl>, `Electrical Transport` <lgl>,
#   `Fire Control` <lgl>, Projection <lgl>, Summoning <lgl>, `Enhanced
#   Memory` <lgl>, Reflexes <lgl>, Invulnerability <lgl>, `Energy
#   Constructs` <lgl>, `Force Fields` <lgl>, `Self-Sustenance` <lgl>,
#   `Anti-Gravity` <lgl>, Empathy <lgl>, `Power Nullifier` <lgl>, `Radiation
#   Control` <lgl>, `Psionic Powers` <lgl>, Elasticity <lgl>, `Substance
#   Secretion` <lgl>, `Elemental Transmogrification` <lgl>,
#   `Technopath/Cyberpath` <lgl>, `Photographic Reflexes` <lgl>, `Seismic
#   Power` <lgl>, Animation <lgl>, Precognition <lgl>, `Mind Control` <lgl>,
#   `Fire Resistance` <lgl>, `Power Absorption` <lgl>, `Enhanced
#   Hearing` <lgl>, `Nova Force` <lgl>, Insanity <lgl>, Hypnokinesis <lgl>,
#   `Animal Control` <lgl>, `Natural Armor` <lgl>, Intangibility <lgl>,
#   `Enhanced Sight` <lgl>, `Molecular Manipulation` <lgl>, `Heat
#   Generation` <lgl>, Adaptation <lgl>, Gliding <lgl>, `Power Suit` <lgl>,
#   `Mind Blast` <lgl>, `Probability Manipulation` <lgl>, `Gravity
#   Control` <lgl>, Regeneration <lgl>, `Light Control` <lgl>,
#   Echolocation <lgl>, Levitation <lgl>, `Toxin and Disease Control` <lgl>,
#   Banish <lgl>, `Energy Manipulation` <lgl>, `Heat Resistance` <lgl>,
#   `Natural Weapons` <lgl>, ...
\end{verbatim}

\hypertarget{task_arr}{%
\section{\texorpdfstring{Сортировка строк: \texttt{dplyr::arrange()}}{Сортировка строк: dplyr::arrange()}}\label{task_arr}}

\begin{itemize}
\tightlist
\item
  Выберите из тиббла \texttt{heroes} колонки \texttt{name}, \texttt{Gender}, \texttt{Height} и отсортируйте строчки \emph{по возрастанию} \texttt{Height}.
\end{itemize}

\begin{verbatim}
# A tibble: 734 x 3
   name            Gender Height
   <chr>           <chr>   <dbl>
 1 Utgard-Loki     Male     15.2
 2 Bloodwraith     Male     30.5
 3 King Kong       Male     30.5
 4 Anti-Monitor    Male     61  
 5 Giganta         Female   62.5
 6 Krypto          Male     64  
 7 Yoda            Male     66  
 8 Jack-Jack       Male     71  
 9 Howard the Duck Male     79  
10 Godzilla        <NA>    108  
# ... with 724 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите из тиббла \texttt{heroes} колонки \texttt{name}, \texttt{Gender}, \texttt{Height} и отсортируйте строчки \emph{по убыванию} \texttt{Height}.
\end{itemize}

\begin{verbatim}
# A tibble: 734 x 3
   name          Gender Height
   <chr>         <chr>   <dbl>
 1 Fin Fang Foom Male     975 
 2 Galactus      Male     876 
 3 Groot         Male     701 
 4 MODOK         Male     366 
 5 Wolfsbane     Female   366 
 6 Onslaught     Male     305 
 7 Sasquatch     Male     305 
 8 Ymir          Male     305.
 9 Rey           Female   297 
10 Juggernaut    Male     287 
# ... with 724 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите из тиббла \texttt{heroes} колонки \texttt{name}, \texttt{Gender}, \texttt{Height} и отсортируйте строчки сначала по \texttt{Gender}, затем \emph{по убыванию} \texttt{Height}.
\end{itemize}

\begin{verbatim}
# A tibble: 734 x 3
   name      Gender Height
   <chr>     <chr>   <dbl>
 1 Wolfsbane Female    366
 2 Rey       Female    297
 3 Bloodaxe  Female    218
 4 Thundra   Female    218
 5 Hela      Female    213
 6 Frenzy    Female    211
 7 She-Hulk  Female    201
 8 Ardina    Female    193
 9 Starfire  Female    193
10 Valkyrie  Female    191
# ... with 724 more rows
\end{verbatim}

\hypertarget{task_dist}{%
\section{\texorpdfstring{Уникальные значения: \texttt{dplyr::distinct()}}{Уникальные значения: dplyr::distinct()}}\label{task_dist}}

\begin{itemize}
\tightlist
\item
  Извлеките уникальные значения столбца \texttt{Eye\ color} из тиббла \texttt{heroes}.
\end{itemize}

\begin{verbatim}
# A tibble: 23 x 1
   `Eye color`
   <chr>      
 1 yellow     
 2 blue       
 3 green      
 4 brown      
 5 <NA>       
 6 red        
 7 violet     
 8 white      
 9 purple     
10 black      
# ... with 13 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките уникальные значения столбца \texttt{Hair\ color} из тиббла \texttt{heroes}.
\end{itemize}

\begin{verbatim}
# A tibble: 30 x 1
   `Hair color`
   <chr>       
 1 No Hair     
 2 Black       
 3 Blond       
 4 Brown       
 5 <NA>        
 6 White       
 7 Purple      
 8 Orange      
 9 Pink        
10 Red         
# ... with 20 more rows
\end{verbatim}

\hypertarget{task_mutate}{%
\section{\texorpdfstring{Создание колонок: \texttt{dplyr::mutate()} и \texttt{dplyr::transmute()}}{Создание колонок: dplyr::mutate() и dplyr::transmute()}}\label{task_mutate}}

\begin{itemize}
\tightlist
\item
  Создайте колонку \texttt{height\_m} с ростом супергероев в метрах, затем выберите только колонки \texttt{name} и \texttt{height\_m}.
\end{itemize}

\begin{verbatim}
# A tibble: 734 x 2
   name          height_m
   <chr>            <dbl>
 1 A-Bomb            2.03
 2 Abe Sapien        1.91
 3 Abin Sur          1.85
 4 Abomination       2.03
 5 Abraxas          NA   
 6 Absorbing Man     1.93
 7 Adam Monroe      NA   
 8 Adam Strange      1.85
 9 Agent 13          1.73
10 Agent Bob         1.78
# ... with 724 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте новою колонку \texttt{hair} в heroes, в которой будет значение \texttt{"Bold"} для тех супергероев, у которых в колонке \texttt{Hair.color} стоит \texttt{"No\ Hair"}, и значение \texttt{"Hairy"} во всех остальных случаях. Затем выберите только колонки \texttt{name}, \texttt{Hair\ color}, \texttt{hair}.
\end{itemize}

\begin{verbatim}
# A tibble: 734 x 3
   name          `Hair color` hair 
   <chr>         <chr>        <chr>
 1 A-Bomb        No Hair      Bold 
 2 Abe Sapien    No Hair      Bold 
 3 Abin Sur      No Hair      Bold 
 4 Abomination   No Hair      Bold 
 5 Abraxas       Black        Hairy
 6 Absorbing Man No Hair      Bold 
 7 Adam Monroe   Blond        Hairy
 8 Adam Strange  Blond        Hairy
 9 Agent 13      Blond        Hairy
10 Agent Bob     Brown        Hairy
# ... with 724 more rows
\end{verbatim}

\hypertarget{task_group_by}{%
\section{\texorpdfstring{Агрегация: \texttt{dplyr::group\_by()\ \%\textgreater{}\%\ summarise()}}{Агрегация: dplyr::group\_by() \%\textgreater\% summarise()}}\label{task_group_by}}

\begin{itemize}
\tightlist
\item
  Посчитайте количество супергероев по расам и отсортируйте по убыванию. Извлеките первые 5 строк.
\end{itemize}

\begin{verbatim}
# A tibble: 5 x 2
  Race              n
  <chr>         <int>
1 <NA>            304
2 Human           208
3 Mutant           63
4 God / Eternal    14
5 Cyborg           11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте средний пост по полу.
\end{itemize}

\begin{verbatim}
# A tibble: 3 x 2
  Gender height_mean
  <chr>        <dbl>
1 Female        175.
2 Male          192.
3 <NA>          177.
\end{verbatim}

\hypertarget{task_across}{%
\section{\texorpdfstring{Операции с несколькими колонками: \texttt{across()}}{Операции с несколькими колонками: across()}}\label{task_across}}

\begin{itemize}
\tightlist
\item
  Посчитайте количество \texttt{NA} в каждой колонке, группируя по полу (\texttt{Gender}).
\end{itemize}

\begin{verbatim}
# A tibble: 3 x 11
  Gender    X1  name `Eye color`  Race `Hair color` Height Publisher
  <chr>  <int> <int>       <int> <int>        <int>  <int>     <int>
1 Female     0     0          41    98           38     56         0
2 Male       0     0         121   184          123    147         0
3 <NA>       0     0          10    22           11     14         0
# ... with 3 more variables: `Skin color` <int>, Alignment <int>, Weight <int>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте количество \texttt{NA} в каждой колонке, которая заканчивается на \texttt{"color"}, группируя по полу (\texttt{Gender}).
\end{itemize}

\begin{verbatim}
# A tibble: 3 x 4
  Gender `Eye color` `Hair color` `Skin color`
  <chr>        <int>        <int>        <int>
1 Female          41           38          186
2 Male           121          123          449
3 <NA>            10           11           27
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте из тиббла \texttt{heroes} новый тиббл с колонками \texttt{name}, \texttt{Height} и \texttt{Weight}, где для каждого героя содержится значение \texttt{"выше\ среднего"}, если его рост или вес выше среднего по колонке и \texttt{"ниже\ среднего"}, если ниже или равен среднему.
\end{itemize}

\begin{verbatim}
# A tibble: 734 x 3
   name          Height        Weight       
   <chr>         <chr>         <chr>        
 1 A-Bomb        выше среднего выше среднего
 2 Abe Sapien    выше среднего ниже среднего
 3 Abin Sur      ниже среднего ниже среднего
 4 Abomination   выше среднего выше среднего
 5 Abraxas       <NA>          <NA>         
 6 Absorbing Man выше среднего выше среднего
 7 Adam Monroe   <NA>          <NA>         
 8 Adam Strange  ниже среднего ниже среднего
 9 Agent 13      ниже среднего ниже среднего
10 Agent Bob     ниже среднего ниже среднего
# ... with 724 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте из тиббла \texttt{heroes} новый тиббл с колонками \texttt{Gender}, \texttt{name}, \texttt{Height} и \texttt{Weight}, где для каждого героя содержится значение \texttt{"выше\ среднего"}, если его рост или вес выше среднего по колонке и \texttt{"ниже\ среднего"}, если ниже или равен среднему \emph{внутри соответствующей группы по полу}.
\end{itemize}

\begin{verbatim}
# A tibble: 734 x 4
# Groups:   Gender [3]
   Gender name          Height        Weight       
   <chr>  <chr>         <chr>         <chr>        
 1 Male   A-Bomb        выше среднего выше среднего
 2 Male   Abe Sapien    ниже среднего ниже среднего
 3 Male   Abin Sur      ниже среднего ниже среднего
 4 Male   Abomination   выше среднего выше среднего
 5 Male   Abraxas       <NA>          <NA>         
 6 Male   Absorbing Man выше среднего ниже среднего
 7 Male   Adam Monroe   <NA>          <NA>         
 8 Male   Adam Strange  ниже среднего ниже среднего
 9 Female Agent 13      ниже среднего ниже среднего
10 Male   Agent Bob     ниже среднего ниже среднего
# ... with 724 more rows
\end{verbatim}

\hypertarget{ux441ux43eux435ux434ux438ux43dux435ux43dux438ux435-ux434ux430ux442ux430ux444ux440ux435ux439ux43cux43eux432-_join-task_join}{%
\section{Соединение датафреймов: *\_join \{\#task\_join\}}\label{ux441ux43eux435ux434ux438ux43dux435ux43dux438ux435-ux434ux430ux442ux430ux444ux440ux435ux439ux43cux43eux432-_join-task_join}}

\begin{itemize}
\tightlist
\item
  Создайте тиббл \texttt{web\_creators}, в котором будут супергерои, которые могут плести паутину, т.е. у них стоит \texttt{TRUE} в колонке \texttt{Web\ Creation} в тиббле \texttt{powers}.
\end{itemize}

\begin{verbatim}
# A tibble: 16 x 12
      X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
   <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
 1    33 Anti~ Male   blue        Symb~ Blond           229 Marvel C~
 2    38 Arac~ Female blue        Human Blond           175 Marvel C~
 3   161 Carn~ Male   green       Symb~ Red             185 Marvel C~
 4   335 Hybr~ Male   brown       Symb~ Black           175 Marvel C~
 5   479 Myst~ Male   brown       Human No Hair         180 Marvel C~
 6   580 Scar~ Male   brown       Clone Brown           193 Marvel C~
 7   597 Silk  Female brown       Human Black            NA Marvel C~
 8   620 Spid~ Female blue        Human Brown           170 Marvel C~
 9   621 Spid~ Female blue        Human Blond           165 Marvel C~
10   622 Spid~ Male   hazel       Human Brown           178 Marvel C~
11   623 Spid~ <NA>   red         Human Brown           178 Marvel C~
12   624 Spid~ Male   brown       Human Black           157 Marvel C~
13   673 Toxin Male   blue        Symb~ Brown           188 Marvel C~
14   674 Toxin Male   black       Symb~ Blond           191 Marvel C~
15   689 Venom Male   blue        Symb~ Strawberry ~    191 Marvel C~
16   692 Veno~ Male   <NA>        Symb~ <NA>            226 Marvel C~
# ... with 4 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>,
#   `Web Creation` <lgl>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите всех супергероев, которые присутствуют в \texttt{heroes}, но отсутствуют в \texttt{powers}. Ответом должен быть строковый вектор с именами супергероев.
\end{itemize}

\begin{verbatim}
 [1] "Agent 13"          "Alfred Pennyworth" "Arsenal"          
 [4] "Batgirl III"       "Batgirl V"         "Beetle"           
 [7] "Black Goliath"     "Black Widow II"    "Blaquesmith"      
[10] "Bolt"              "Boomer"            "Box"              
[13] "Box III"           "Captain Mar-vell"  "Cat II"           
[16] "Cecilia Reyes"     "Clea"              "Clock King"       
[19] "Colin Wagner"      "Colossal Boy"      "Corsair"          
[22] "Cypher"            "Danny Cooper"      "Darkside"         
[25] "ERG-1"             "Fixer"             "Franklin Storm"   
[28] "Giant-Man"         "Giant-Man II"      "Goliath"          
[31] "Goliath"           "Goliath"           "Guardian"         
[34] "Hawkwoman"         "Hawkwoman II"      "Hawkwoman III"    
[37] "Howard the Duck"   "Jack Bauer"        "Jesse Quick"      
[40] "Jessica Sanders"   "Jigsaw"            "Jyn Erso"         
[43] "Kid Flash II"      "Kingpin"           "Meteorite"        
[46] "Mister Zsasz"      "Mogo"              "Moloch"           
[49] "Morph"             "Nite Owl II"       "Omega Red"        
[52] "Paul Blart"        "Penance"           "Penance I"        
[55] "Plastic Lad"       "Power Man"         "Renata Soliz"     
[58] "Ronin"             "Shrinking Violet"  "Snake-Eyes"       
[61] "Spider-Carnage"    "Spider-Woman II"   "Stacy X"          
[64] "Thunderbird II"    "Two-Face"          "Vagabond"         
[67] "Vision II"         "Vulcan"            "Warbird"          
[70] "White Queen"       "Wiz Kid"           "Wondra"           
[73] "Wyatt Wingfoot"    "Yellow Claw"      
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите всех супергероев, которые присутствуют в \texttt{powers}, но отсутствуют в \texttt{heroes}. Ответом должен быть строковый вектор с именами супергероев.
\end{itemize}

\begin{verbatim}
 [1] "3-D Man"           "Bananaman"         "Bizarro-Girl"     
 [4] "Black Vulcan"      "Blue Streak"       "Bradley"          
 [7] "Clayface"          "Concrete"          "Dementor"         
[10] "Doctor Poison"     "Fire"              "Hellgramite"      
[13] "Lara Croft"        "Little Epic"       "Lord Voldemort"   
[16] "Orion"             "Peek-a-Boo"        "Queen Hippolyta"  
[19] "Reactron"          "SHDB"              "Stretch Armstrong"
[22] "TEST"              "Tommy Clarke"      "Tyrant"           
\end{verbatim}

\hypertarget{task_join}{%
\section{Tidy data}\label{task_join}}

\begin{itemize}
\tightlist
\item
  Для начала создайте тиббл \texttt{heroes\_weight}, скопировав код:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes_weight <-}\StringTok{ }\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(Publisher }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"DC Comics"}\NormalTok{, }\StringTok{"Marvel Comics"}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender, Publisher) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{weight_mean =} \KeywordTok{mean}\NormalTok{(Weight, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{drop_na}\NormalTok{()}
\NormalTok{heroes_weight }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 4 x 3
# Groups:   Gender [2]
  Gender Publisher     weight_mean
  <chr>  <chr>               <dbl>
1 Female DC Comics            76.8
2 Female Marvel Comics        80.1
3 Male   DC Comics           113. 
4 Male   Marvel Comics       134. 
\end{verbatim}

\begin{quote}
Функция \texttt{drop\_na()} позволяет выбросить все строчки, в которых встречается \texttt{NA}.
\end{quote}

\begin{itemize}
\tightlist
\item
  Превратите тиббл \texttt{heroes\_weight} в широкий тиббл:
\end{itemize}

\begin{verbatim}
# A tibble: 2 x 3
# Groups:   Gender [2]
  Gender `DC Comics` `Marvel Comics`
  <chr>        <dbl>           <dbl>
1 Female        76.8            80.1
2 Male         113.            134. 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Затем превратите его обратно в длинный тиббл:
\end{itemize}

\begin{verbatim}
# A tibble: 4 x 3
# Groups:   Gender [2]
  Gender Publisher     weight_mean
  <chr>  <chr>               <dbl>
1 Female DC Comics            76.8
2 Female Marvel Comics        80.1
3 Male   DC Comics           113. 
4 Male   Marvel Comics       134. 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сделайте \texttt{powers} длинным тибблом с тремя колонками: \texttt{hero\_names}, \texttt{power} (названгие суперсилы) и \texttt{has} (наличие суперсилы у данного супергероя).
\end{itemize}

\begin{verbatim}
# A tibble: 111,389 x 3
   hero_names power                 has  
   <chr>      <chr>                 <lgl>
 1 3-D Man    Agility               TRUE 
 2 3-D Man    Accelerated Healing   FALSE
 3 3-D Man    Lantern Power Ring    FALSE
 4 3-D Man    Dimensional Awareness FALSE
 5 3-D Man    Cold Resistance       FALSE
 6 3-D Man    Durability            FALSE
 7 3-D Man    Stealth               FALSE
 8 3-D Man    Energy Absorption     FALSE
 9 3-D Man    Flight                FALSE
10 3-D Man    Danger Sense          FALSE
# ... with 111,379 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сделайте тиббл \texttt{powers} обратно широким, но с новой структурой: каждая строчка означает суперсилу, а каждая колонка - супергероя (за исключением первой колонки - названия суперсилы).
\end{itemize}

\begin{verbatim}
# A tibble: 167 x 668
   power `3-D Man` `A-Bomb` `Abe Sapien` `Abin Sur` Abomination Abraxas
   <chr> <lgl>     <lgl>    <lgl>        <lgl>      <lgl>       <lgl>  
 1 Agil~ TRUE      FALSE    TRUE         FALSE      FALSE       FALSE  
 2 Acce~ FALSE     TRUE     TRUE         FALSE      TRUE        FALSE  
 3 Lant~ FALSE     FALSE    FALSE        TRUE       FALSE       FALSE  
 4 Dime~ FALSE     FALSE    FALSE        FALSE      FALSE       TRUE   
 5 Cold~ FALSE     FALSE    TRUE         FALSE      FALSE       FALSE  
 6 Dura~ FALSE     TRUE     TRUE         FALSE      FALSE       FALSE  
 7 Stea~ FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  
 8 Ener~ FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  
 9 Flig~ FALSE     FALSE    FALSE        FALSE      FALSE       TRUE   
10 Dang~ FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  
# ... with 157 more rows, and 661 more variables: `Absorbing Man` <lgl>, `Adam
#   Monroe` <lgl>, `Adam Strange` <lgl>, `Agent Bob` <lgl>, `Agent Zero` <lgl>,
#   `Air-Walker` <lgl>, Ajax <lgl>, `Alan Scott` <lgl>, `Alex Mercer` <lgl>,
#   `Alex Woolsly` <lgl>, Alien <lgl>, `Allan Quatermain` <lgl>, Amazo <lgl>,
#   Ammo <lgl>, `Ando Masahashi` <lgl>, Angel <lgl>, `Angel Dust` <lgl>, `Angel
#   Salvadore` <lgl>, Angela <lgl>, `Animal Man` <lgl>, Annihilus <lgl>,
#   `Ant-Man` <lgl>, `Ant-Man II` <lgl>, `Anti-Monitor` <lgl>,
#   `Anti-Spawn` <lgl>, `Anti-Venom` <lgl>, Apocalypse <lgl>, Aquababy <lgl>,
#   Aqualad <lgl>, Aquaman <lgl>, Arachne <lgl>, Archangel <lgl>,
#   Arclight <lgl>, Ardina <lgl>, Ares <lgl>, Ariel <lgl>, Armor <lgl>, `Astro
#   Boy` <lgl>, Atlas <lgl>, Atom <lgl>, `Atom Girl` <lgl>, `Atom II` <lgl>,
#   `Atom III` <lgl>, `Atom IV` <lgl>, Aurora <lgl>, Azazel <lgl>,
#   Azrael <lgl>, Aztar <lgl>, Bananaman <lgl>, Bane <lgl>, Banshee <lgl>,
#   Bantam <lgl>, Batgirl <lgl>, `Batgirl IV` <lgl>, `Batgirl VI` <lgl>,
#   Batman <lgl>, `Batman II` <lgl>, Battlestar <lgl>, `Batwoman V` <lgl>,
#   Beak <lgl>, Beast <lgl>, `Beast Boy` <lgl>, `Ben 10` <lgl>, `Beta Ray
#   Bill` <lgl>, Beyonder <lgl>, `Big Barda` <lgl>, `Big Daddy` <lgl>, `Big
#   Man` <lgl>, `Bill Harken` <lgl>, `Billy Kincaid` <lgl>, Binary <lgl>,
#   `Bionic Woman` <lgl>, `Bird-Brain` <lgl>, `Bird-Man` <lgl>, `Bird-Man
#   II` <lgl>, Birdman <lgl>, Bishop <lgl>, Bizarro <lgl>,
#   `Bizarro-Girl` <lgl>, `Black Abbott` <lgl>, `Black Adam` <lgl>, `Black
#   Bolt` <lgl>, `Black Canary` <lgl>, `Black Cat` <lgl>, `Black Flash` <lgl>,
#   `Black Knight III` <lgl>, `Black Lightning` <lgl>, `Black Mamba` <lgl>,
#   `Black Manta` <lgl>, `Black Panther` <lgl>, `Black Vulcan` <lgl>, `Black
#   Widow` <lgl>, Blackout <lgl>, Blackwing <lgl>, Blackwulf <lgl>,
#   Blade <lgl>, `Bling!` <lgl>, Blink <lgl>, Blizzard <lgl>, `Blizzard
#   II` <lgl>, ...
\end{verbatim}

\hypertarget{solutions}{%
\chapter{Решения заданий}\label{solutions}}

\#\#Начало работы в R \{\#solution\_begin\}

\begin{itemize}
\tightlist
\item
  Разделите 9801 на 9.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{9801}\OperatorTok{/}\DecValTok{9}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1089
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте логарифм от 8912162342 по основанию 6.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{2176782336}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 12
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь натуральный логарифм 10 и умножьте его на 5.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{*}\DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 11.51293
\end{verbatim}

\begin{itemize}
\tightlist
\item
  С помощью функции \texttt{sin()} посчитайте \(\sin (\pi), \sin \left(\frac{\pi}{2}\right), \sin \left(\frac{\pi}{6}\right)\).
\end{itemize}

\begin{quote}
Значение \(\pi\) - зашитая в R константа (\texttt{pi}).
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sin}\NormalTok{(pi)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1.224647e-16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sin}\NormalTok{(pi}\OperatorTok{/}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sin}\NormalTok{(pi}\OperatorTok{/}\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.5
\end{verbatim}

\#\#Создание векторов \{\#solution\_new\_vecs\}

\begin{itemize}
\tightlist
\item
  Создайте вектор из значений 2, 30 и 4000.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{4000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]    2   30 4000
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 1 до 20.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{20}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 20 до 1.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{20}\OperatorTok{:}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1
\end{verbatim}

Функция \texttt{sum()} возвращает сумму элементов вектора на входе. Посчитайте сумму первых 100 натуральных чисел (т.е. всех целых чисел от 1 до 100).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5050
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз!
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DecValTok{19}\OperatorTok{:}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15
[26] 14 13 12 11 10  9  8  7  6  5  4  3  2  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор значений 5, 4, 3, 2, 2, 3, 4, 5:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{5}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5 4 3 2 2 3 4 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 2, 4, 6, \ldots{} , 18, 20.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  2  4  6  8 10 12 14 16 18 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 0.1, 0.2, 0.3, \ldots, 0.9, 1.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
\end{verbatim}

\begin{itemize}
\tightlist
\item
  2020 год --- високосный. Следующий високосный год через 4 года --- это будет 2024 год. Составьте календарь всех високосных годов XXI века, начиная с 2020 года.
\end{itemize}

\begin{quote}
2100 год относится к XXI веку, а не к XXII.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{2020}\NormalTok{, }\DecValTok{2100}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] 2020 2024 2028 2032 2036 2040 2044 2048 2052 2056 2060 2064 2068 2072 2076
[16] 2080 2084 2088 2092 2096 2100
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор, состоящий из 20 повторений ``Хэй!''.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\StringTok{"Хэй!"}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!"
[11] "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!" "Хэй!"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Как я и говорил, многие функции, работающие с одним значением на входе, так же прекрасно работают и с целыми векторами. Попробуйте посчитать квадратный корень чисел от 1 до 10 с помощью функции \texttt{sqrt()} и сохраните результат в векторе \texttt{roots}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roots <-}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\NormalTok{roots}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
 [9] 3.000000 3.162278
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Давайте убедимся, что это действительно квадратные корни. Для этого возведите все значения вектора \texttt{roots} в квадрат!
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roots }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Если все верно, то того же самого можно добиться поэлементным умножением вектора \texttt{roots} на себя.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roots }\OperatorTok{*}\StringTok{ }\NormalTok{roots}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте вектор из одной единицы, двух двоек, трех троек, \ldots. , девяти девяток.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 9 9
[39] 9 9 9 9 9 9 9
\end{verbatim}

\hypertarget{solution_coer}{%
\section{Приведение типов}\label{solution_coer}}

\begin{itemize}
\tightlist
\item
  Сделайте вектор \texttt{vec1}, в котором соедините \texttt{3}, а также значения \texttt{"Мой"} и \texttt{"вектор"}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\StringTok{"Мой"}\NormalTok{, }\StringTok{"вектор"}\NormalTok{)}
\NormalTok{vec1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "3"      "Мой"    "вектор"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Попробуйте вычесть \texttt{TRUE} из 10.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{10} \OperatorTok{-}\StringTok{ }\OtherTok{TRUE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините значение \texttt{10} и \texttt{TRUE} в вектор \texttt{vec2}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec2 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\NormalTok{vec2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 10  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините вектор \texttt{vec2} и значение \texttt{"r"}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(vec2, }\StringTok{"r"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "10" "1"  "r" 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините значения \texttt{10}, \texttt{TRUE}, \texttt{"r"} в вектор.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\StringTok{"r"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "10"   "TRUE" "r"   
\end{verbatim}

\hypertarget{solution_vec_ion}{%
\section{Векторизация}\label{solution_vec_ion}}

\begin{itemize}
\tightlist
\item
  Создайте вектор \texttt{p}, состоящий из значений 4, 5, 6, 7, и вектор \texttt{q}, состоящий из 0, 1, 2, 3.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\DecValTok{4}\OperatorTok{:}\DecValTok{7}
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 4 5 6 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q <-}\StringTok{ }\DecValTok{0}\OperatorTok{:}\DecValTok{3}
\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0 1 2 3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте поэлементную сумму векторов \texttt{p} и \texttt{q}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  4  6  8 10
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте поэлементную разницу \texttt{p} и \texttt{q}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{-}\StringTok{ }\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 4 4 4 4
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поделите каждый элемент вектора \texttt{p} на соответствующий ему элемент вектора \texttt{q}:
\end{itemize}

\begin{quote}
О, да, Вам нужно делить на 0!
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{/}\StringTok{ }\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]      Inf 5.000000 3.000000 2.333333
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Возведите каждый элемент вектора \texttt{p} в степень соответствующего ему элемента вектора \texttt{q}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{^}\StringTok{ }\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]   1   5  36 343
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Умножьте каждое значение вектора \texttt{p} на 10.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{*}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 40 50 60 70
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор квадратов чисел от 1 до 10:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}\OperatorTok{^}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]   1   4   9  16  25  36  49  64  81 100
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 0, 2, 0, 4, \ldots{} , 18, 0, 20.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{20} \OperatorTok{*}\StringTok{ }\DecValTok{0}\OperatorTok{:}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  0  2  0  4  0  6  0  8  0 10  0 12  0 14  0 16  0 18  0 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 1, 0, 3, 0, 5, \ldots, 17, 0, 19, 0.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{20} \OperatorTok{*}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  1  0  3  0  5  0  7  0  9  0 11  0 13  0 15  0 17  0 19  0
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте вектор, в котором будут содержаться первые 20 степеней двойки.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{^}\StringTok{ }\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]       2       4       8      16      32      64     128     256     512
[10]    1024    2048    4096    8192   16384   32768   65536  131072  262144
[19]  524288 1048576
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте вектор из чисел 1, 10, 100, 1000, 10000:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{10} \OperatorTok{^}\StringTok{ }\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]     1    10   100  1000 10000
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Посчитать сумму последовательности \(\frac{1}{1 \cdot 2}+\frac{1}{2 \cdot 3}+\frac{1}{3 \cdot 4}+\ldots+\frac{1}{50 \cdot 51}\).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{50} \OperatorTok{*}\StringTok{ }\DecValTok{2}\OperatorTok{:}\DecValTok{51}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.9803922
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Посчитать сумму последовательности \(\frac{1}{2^{0}}+\frac{1}{2^{1}}+\frac{1}{2^{2}}+\frac{1}{2^{3}}+\ldots \frac{1}{2^{20}}\).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\DecValTok{2} \OperatorTok{^}\StringTok{ }\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{20}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1.999999
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Посчитать сумму последовательности \(1+\frac{4}{3}+\frac{7}{9}+\frac{10}{27}+\frac{13}{81}+\ldots+\frac{28}{19683}\).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{((}\DecValTok{3} \OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{) }\OperatorTok{-}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{/}\StringTok{ }\DecValTok{3} \OperatorTok{^}\StringTok{ }\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{9}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3.749174
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Сколько чисел из последовательности \(1+\frac{4}{3}+\frac{7}{9}+\frac{10}{27}+\frac{13}{81}+\ldots+\frac{28}{19683}\) больше чем 0.5?
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{((}\DecValTok{3} \OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{) }\OperatorTok{-}\StringTok{ }\DecValTok{2}\NormalTok{) }\OperatorTok{/}\StringTok{ }\DecValTok{3} \OperatorTok{^}\StringTok{ }\NormalTok{(}\DecValTok{0}\OperatorTok{:}\DecValTok{9}\NormalTok{) }\OperatorTok{>}\StringTok{ }\FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

\hypertarget{solution_vec_ind}{%
\section{Индексирование векторов}\label{solution_vec_ind}}

\begin{itemize}
\tightlist
\item
  Создайте вектор \texttt{troiki} со значениями 3, 6, 9, \ldots, 24, 27.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{troiki <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{troiki}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  3  6  9 12 15 18 21 24 27
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките 2, 5 и 7 значения вектора \texttt{troiki}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{troiki[}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  6 15 21
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките предпоследнее значение вектора \texttt{troiki}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{troiki[}\KeywordTok{length}\NormalTok{(troiki) }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 24
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките все значения вектора \texttt{troiki} \emph{кроме} предпоследнего:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{troiki[}\OperatorTok{-}\NormalTok{(}\KeywordTok{length}\NormalTok{(troiki) }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  3  6  9 12 15 18 21 27
\end{verbatim}

Создайте вектор \texttt{vec3}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Найдите второй элемент вектора \texttt{vec3}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Верните второй и пятый элемент вектора \texttt{vec3}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3[}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5 8
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Попробуйте извлечь сотое значение вектора \texttt{vec3}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3[}\DecValTok{100}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] NA
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Верните все элементы вектора \texttt{vec3} \emph{кроме} второго элемента.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3[}\OperatorTok{-}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  3  2  1  8  4  9 10  3 15  1 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Верните все элементы вектора \texttt{vec3} \emph{кроме} второго и пятого элемента.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3[}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{2}\NormalTok{, }\DecValTok{-5}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  3  2  1  4  9 10  3 15  1 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите последний элемент вектора \texttt{vec3}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3[}\KeywordTok{length}\NormalTok{(vec3)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Верните все значения вектора \texttt{vec3} кроме первого и последнего.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3[}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\OperatorTok{-}\KeywordTok{length}\NormalTok{(vec3))]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  5  2  1  8  4  9 10  3 15  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все значения вектора \texttt{vec3}, которые больше 4.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3[vec3 }\OperatorTok{>}\StringTok{ }\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  5  8  9 10 15 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все значения вектора \texttt{vec3}, которые больше 4, но меньше 10.
\end{itemize}

\begin{quote}
Если хотите сделать это в одну строчку, то вам помогут логические операторы!
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3[vec3 }\OperatorTok{>}\StringTok{ }\DecValTok{4} \OperatorTok{&}\StringTok{ }\NormalTok{vec3 }\OperatorTok{<}\StringTok{ }\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5 8 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все значения вектора \texttt{vec3}, которые меньше 4 или больше 10.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3[vec3 }\OperatorTok{<}\StringTok{ }\DecValTok{4} \OperatorTok{|}\StringTok{ }\NormalTok{vec3 }\OperatorTok{>}\StringTok{ }\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]  3  2  1  3 15  1 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Возведите в квадрат каждое значение вектора \texttt{vec3}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3 }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]   9  25   4   1  64  16  81 100   9 225   1 121
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Возведите в квадрат каждое значение вектора на нечетной позиции и извлеките корень из каждого значения на четной позиции вектора \texttt{vec3}.
\end{itemize}

\begin{quote}
Извлечение корня - это то же самое, что и возведение в степень 0.5.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec3 }\OperatorTok{^}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  9.000000  2.236068  4.000000  1.000000 64.000000  2.000000 81.000000
 [8]  3.162278  9.000000  3.872983  1.000000  3.316625
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 2, 4, 6, \ldots{} , 18, 20 как минимум 2 новыми способами.
\end{itemize}

\begin{quote}
Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше!
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{)[}\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{,}\OtherTok{TRUE}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  2  4  6  8 10 12 14 16 18 20
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#(1:10)*2}
\end{Highlighting}
\end{Shaded}

\#\#Работа с пропущенными значениями \{\#solution\_na\}

\begin{itemize}
\tightlist
\item
  Создайте вектор \texttt{vec4} со значениями 300, 15, 8, 2, 0, 1, 110:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec4 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{300}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{110}\NormalTok{)}
\NormalTok{vec4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 300  15   8  20   0   1 110
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Замените все значения \texttt{vec4}, которые больше 20 на \texttt{NA}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec4[vec4 }\OperatorTok{>}\StringTok{ }\DecValTok{20}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Проверьте полученный вектор \texttt{vec4}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] NA 15  8 20  0  1 NA
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте сумму \texttt{vec4} с помощью функции \texttt{sum()}. Ответ \texttt{NA} не считается!
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(vec4, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 44
\end{verbatim}

\hypertarget{solution_matrix}{%
\section{Матрицы}\label{solution_matrix}}

\begin{itemize}
\tightlist
\item
  Создайте матрицу 4х4, состоящую из единиц. Назовите ее \texttt{M1}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1 <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{16}\NormalTok{), }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{M1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4]
[1,]    1    1    1    1
[2,]    1    1    1    1
[3,]    1    1    1    1
[4,]    1    1    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поменяйте все некрайние значения матрицы \texttt{M1} (то есть значения на позициях {[}2,2{]}, {[}2,3{]}, {[}3,2{]} и {[}3,3{]}) на число 2.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1[}\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{] <-}\StringTok{ }\DecValTok{2}
\NormalTok{M1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4]
[1,]    1    1    1    1
[2,]    1    2    2    1
[3,]    1    2    2    1
[4,]    1    1    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выделите второй и третий столбик из матрицы \texttt{M1}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1[,}\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2]
[1,]    1    1
[2,]    2    2
[3,]    2    2
[4,]    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сравните (\texttt{==}) вторую колонку и вторую строчку матрицы \texttt{M1}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M1[,}\DecValTok{2}\NormalTok{] }\OperatorTok{==}\StringTok{ }\NormalTok{M1[}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE TRUE TRUE TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную \texttt{mult\_tab}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mult_tab <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\KeywordTok{rep}\NormalTok{(}\DecValTok{9}\NormalTok{,}\DecValTok{9}\NormalTok{))}\OperatorTok{*}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{), }\DataTypeTok{nrow =} \DecValTok{9}\NormalTok{)}
\NormalTok{mult_tab}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
 [1,]    1    2    3    4    5    6    7    8    9
 [2,]    2    4    6    8   10   12   14   16   18
 [3,]    3    6    9   12   15   18   21   24   27
 [4,]    4    8   12   16   20   24   28   32   36
 [5,]    5   10   15   20   25   30   35   40   45
 [6,]    6   12   18   24   30   36   42   48   54
 [7,]    7   14   21   28   35   42   49   56   63
 [8,]    8   16   24   32   40   48   56   64   72
 [9,]    9   18   27   36   45   54   63   72   81
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#Еще}
\CommentTok{#outer(1:9, 1:9, "*")}
\CommentTok{#1:9 %o% 1:9}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  *Из матрицы \texttt{mult\_tab} выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mult_tab[}\DecValTok{6}\OperatorTok{:}\DecValTok{8}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{7}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4] [,5]
[1,]   18   24   30   36   42
[2,]   21   28   35   42   49
[3,]   24   32   40   48   56
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте матрицу с логическими значениями, где \texttt{TRUE}, если в этом месте в таблице умножения (\texttt{mult\_tab}) двузначное число и \texttt{FALSE}, если однозначное.
\end{itemize}

\begin{quote}
Матрица - это почти вектор. К нему можно обращаться с единственным индексом.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mult_tab }\OperatorTok{>=}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]
 [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
 [2,] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
 [3,] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [4,] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [5,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [6,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [7,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [8,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
 [9,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте матрицу \texttt{mult\_tab2}, в которой все значения \texttt{tab} меньше 10 заменены на 0.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mult_tab2 <-}\StringTok{ }\NormalTok{mult_tab}
\NormalTok{mult_tab2[mult_tab }\OperatorTok{<}\StringTok{ }\DecValTok{10}\NormalTok{] <-}\StringTok{ }\DecValTok{0}
\NormalTok{mult_tab2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
 [1,]    0    0    0    0    0    0    0    0    0
 [2,]    0    0    0    0   10   12   14   16   18
 [3,]    0    0    0   12   15   18   21   24   27
 [4,]    0    0   12   16   20   24   28   32   36
 [5,]    0   10   15   20   25   30   35   40   45
 [6,]    0   12   18   24   30   36   42   48   54
 [7,]    0   14   21   28   35   42   49   56   63
 [8,]    0   16   24   32   40   48   56   64   72
 [9,]    0   18   27   36   45   54   63   72   81
\end{verbatim}

\hypertarget{solution_list}{%
\section{Списки}\label{solution_list}}

Дан список \texttt{list1}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1 =}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{numbers =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{letters =}\NormalTok{ letters, }\DataTypeTok{logic =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{list1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
$numbers
[1] 1 2 3 4 5

$letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"

$logic
[1] TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите первый элемент списка \texttt{list1}. Ответ должен быть списком длиной один.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
$numbers
[1] 1 2 3 4 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь найдите содержание первого элемента списка \texttt{list1} двумя разными способами. Ответ должен быть вектором.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 2 3 4 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1}\OperatorTok{$}\NormalTok{numbers}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 2 3 4 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь возьмите первый элемент содержания первого элемента списка \texttt{list1}. Ответ должен быть вектором.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1[[}\DecValTok{1}\NormalTok{]][}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте список \texttt{list2}, содержащий в себе два списка \texttt{list1}. Один из них будет иметь имя \texttt{pupa}, а другой --- \texttt{lupa}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list2 =}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{pupa =}\NormalTok{ list1, }\DataTypeTok{lupa =}\NormalTok{ list1)}
\NormalTok{list2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
$pupa
$pupa$numbers
[1] 1 2 3 4 5

$pupa$letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"

$pupa$logic
[1] TRUE


$lupa
$lupa$numbers
[1] 1 2 3 4 5

$lupa$letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"

$lupa$logic
[1] TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Извлеките первый элемент списка \texttt{list2}, из него --- второй полэлемент, а из него --- третье значение.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list2[[}\DecValTok{1}\NormalTok{]][[}\DecValTok{2}\NormalTok{]][}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "c"
\end{verbatim}

\hypertarget{solution_df}{%
\section{Датафрейм}\label{solution_df}}

\begin{itemize}
\tightlist
\item
  Запустите команду \texttt{data(mtcars)} чтобы загрузить встроенный датафрейм с информацией про автомобили. Каждая строчка датафрейма - модель автомобиля, каждая колонка - отдельная характеристика. Подробнее см. \texttt{?mtcars}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data}\NormalTok{(mtcars)}
\NormalTok{mtcars}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Изучите структуру датафрейма \texttt{mtcars} с помощью функции \texttt{str()}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
'data.frame':   32 obs. of  11 variables:
 $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
 $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
 $ disp: num  160 160 108 258 360 ...
 $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
 $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
 $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
 $ qsec: num  16.5 17 18.6 19.4 17 ...
 $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
 $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
 $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
 $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите значение третьей строчки четвертого столбца датафрейма \texttt{mtcars}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 93
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките первые шесть строчек и первые шесть столбцов датафрейма \texttt{mtcars}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                   mpg cyl disp  hp drat    wt
Mazda RX4         21.0   6  160 110 3.90 2.620
Mazda RX4 Wag     21.0   6  160 110 3.90 2.875
Datsun 710        22.8   4  108  93 3.85 2.320
Hornet 4 Drive    21.4   6  258 110 3.08 3.215
Hornet Sportabout 18.7   8  360 175 3.15 3.440
Valiant           18.1   6  225 105 2.76 3.460
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките колонку \texttt{wt} датафрейма \texttt{mtcars} - массу автомобиля в тысячах фунтов.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars}\OperatorTok{$}\NormalTok{wt}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] 2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070
[13] 3.730 3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840
[25] 3.845 1.935 2.140 1.513 3.170 2.770 3.570 2.780
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките колонки из \texttt{mtcars} в следующем порядке: \texttt{hp}, \texttt{mpg}, \texttt{cyl}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[, }\KeywordTok{c}\NormalTok{(}\StringTok{"hp"}\NormalTok{, }\StringTok{"mpg"}\NormalTok{, }\StringTok{"cyl"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                     hp  mpg cyl
Mazda RX4           110 21.0   6
Mazda RX4 Wag       110 21.0   6
Datsun 710           93 22.8   4
Hornet 4 Drive      110 21.4   6
Hornet Sportabout   175 18.7   8
Valiant             105 18.1   6
Duster 360          245 14.3   8
Merc 240D            62 24.4   4
Merc 230             95 22.8   4
Merc 280            123 19.2   6
Merc 280C           123 17.8   6
Merc 450SE          180 16.4   8
Merc 450SL          180 17.3   8
Merc 450SLC         180 15.2   8
Cadillac Fleetwood  205 10.4   8
Lincoln Continental 215 10.4   8
Chrysler Imperial   230 14.7   8
Fiat 128             66 32.4   4
Honda Civic          52 30.4   4
Toyota Corolla       65 33.9   4
Toyota Corona        97 21.5   4
Dodge Challenger    150 15.5   8
AMC Javelin         150 15.2   8
Camaro Z28          245 13.3   8
Pontiac Firebird    175 19.2   8
Fiat X1-9            66 27.3   4
Porsche 914-2        91 26.0   4
Lotus Europa        113 30.4   4
Ford Pantera L      264 15.8   8
Ferrari Dino        175 19.7   6
Maserati Bora       335 15.0   8
Volvo 142E          109 21.4   4
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте \emph{количество} автомобилей с 4 цилиндрами (\texttt{cyl}) в датафрейме \texttt{mtcars}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{cyl }\OperatorTok{==}\StringTok{ }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте \emph{долю} автомобилей с 4 цилиндрами (\texttt{cyl}) в датафрейме \texttt{mtcars}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{cyl }\OperatorTok{==}\StringTok{ }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 0.34375
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все автомобили мощностью не менее 100 лошадиных сил (\texttt{hp}) в датафрейме \texttt{mtcars}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{hp }\OperatorTok{>=}\StringTok{ }\DecValTok{100}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все автомобили мощностью не менее 100 лошадиных сил (\texttt{hp}) и 4 цилиндрами (\texttt{cyl}) в датафрейме \texttt{mtcars}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{hp }\OperatorTok{>=}\StringTok{ }\DecValTok{100} \OperatorTok{&}\StringTok{ }\NormalTok{mtcars}\OperatorTok{$}\NormalTok{cyl }\OperatorTok{==}\StringTok{ }\DecValTok{4}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
              mpg cyl  disp  hp drat    wt qsec vs am gear carb
Lotus Europa 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2
Volvo 142E   21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте максимальную массу (\texttt{wt}) автомобиля в выборке, воспользовавшись функцией \texttt{max()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{max}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{wt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5.424
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте максимальную массу (\texttt{wt}) автомобиля в выборке, воспользовавшись функцией \texttt{min()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{min}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{wt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1.513
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите строчку датафрейма \texttt{mtcars} с самым легким автомобилем.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{wt }\OperatorTok{==}\StringTok{ }\KeywordTok{min}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{wt), ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
              mpg cyl disp  hp drat    wt qsec vs am gear carb
Lotus Europa 30.4   4 95.1 113 3.77 1.513 16.9  1  1    5    2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките строчки датафрейма \texttt{mtcars} с автомобилями, масса которых ниже средней массы.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{wt }\OperatorTok{<}\StringTok{ }\KeywordTok{mean}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{wt), ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Масса автомобиля указана в тысячах фунтов. Создайте колонку \texttt{wt\_kg} с массой автомобиля в килограммах. Результат округлите до целых значений с помощью функции \texttt{round()}.
\end{itemize}

\begin{quote}
1 фунт = 0.45359237 кг.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars}\OperatorTok{$}\NormalTok{wt_kg <-}\StringTok{ }\KeywordTok{round}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{wt }\OperatorTok{*}\StringTok{ }\DecValTok{1000} \OperatorTok{*}\StringTok{ }\FloatTok{0.45359237}\NormalTok{)}
\NormalTok{mtcars}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb wt_kg
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4  1188
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4  1304
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1  1052
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1  1458
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2  1560
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1  1569
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4  1619
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2  1447
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2  1429
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4  1560
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4  1560
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3  1846
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3  1692
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3  1715
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4  2381
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4  2460
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4  2424
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1   998
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2   733
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1   832
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1  1118
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2  1597
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2  1558
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4  1742
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2  1744
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1   878
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2   971
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2   686
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4  1438
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6  1256
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8  1619
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2  1261
\end{verbatim}

\hypertarget{solution_if}{%
\section{Условные конструкции}\label{solution_if}}

\begin{itemize}
\tightlist
\item
  Создайте вектор \texttt{vec5}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec5 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Создайте новый строковый вектор, где на месте чисел больше 10 в \texttt{vec5} будет стоять ``большое число'', а на месте остальных чисел --- ``маленькое число''.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ifelse}\NormalTok{(vec5 }\OperatorTok{>}\StringTok{ }\DecValTok{10}\NormalTok{, }\StringTok{"большое число"}\NormalTok{, }\StringTok{"маленькое число"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "маленькое число" "большое число"   "большое число"   "маленькое число"
[5] "маленькое число" "маленькое число"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Загрузите файл heroes\_information.csv в переменную \texttt{heroes}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{, }
                   \DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{,}
                   \DataTypeTok{na.strings =} \KeywordTok{c}\NormalTok{(}\StringTok{"-"}\NormalTok{, }\StringTok{"-99"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Создайте новою колонку \texttt{hair} в \texttt{heroes}, в которой будет значение \texttt{"Bold"} для тех супергероев, у которых в колонке \texttt{Hair.color} стоит \texttt{"No\ Hair"}, и значение \texttt{"Hairy"} во всех остальных случаях.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes}\OperatorTok{$}\NormalTok{hair <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(heroes}\OperatorTok{$}\NormalTok{Hair.color }\OperatorTok{==}\StringTok{ "No Hair"}\NormalTok{, }\StringTok{"Bold"}\NormalTok{, }\StringTok{"Hairy"}\NormalTok{)}
\KeywordTok{head}\NormalTok{(heroes)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  X          name Gender Eye.color              Race Hair.color Height
1 0        A-Bomb   Male    yellow             Human    No Hair    203
2 1    Abe Sapien   Male      blue     Icthyo Sapien    No Hair    191
3 2      Abin Sur   Male      blue           Ungaran    No Hair    185
4 3   Abomination   Male     green Human / Radiation    No Hair    203
5 4       Abraxas   Male      blue     Cosmic Entity      Black     NA
6 5 Absorbing Man   Male      blue             Human    No Hair    193
          Publisher Skin.color Alignment Weight  hair
1     Marvel Comics       <NA>      good    441  Bold
2 Dark Horse Comics       blue      good     65  Bold
3         DC Comics        red      good     90  Bold
4     Marvel Comics       <NA>       bad    441  Bold
5     Marvel Comics       <NA>       bad     NA Hairy
6     Marvel Comics       <NA>       bad    122  Bold
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте новою колонку \texttt{tall} в \texttt{heroes}, в которой будет значение \texttt{"tall"} для тех супергероев, у которых в колонке \texttt{Height} стоит число больше 190, значение \texttt{"short"} для тех супергероев, у которых в колонке \texttt{Height} стоит число меньше 170, и значение \texttt{"middle"} во всех остальных случаях.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# heroes$tall <- dplyr::case_when(}
\CommentTok{#   heroes$Height > 190 ~ "tall",}
\CommentTok{#   heroes$Height < 170 ~ "short",}
\CommentTok{#   TRUE ~ "middle"}
\CommentTok{# )}
\NormalTok{heroes}\OperatorTok{$}\NormalTok{tall <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(heroes}\OperatorTok{$}\NormalTok{Height }\OperatorTok{>}\StringTok{ }\DecValTok{190}\NormalTok{, }
                      \StringTok{"tall"}\NormalTok{,}
                      \KeywordTok{ifelse}\NormalTok{(heroes}\OperatorTok{$}\NormalTok{Height }\OperatorTok{<}\StringTok{ }\DecValTok{170}\NormalTok{,}
                             \StringTok{"short"}\NormalTok{,}
                             \StringTok{"middle"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{solution_function}{%
\section{Создание функций}\label{solution_function}}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{plus\_one()}, которая принимает число и возвращает это же число + 1.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plus_one <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Проверьте функцию \texttt{plus\_one()} на числе 41.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plus_one}\NormalTok{(}\DecValTok{41}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 42
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{circle\_area}, которая вычисляет площадь круга по радиусу согласно формуле \(\pi r^2\).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{circle_area <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(r) pi }\OperatorTok{*}\StringTok{ }\NormalTok{r }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Посчитайте площадь круга с радиусом 5.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{circle_area}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 78.53982
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{cels2fahr()}, которая будет превращать градусы по Цельсию в градусы по Фаренгейту.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cels2fahr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{*}\StringTok{ }\DecValTok{9} \OperatorTok{/}\StringTok{ }\DecValTok{5} \OperatorTok{+}\StringTok{ }\DecValTok{32}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Проверьте на значениях -100, -40 и 0, что функция \texttt{cels2fahr()} работает корректно.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cels2fahr}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{100}\NormalTok{, }\DecValTok{-40}\NormalTok{, }\DecValTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] -148  -40   32
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Напишите функцию \texttt{highlight()}, которая принимает на входе строковый вектор, а возвращает тот же вектор, но дополненный значением \texttt{"***"} в начале и конце вектора. Лучше всего это рассмотреть на примере:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{highlight <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{c}\NormalTok{(}\StringTok{"***"}\NormalTok{, x, }\StringTok{"***"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{highlight}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Я"}\NormalTok{, }\StringTok{"Бэтмен!"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "***"     "Я"       "Бэтмен!" "***"    
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь сделайте функцию \texttt{highlight} более гибкой. Добавьте в нее параметр \texttt{wrapper\ =}, который по умолчанию равен \texttt{"***"}. Значение параметра \texttt{wrapper\ =} и будет вставлено в начало и конец вектора.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{highlight <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{wrapper =} \StringTok{"***"}\NormalTok{) }\KeywordTok{c}\NormalTok{(wrapper, x, wrapper)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Проверьте написанную функцию на векторе \texttt{c("Я",\ "Бэтмен!")}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{highlight}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Я"}\NormalTok{, }\StringTok{"Бэтмен!"}\NormalTok{)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "***"     "Я"       "Бэтмен!" "***"    
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{highlight}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Я"}\NormalTok{, }\StringTok{"Бэтмен!"}\NormalTok{), }\DataTypeTok{wrapper =} \StringTok{"__"}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "__"      "Я"       "Бэтмен!" "__"     
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{trim()}, которая будет возвращать вектор без первого и последнего значения (вне зависимости от типа данных).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trim <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x[}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\OperatorTok{-}\KeywordTok{length}\NormalTok{(x))]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Проверьте, что функция \texttt{trim()} работает корректно:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 2 3 4 5 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(letters)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t"
[20] "u" "v" "w" "x" "y"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь добавьте в функцию \texttt{trim()} параметр \texttt{n\ =} со значением по умолчанию 1. Этот параметр будет обозначать сколько значений нужно отрезать слева и справа от вектора.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trim <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{n =} \DecValTok{1}\NormalTok{) x[}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\OperatorTok{:-}\NormalTok{n, (}\OperatorTok{-}\KeywordTok{length}\NormalTok{(x)}\OperatorTok{+}\NormalTok{n}\DecValTok{-1}\NormalTok{)}\OperatorTok{:-}\KeywordTok{length}\NormalTok{(x))]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Проверьте полученную функцию:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(letters)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t"
[20] "u" "v" "w" "x" "y"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(letters, }\DataTypeTok{n =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u"
[20] "v" "w" "x"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сделайте так, чтобы функция \texttt{trim()} работала корректно с \texttt{n\ =\ 0}, т.е. функция возвращала бы исходный вектор без изменений.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trim <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{n =} \DecValTok{1}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }\KeywordTok{return}\NormalTok{(x)}
\NormalTok{  x[}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\OperatorTok{:-}\NormalTok{n, (}\OperatorTok{-}\KeywordTok{length}\NormalTok{(x)}\OperatorTok{+}\NormalTok{n}\DecValTok{-1}\NormalTok{)}\OperatorTok{:-}\KeywordTok{length}\NormalTok{(x))]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(letters, }\DataTypeTok{n =} \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Теперь добавьте проверку на адекватность входных данных: функция \texttt{trim()} должна выдавать ошибку, если \texttt{n\ =} меньше нуля или если \texttt{n\ =} слишком большой и отрезает все значения вектора:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trim <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{n =} \DecValTok{1}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) }\KeywordTok{stop}\NormalTok{(}\StringTok{"n не может быть меньше нуля!"}\NormalTok{)}
\NormalTok{  l <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
  \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{>}\StringTok{ }\KeywordTok{ceiling}\NormalTok{(l}\OperatorTok{/}\DecValTok{2}\NormalTok{) }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\KeywordTok{stop}\NormalTok{(}\StringTok{"n слишком большой!"}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }\KeywordTok{return}\NormalTok{(x)}
\NormalTok{  x[}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\OperatorTok{:-}\NormalTok{n, (}\OperatorTok{-}\NormalTok{l}\OperatorTok{+}\NormalTok{n}\DecValTok{-1}\NormalTok{)}\OperatorTok{:-}\NormalTok{l)]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  *Проверьте полученную функцию \texttt{trim()}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in trim(1:6, 3): n слишком большой!
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{trim}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DecValTok{-1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Error in trim(1:6, -1): n не может быть меньше нуля!
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{na\_n()}, которая будет возвращать количество \texttt{NA} в векторе.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{na_n <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Проверьте функцию \texttt{na\_n()} на векторе:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{na_n}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{2}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Напишите функцию \texttt{factors()}, которая будет возвращать все делители числа в виде числового вектора.
\end{itemize}

\begin{quote}
Здесь может понадобиться оператор для получения остатка от деления: \texttt{\%\%}.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{factors <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) (}\DecValTok{1}\OperatorTok{:}\NormalTok{x)[x }\OperatorTok{%%}\StringTok{ }\NormalTok{(}\DecValTok{1}\OperatorTok{:}\NormalTok{x) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Проверьте функцию \texttt{factors()} на простых и сложных числах:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{factors}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 1 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{factors}\NormalTok{(}\DecValTok{161}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1]   1   7  23 161
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{factors}\NormalTok{(}\DecValTok{1984}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]    1    2    4    8   16   31   32   62   64  124  248  496  992 1984
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Напишите функцию \texttt{is\_prime()}, которая проверяет, является ли число простым.
\end{itemize}

\begin{quote}
Здесь может пригодиться функция \texttt{any()} - она возвращает \texttt{TRUE}, если в векторе есть хотя бы один \texttt{TRUE}.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{is_prime <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\OperatorTok{!}\KeywordTok{any}\NormalTok{(x}\OperatorTok{%%}\NormalTok{(}\DecValTok{2}\OperatorTok{:}\NormalTok{(x}\DecValTok{-1}\NormalTok{)) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)}
\CommentTok{#is_prime <- function(x) length(factors(x)) == 2 #Используя уже написанную функцию factors()}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Проверьте какие года были для нас простыми, а какие нет:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2017}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2019}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2019}\OperatorTok{/}\DecValTok{3} \CommentTok{#2019 делится на 3 без остатка}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 673
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2020}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте функцию \texttt{monotonic()}, которая возвращает \texttt{TRUE}, если значения в векторе не убывают (то есть каждое следующее - больше или равно предыдущему) или не возврастают.
\end{itemize}

\begin{quote}
Полезная функция для этого --- \texttt{diff()} --- возвращает разницу соседних значений.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{monotonic <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{all}\NormalTok{(}\KeywordTok{diff}\NormalTok{(x)}\OperatorTok{>=}\DecValTok{0}\NormalTok{) }\OperatorTok{|}\StringTok{ }\KeywordTok{all}\NormalTok{(}\KeywordTok{diff}\NormalTok{(x)}\OperatorTok{<=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{,}\DecValTok{5}\OperatorTok{:}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\DecValTok{6}\OperatorTok{:-}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{rep}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{), }\DecValTok{5}\OperatorTok{:}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] TRUE
\end{verbatim}

Бинарные операторы типа \texttt{+} или \texttt{\%in\%} тоже представляют собой функции. Более того, мы можем создавать свои бинарные операторы! В этом нет особой сложности --- нужно все так же создавать функцию (для двух переменных), главное окружать их \texttt{\%} и название обрамлять обратными штрихами `. Например, можно сделать свой бинарный оператор \texttt{\%notin\%}, который будет выдавать \texttt{TRUE}, если значения слева \emph{нет} в векторе справа:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%notin%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) }\OperatorTok{!}\StringTok{ }\NormalTok{(x }\OperatorTok{%in%}\StringTok{ }\NormalTok{y)}
\DecValTok{1}\OperatorTok{:}\DecValTok{10} \OperatorTok{%notin%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте бинарный оператор \texttt{\%without\%}, который будет возвращать все значения вектора слева без значений вектора справа.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%without%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) x[}\OperatorTok{!}\NormalTok{x }\OperatorTok{%in%}\StringTok{ }\NormalTok{y]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\StringTok{"а"}\NormalTok{, }\StringTok{"и"}\NormalTok{, }\StringTok{"б"}\NormalTok{, }\StringTok{"сидели"}\NormalTok{, }\StringTok{"на"}\NormalTok{, }\StringTok{"трубе"}\NormalTok{) }\OperatorTok{%without%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"а"}\NormalTok{, }\StringTok{"б"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "и"      "сидели" "на"     "трубе" 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте бинарный оператор \texttt{\%between\%}, который будет возвращать \texttt{TRUE}, если значение в векторе слева накходится в \emph{диапазоне} значений вектора справа:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%between%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) x }\OperatorTok{>=}\StringTok{ }\KeywordTok{min}\NormalTok{(y) }\OperatorTok{&}\StringTok{ }\NormalTok{x }\OperatorTok{<=}\StringTok{ }\KeywordTok{max}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{10} \OperatorTok{%between%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE
\end{verbatim}

\hypertarget{solution_apply}{%
\section{Семейство функций apply()}\label{solution_apply}}

\begin{itemize}
\tightlist
\item
  Создайте матрицу \texttt{M2}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M2 <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{20}\OperatorTok{:}\DecValTok{11}\NormalTok{, }\DecValTok{11}\OperatorTok{:}\DecValTok{20}\NormalTok{), }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{)}
\NormalTok{M2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
     [,1] [,2] [,3] [,4]
[1,]   20   15   11   16
[2,]   19   14   12   17
[3,]   18   13   13   18
[4,]   17   12   14   19
[5,]   16   11   15   20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте максимальное значение матрицы \texttt{M2} по каждой строчке.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(M2, }\DecValTok{1}\NormalTok{, max)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 20 19 18 19 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте максимальное значение матрицы \texttt{M2} по каждому столбцу.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(M2, }\DecValTok{2}\NormalTok{, max)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 20 15 15 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте среднее значение матрицы \texttt{M2} по каждой строке.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(M2, }\DecValTok{1}\NormalTok{, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 15.5 15.5 15.5 15.5 15.5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте среднее значение матрицы \texttt{M2} по каждому столбцу.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(M2, }\DecValTok{2}\NormalTok{, mean)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 18 13 13 18
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте список \texttt{list3}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list3 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{a =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{,}
  \DataTypeTok{b =} \DecValTok{0}\OperatorTok{:}\DecValTok{20}\NormalTok{,}
  \DataTypeTok{c =} \DecValTok{4}\OperatorTok{:}\DecValTok{24}\NormalTok{,}
  \DataTypeTok{d =} \DecValTok{6}\OperatorTok{:}\DecValTok{3}\NormalTok{,}
  \DataTypeTok{e =} \DecValTok{6}\OperatorTok{:}\DecValTok{25}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Найдите максимальное значение каждого вектора списка \texttt{list3}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(list3, max)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 a  b  c  d  e 
 5 20 24  6 25 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте сумму каждого вектора списка \texttt{list3}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(list3, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  a   b   c   d   e 
 15 210 294  18 310 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте длину каждого вектора списка \texttt{list3}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(list3, length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 a  b  c  d  e 
 5 21 21  4 20 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Напишите функцию \texttt{max\_item()}, которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент.
\end{itemize}

\begin{quote}
Для этого вам может понадобиться функция \texttt{which.max()}, которая возвращает индекс максимального значения (первого, если их несколько).
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{max_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x) x[[}\KeywordTok{which.max}\NormalTok{(}\KeywordTok{sapply}\NormalTok{(x, length))]]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Проверьте функцию \texttt{max\_item()} на списке \texttt{list3}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{max_item}\NormalTok{(list3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь мы сделаем сложный список \texttt{list4}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list4 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{40}\NormalTok{, list3)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри. Результат должен быть списком с такой же структорой, как и изначальный список \texttt{list4}.
\end{itemize}

\begin{quote}
Для этого может понадобиться функция \texttt{rapply()}: \textbf{recursive lapply}
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rapply}\NormalTok{(list4, length, }\DataTypeTok{how =} \StringTok{"list"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[[1]]
[1] 3

[[2]]
[1] 38

[[3]]
[[3]]$a
[1] 5

[[3]]$b
[1] 21

[[3]]$c
[1] 21

[[3]]$d
[1] 4

[[3]]$e
[1] 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Загрузите набор данных \texttt{heroes} и посчитайте, сколько \texttt{NA} в каждом из столбцов.
\end{itemize}

\begin{quote}
Для этого удобно использовать ранее написанную функцию \texttt{na\_n()}.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(heroes, na_n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
         X       name     Gender  Eye.color       Race Hair.color     Height 
         0          0         29        172        304        172        217 
 Publisher Skin.color  Alignment     Weight       hair       tall 
         0        662          7        239        172        217 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Используя ранее написанную функцию \texttt{is\_prime()}, напишите функцию \texttt{prime\_numbers()}, которая будет возвращать все простые числа до выбранного числа.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{is_prime <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\OperatorTok{!}\KeywordTok{any}\NormalTok{(x }\OperatorTok{%%}\StringTok{ }\NormalTok{(}\DecValTok{2}\OperatorTok{:}\NormalTok{(x }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)}
\NormalTok{prime_numbers <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) (}\DecValTok{2}\OperatorTok{:}\NormalTok{x)[}\KeywordTok{sapply}\NormalTok{(}\DecValTok{2}\OperatorTok{:}\NormalTok{x, is_prime)]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{prime_numbers}\NormalTok{(}\DecValTok{200}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1]   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59  61  67  71
[20]  73  79  83  89  97 101 103 107 109 113 127 131 137 139 149 151 157 163 167
[39] 173 179 181 191 193 197 199
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(tidyverse)}
\NormalTok{heroes <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\StringTok{"data/heroes_information.csv"}\NormalTok{,}
                   \DataTypeTok{na =} \KeywordTok{c}\NormalTok{(}\StringTok{"-"}\NormalTok{, }\StringTok{"-99"}\NormalTok{))}
\NormalTok{powers <-}\StringTok{ }\KeywordTok{read_csv}\NormalTok{(}\StringTok{"data/super_hero_powers.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{solution_pipe}{%
\section{\texorpdfstring{magrittr::\texttt{\%\textgreater{}\%}}{magrittr::\%\textgreater\%}}\label{solution_pipe}}

\begin{itemize}
\tightlist
\item
  Перепишите следующие выражения, используя \texttt{\%\textgreater{}\%}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 7.416198
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{10} \OperatorTok{%>%}
\StringTok{  }\KeywordTok{sum}\NormalTok{() }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{sqrt}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 7.416198
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{abs}\NormalTok{(}\KeywordTok{min}\NormalTok{(}\OperatorTok{-}\DecValTok{5}\OperatorTok{:}\DecValTok{5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{-5}\OperatorTok{:}\DecValTok{5} \OperatorTok{%>%}
\StringTok{  }\KeywordTok{min}\NormalTok{() }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{abs}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\StringTok{"Корень из"}\NormalTok{, }\DecValTok{2}\NormalTok{, }\StringTok{"равен"}\NormalTok{, }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Корень из"       "2"               "равен"           "1.4142135623731"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{%>%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Корень из"}\NormalTok{, ., }\StringTok{"равен"}\NormalTok{, }\KeywordTok{sqrt}\NormalTok{(.))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
[1] "Корень из"       "2"               "равен"           "1.4142135623731"
\end{verbatim}

\#\#Выбор строк: \texttt{dplyr::slice()} и \texttt{dplyr::filter()} \{\#solution\_filt\}

\begin{itemize}
\tightlist
\item
  Выберите только те строчки, в которых содержится информация о супергероях тяжелее 500 кг.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{filter}\NormalTok{(Weight }\OperatorTok{>}\StringTok{ }\DecValTok{500}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 6 x 11
     X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
  <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
1   203 Dark~ Male   red         New ~ No Hair       267   DC Comics
2   283 Giga~ Female green       <NA>  Red            62.5 DC Comics
3   331 Hulk  Male   green       Huma~ Green         244   Marvel C~
4   373 Jugg~ Male   blue        Human Red           287   Marvel C~
5   549 Red ~ Male   yellow      Huma~ Black         213   Marvel C~
6   575 Sasq~ Male   red         <NA>  Orange        305   Marvel C~
# ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите только те строчки, в которых содержится информация о \emph{женщинах}-супергероях тяжелее 500 кг.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{filter}\NormalTok{(Weight }\OperatorTok{>}\StringTok{ }\DecValTok{500} \OperatorTok{&}\StringTok{ }\NormalTok{Gender }\OperatorTok{==}\StringTok{ "Female"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 1 x 11
     X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
  <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
1   283 Giga~ Female green       <NA>  Red            62.5 DC Comics
# ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите только те строчки, в которых содержится информация о супергероях человеческой расы (\texttt{"Human"}) женского пола. Из этих супергероев возьмите первые 5.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{filter}\NormalTok{(Race }\OperatorTok{==}\StringTok{ "Human"} \OperatorTok{&}\StringTok{ }\NormalTok{Gender }\OperatorTok{==}\StringTok{ "Female"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 5 x 11
     X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
  <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
1    38 Arac~ Female blue        Human Blond           175 Marvel C~
2    63 Batg~ Female green       Human Red             170 DC Comics
3    65 Batg~ Female green       Human Black           165 DC Comics
4    72 Batw~ Female green       Human Red             178 DC Comics
5    96 Blac~ Female blue        Human Blond           165 DC Comics
# ... with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>
\end{verbatim}

\#\#Выбор столбцов: \texttt{dplyr::select()} \{\#solution\_select\}

\begin{itemize}
\tightlist
\item
  Выберете первые 4 столбца в \texttt{powers}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{powers }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 667 x 4
   hero_names    Agility `Accelerated Healing` `Lantern Power Ring`
   <chr>         <lgl>   <lgl>                 <lgl>               
 1 3-D Man       TRUE    FALSE                 FALSE               
 2 A-Bomb        FALSE   TRUE                  FALSE               
 3 Abe Sapien    TRUE    TRUE                  FALSE               
 4 Abin Sur      FALSE   FALSE                 TRUE                
 5 Abomination   FALSE   TRUE                  FALSE               
 6 Abraxas       FALSE   FALSE                 FALSE               
 7 Absorbing Man FALSE   FALSE                 FALSE               
 8 Adam Monroe   FALSE   TRUE                  FALSE               
 9 Adam Strange  FALSE   FALSE                 FALSE               
10 Agent Bob     FALSE   FALSE                 FALSE               
# ... with 657 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите все столбцы от \texttt{Reflexes} до \texttt{Empathy} в тиббле \texttt{powers}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{powers }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(Reflexes}\OperatorTok{:}\NormalTok{Empathy)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 667 x 7
   Reflexes Invulnerability `Energy Constru~ `Force Fields` `Self-Sustenanc~
   <lgl>    <lgl>           <lgl>            <lgl>          <lgl>           
 1 FALSE    FALSE           FALSE            FALSE          FALSE           
 2 FALSE    FALSE           FALSE            FALSE          TRUE            
 3 TRUE     FALSE           FALSE            FALSE          FALSE           
 4 FALSE    FALSE           FALSE            FALSE          FALSE           
 5 FALSE    TRUE            FALSE            FALSE          FALSE           
 6 FALSE    TRUE            FALSE            FALSE          FALSE           
 7 FALSE    TRUE            FALSE            FALSE          FALSE           
 8 FALSE    FALSE           FALSE            FALSE          FALSE           
 9 FALSE    FALSE           FALSE            FALSE          FALSE           
10 FALSE    FALSE           FALSE            FALSE          FALSE           
# ... with 657 more rows, and 2 more variables: `Anti-Gravity` <lgl>,
#   Empathy <lgl>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите все столбцы тиббла \texttt{powers} кроме первого (\texttt{hero\_names}):
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{powers }\OperatorTok{%>%}
\KeywordTok{select}\NormalTok{(}\OperatorTok{!}\NormalTok{hero_names)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 667 x 167
   Agility `Accelerated He~ `Lantern Power ~ `Dimensional Aw~ `Cold Resistanc~
   <lgl>   <lgl>            <lgl>            <lgl>            <lgl>           
 1 TRUE    FALSE            FALSE            FALSE            FALSE           
 2 FALSE   TRUE             FALSE            FALSE            FALSE           
 3 TRUE    TRUE             FALSE            FALSE            TRUE            
 4 FALSE   FALSE            TRUE             FALSE            FALSE           
 5 FALSE   TRUE             FALSE            FALSE            FALSE           
 6 FALSE   FALSE            FALSE            TRUE             FALSE           
 7 FALSE   FALSE            FALSE            FALSE            TRUE            
 8 FALSE   TRUE             FALSE            FALSE            FALSE           
 9 FALSE   FALSE            FALSE            FALSE            FALSE           
10 FALSE   FALSE            FALSE            FALSE            FALSE           
# ... with 657 more rows, and 162 more variables: Durability <lgl>,
#   Stealth <lgl>, `Energy Absorption` <lgl>, Flight <lgl>, `Danger
#   Sense` <lgl>, `Underwater breathing` <lgl>, Marksmanship <lgl>, `Weapons
#   Master` <lgl>, `Power Augmentation` <lgl>, `Animal Attributes` <lgl>,
#   Longevity <lgl>, Intelligence <lgl>, `Super Strength` <lgl>,
#   Cryokinesis <lgl>, Telepathy <lgl>, `Energy Armor` <lgl>, `Energy
#   Blasts` <lgl>, Duplication <lgl>, `Size Changing` <lgl>, `Density
#   Control` <lgl>, Stamina <lgl>, `Astral Travel` <lgl>, `Audio
#   Control` <lgl>, Dexterity <lgl>, Omnitrix <lgl>, `Super Speed` <lgl>,
#   Possession <lgl>, `Animal Oriented Powers` <lgl>, `Weapon-based
#   Powers` <lgl>, Electrokinesis <lgl>, `Darkforce Manipulation` <lgl>, `Death
#   Touch` <lgl>, Teleportation <lgl>, `Enhanced Senses` <lgl>,
#   Telekinesis <lgl>, `Energy Beams` <lgl>, Magic <lgl>, Hyperkinesis <lgl>,
#   Jump <lgl>, Clairvoyance <lgl>, `Dimensional Travel` <lgl>, `Power
#   Sense` <lgl>, Shapeshifting <lgl>, `Peak Human Condition` <lgl>,
#   Immortality <lgl>, Camouflage <lgl>, `Element Control` <lgl>,
#   Phasing <lgl>, `Astral Projection` <lgl>, `Electrical Transport` <lgl>,
#   `Fire Control` <lgl>, Projection <lgl>, Summoning <lgl>, `Enhanced
#   Memory` <lgl>, Reflexes <lgl>, Invulnerability <lgl>, `Energy
#   Constructs` <lgl>, `Force Fields` <lgl>, `Self-Sustenance` <lgl>,
#   `Anti-Gravity` <lgl>, Empathy <lgl>, `Power Nullifier` <lgl>, `Radiation
#   Control` <lgl>, `Psionic Powers` <lgl>, Elasticity <lgl>, `Substance
#   Secretion` <lgl>, `Elemental Transmogrification` <lgl>,
#   `Technopath/Cyberpath` <lgl>, `Photographic Reflexes` <lgl>, `Seismic
#   Power` <lgl>, Animation <lgl>, Precognition <lgl>, `Mind Control` <lgl>,
#   `Fire Resistance` <lgl>, `Power Absorption` <lgl>, `Enhanced
#   Hearing` <lgl>, `Nova Force` <lgl>, Insanity <lgl>, Hypnokinesis <lgl>,
#   `Animal Control` <lgl>, `Natural Armor` <lgl>, Intangibility <lgl>,
#   `Enhanced Sight` <lgl>, `Molecular Manipulation` <lgl>, `Heat
#   Generation` <lgl>, Adaptation <lgl>, Gliding <lgl>, `Power Suit` <lgl>,
#   `Mind Blast` <lgl>, `Probability Manipulation` <lgl>, `Gravity
#   Control` <lgl>, Regeneration <lgl>, `Light Control` <lgl>,
#   Echolocation <lgl>, Levitation <lgl>, `Toxin and Disease Control` <lgl>,
#   Banish <lgl>, `Energy Manipulation` <lgl>, `Heat Resistance` <lgl>,
#   `Natural Weapons` <lgl>, ...
\end{verbatim}

\hypertarget{solution_arr}{%
\section{\texorpdfstring{Сортировка строк: \texttt{dplyr::arrange()}}{Сортировка строк: dplyr::arrange()}}\label{solution_arr}}

\begin{itemize}
\tightlist
\item
  Выберите из тиббла \texttt{heroes} колонки \texttt{name}, \texttt{Gender}, \texttt{Height} и отсортируйте строчки \emph{по возрастанию} \texttt{Height}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, Gender, Height) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{arrange}\NormalTok{(Height)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 734 x 3
   name            Gender Height
   <chr>           <chr>   <dbl>
 1 Utgard-Loki     Male     15.2
 2 Bloodwraith     Male     30.5
 3 King Kong       Male     30.5
 4 Anti-Monitor    Male     61  
 5 Giganta         Female   62.5
 6 Krypto          Male     64  
 7 Yoda            Male     66  
 8 Jack-Jack       Male     71  
 9 Howard the Duck Male     79  
10 Godzilla        <NA>    108  
# ... with 724 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите из тиббла \texttt{heroes} колонки \texttt{name}, \texttt{Gender}, \texttt{Height} и отсортируйте строчки \emph{по убыванию} \texttt{Height}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, Gender, Height) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{arrange}\NormalTok{(}\KeywordTok{desc}\NormalTok{(Height))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 734 x 3
   name          Gender Height
   <chr>         <chr>   <dbl>
 1 Fin Fang Foom Male     975 
 2 Galactus      Male     876 
 3 Groot         Male     701 
 4 MODOK         Male     366 
 5 Wolfsbane     Female   366 
 6 Onslaught     Male     305 
 7 Sasquatch     Male     305 
 8 Ymir          Male     305.
 9 Rey           Female   297 
10 Juggernaut    Male     287 
# ... with 724 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выберите из тиббла \texttt{heroes} колонки \texttt{name}, \texttt{Gender}, \texttt{Height} и отсортируйте строчки сначала по \texttt{Gender}, затем \emph{по убыванию} \texttt{Height}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, Gender, Height) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{arrange}\NormalTok{(Gender, }\KeywordTok{desc}\NormalTok{(Height))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 734 x 3
   name      Gender Height
   <chr>     <chr>   <dbl>
 1 Wolfsbane Female    366
 2 Rey       Female    297
 3 Bloodaxe  Female    218
 4 Thundra   Female    218
 5 Hela      Female    213
 6 Frenzy    Female    211
 7 She-Hulk  Female    201
 8 Ardina    Female    193
 9 Starfire  Female    193
10 Valkyrie  Female    191
# ... with 724 more rows
\end{verbatim}

\hypertarget{solution_dist}{%
\section{\texorpdfstring{Уникальные значения: \texttt{dplyr::distinct()}}{Уникальные значения: dplyr::distinct()}}\label{solution_dist}}

\begin{itemize}
\tightlist
\item
  Извлеките уникальные значения столбца \texttt{Eye\ color} из тиббла \texttt{heroes}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{distinct}\NormalTok{(}\StringTok{`}\DataTypeTok{Eye color}\StringTok{`}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 23 x 1
   `Eye color`
   <chr>      
 1 yellow     
 2 blue       
 3 green      
 4 brown      
 5 <NA>       
 6 red        
 7 violet     
 8 white      
 9 purple     
10 black      
# ... with 13 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Извлеките уникальные значения столбца \texttt{Hair\ color} из тиббла \texttt{heroes}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{distinct}\NormalTok{(}\StringTok{`}\DataTypeTok{Hair color}\StringTok{`}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 30 x 1
   `Hair color`
   <chr>       
 1 No Hair     
 2 Black       
 3 Blond       
 4 Brown       
 5 <NA>        
 6 White       
 7 Purple      
 8 Orange      
 9 Pink        
10 Red         
# ... with 20 more rows
\end{verbatim}

\hypertarget{solution_mutate}{%
\section{\texorpdfstring{Создание колонок: \texttt{dplyr::mutate()} и \texttt{dplyr::transmute()}}{Создание колонок: dplyr::mutate() и dplyr::transmute()}}\label{solution_mutate}}

\begin{itemize}
\tightlist
\item
  Создайте колонку \texttt{height\_m} с ростом супергероев в метрах, затем выберите только колонки \texttt{name} и \texttt{height\_m}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{height_m =}\NormalTok{ Height}\OperatorTok{/}\DecValTok{100}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, height_m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 734 x 2
   name          height_m
   <chr>            <dbl>
 1 A-Bomb            2.03
 2 Abe Sapien        1.91
 3 Abin Sur          1.85
 4 Abomination       2.03
 5 Abraxas          NA   
 6 Absorbing Man     1.93
 7 Adam Monroe      NA   
 8 Adam Strange      1.85
 9 Agent 13          1.73
10 Agent Bob         1.78
# ... with 724 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте новою колонку hair в heroes, в которой будет значение ``Bold'' для тех супергероев, у которых в колонке Hair.color стоит ``No Hair'', и значение ``Hairy'' во всех остальных случаях. Затем выберите только колонки \texttt{name}, \texttt{Hair\ color}, \texttt{hair}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair =} \KeywordTok{ifelse}\NormalTok{(}\StringTok{`}\DataTypeTok{Hair color}\StringTok{`} \OperatorTok{==}\StringTok{ "No Hair"}\NormalTok{, }\StringTok{"Bold"}\NormalTok{, }\StringTok{"Hairy"}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(name, }\StringTok{`}\DataTypeTok{Hair color}\StringTok{`}\NormalTok{, hair)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 734 x 3
   name          `Hair color` hair 
   <chr>         <chr>        <chr>
 1 A-Bomb        No Hair      Bold 
 2 Abe Sapien    No Hair      Bold 
 3 Abin Sur      No Hair      Bold 
 4 Abomination   No Hair      Bold 
 5 Abraxas       Black        Hairy
 6 Absorbing Man No Hair      Bold 
 7 Adam Monroe   Blond        Hairy
 8 Adam Strange  Blond        Hairy
 9 Agent 13      Blond        Hairy
10 Agent Bob     Brown        Hairy
# ... with 724 more rows
\end{verbatim}

\hypertarget{solution_group_by}{%
\section{\texorpdfstring{Агрегация: \texttt{dplyr::group\_by()\ \%\textgreater{}\%\ summarise()}}{Агрегация: dplyr::group\_by() \%\textgreater\% summarise()}}\label{solution_group_by}}

\begin{itemize}
\tightlist
\item
  Посчитайте количество супергероев по расам и отсортируйте по убыванию. Извлеките первые 5 строк.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{count}\NormalTok{(Race, }\DataTypeTok{sort =} \OtherTok{TRUE}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{slice}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 5 x 2
  Race              n
  <chr>         <int>
1 <NA>            304
2 Human           208
3 Mutant           63
4 God / Eternal    14
5 Cyborg           11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте средний пост по полу.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{height_mean =} \KeywordTok{mean}\NormalTok{(Height, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 2
  Gender height_mean
  <chr>        <dbl>
1 Female        175.
2 Male          192.
3 <NA>          177.
\end{verbatim}

\hypertarget{solution_across}{%
\section{\texorpdfstring{Операции с несколькими колонками: \texttt{across()}}{Операции с несколькими колонками: across()}}\label{solution_across}}

\begin{itemize}
\tightlist
\item
  Посчитайте количество \texttt{NA} в каждой колонке, группируя по полу (\texttt{Gender}).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{na_n <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x))}
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{everything}\NormalTok{(), na_n))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 11
  Gender    X1  name `Eye color`  Race `Hair color` Height Publisher
  <chr>  <int> <int>       <int> <int>        <int>  <int>     <int>
1 Female     0     0          41    98           38     56         0
2 Male       0     0         121   184          123    147         0
3 <NA>       0     0          10    22           11     14         0
# ... with 3 more variables: `Skin color` <int>, Alignment <int>, Weight <int>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте количество \texttt{NA} в каждой колонке, которая заканчивается на \texttt{"color"}, группируя по полу (\texttt{Gender}).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{na_n <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x))}
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{across}\NormalTok{(}\KeywordTok{ends_with}\NormalTok{(}\StringTok{"color"}\NormalTok{), na_n))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 3 x 4
  Gender `Eye color` `Hair color` `Skin color`
  <chr>        <int>        <int>        <int>
1 Female          41           38          186
2 Male           121          123          449
3 <NA>            10           11           27
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте из тиббла \texttt{heroes} новый тиббл с колонками \texttt{name}, \texttt{Height} и \texttt{Weight}, где для каждого героя содержится значение \texttt{"выше\ среднего"}, если его рост или вес выше среднего по колонке и \texttt{"ниже\ среднего"}, если ниже или равен среднему.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{higher_than_average <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{ifelse}\NormalTok{(x }\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
                                          \StringTok{"выше среднего"}\NormalTok{,}
                                          \StringTok{"ниже среднего"}\NormalTok{)}
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{transmute}\NormalTok{(name, }
            \KeywordTok{across}\NormalTok{(}\KeywordTok{c}\NormalTok{(Height, Weight), }
\NormalTok{                   higher_than_average))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 734 x 3
   name          Height        Weight       
   <chr>         <chr>         <chr>        
 1 A-Bomb        выше среднего выше среднего
 2 Abe Sapien    выше среднего ниже среднего
 3 Abin Sur      ниже среднего ниже среднего
 4 Abomination   выше среднего выше среднего
 5 Abraxas       <NA>          <NA>         
 6 Absorbing Man выше среднего выше среднего
 7 Adam Monroe   <NA>          <NA>         
 8 Adam Strange  ниже среднего ниже среднего
 9 Agent 13      ниже среднего ниже среднего
10 Agent Bob     ниже среднего ниже среднего
# ... with 724 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте из тиббла \texttt{heroes} новый тиббл с колонками \texttt{Gender}, \texttt{name}, \texttt{Height} и \texttt{Weight}, где для каждого героя содержится значение \texttt{"выше\ среднего"}, если его рост или вес выше среднего по колонке и \texttt{"ниже\ среднего"}, если ниже или равен среднему \emph{внутри соответствующей группы по полу}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{transmute}\NormalTok{(name, }
            \KeywordTok{across}\NormalTok{(}\KeywordTok{c}\NormalTok{(Height, Weight), }
\NormalTok{                   higher_than_average))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 734 x 4
# Groups:   Gender [3]
   Gender name          Height        Weight       
   <chr>  <chr>         <chr>         <chr>        
 1 Male   A-Bomb        выше среднего выше среднего
 2 Male   Abe Sapien    ниже среднего ниже среднего
 3 Male   Abin Sur      ниже среднего ниже среднего
 4 Male   Abomination   выше среднего выше среднего
 5 Male   Abraxas       <NA>          <NA>         
 6 Male   Absorbing Man выше среднего ниже среднего
 7 Male   Adam Monroe   <NA>          <NA>         
 8 Male   Adam Strange  ниже среднего ниже среднего
 9 Female Agent 13      ниже среднего ниже среднего
10 Male   Agent Bob     ниже среднего ниже среднего
# ... with 724 more rows
\end{verbatim}

\hypertarget{ux441ux43eux435ux434ux438ux43dux435ux43dux438ux435-ux434ux430ux442ux430ux444ux440ux435ux439ux43cux43eux432-_join-solution_join}{%
\section{Соединение датафреймов: *\_join \{\#solution\_join\}}\label{ux441ux43eux435ux434ux438ux43dux435ux43dux438ux435-ux434ux430ux442ux430ux444ux440ux435ux439ux43cux43eux432-_join-solution_join}}

Создайте тиббл \texttt{web\_creators}, в котором будут супергерои, которые могут плести паутину, т.е. у них стоит \texttt{TRUE} в колонке \texttt{Web\ Creation} в тиббле \texttt{powers}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{powers_web <-}\StringTok{ }\NormalTok{powers }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{select}\NormalTok{(hero_names, }\StringTok{`}\DataTypeTok{Web Creation}\StringTok{`}\NormalTok{)}
\NormalTok{web_creators <-}\StringTok{ }\KeywordTok{left_join}\NormalTok{(heroes, powers_web, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{"name"}\NormalTok{ =}\StringTok{ "hero_names"}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(}\StringTok{`}\DataTypeTok{Web Creation}\StringTok{`}\NormalTok{)}
\NormalTok{web_creators}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 16 x 12
      X1 name  Gender `Eye color` Race  `Hair color` Height Publisher
   <dbl> <chr> <chr>  <chr>       <chr> <chr>         <dbl> <chr>    
 1    33 Anti~ Male   blue        Symb~ Blond           229 Marvel C~
 2    38 Arac~ Female blue        Human Blond           175 Marvel C~
 3   161 Carn~ Male   green       Symb~ Red             185 Marvel C~
 4   335 Hybr~ Male   brown       Symb~ Black           175 Marvel C~
 5   479 Myst~ Male   brown       Human No Hair         180 Marvel C~
 6   580 Scar~ Male   brown       Clone Brown           193 Marvel C~
 7   597 Silk  Female brown       Human Black            NA Marvel C~
 8   620 Spid~ Female blue        Human Brown           170 Marvel C~
 9   621 Spid~ Female blue        Human Blond           165 Marvel C~
10   622 Spid~ Male   hazel       Human Brown           178 Marvel C~
11   623 Spid~ <NA>   red         Human Brown           178 Marvel C~
12   624 Spid~ Male   brown       Human Black           157 Marvel C~
13   673 Toxin Male   blue        Symb~ Brown           188 Marvel C~
14   674 Toxin Male   black       Symb~ Blond           191 Marvel C~
15   689 Venom Male   blue        Symb~ Strawberry ~    191 Marvel C~
16   692 Veno~ Male   <NA>        Symb~ <NA>            226 Marvel C~
# ... with 4 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>,
#   `Web Creation` <lgl>
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите всех супергероев, которые присутствуют в \texttt{heroes}, но отсутствуют в \texttt{powers}. Ответом должен быть строковый вектор с именами супергероев.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{anti_join}\NormalTok{(heroes, powers, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{"name"}\NormalTok{ =}\StringTok{ "hero_names"}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pull}\NormalTok{(name)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "Agent 13"          "Alfred Pennyworth" "Arsenal"          
 [4] "Batgirl III"       "Batgirl V"         "Beetle"           
 [7] "Black Goliath"     "Black Widow II"    "Blaquesmith"      
[10] "Bolt"              "Boomer"            "Box"              
[13] "Box III"           "Captain Mar-vell"  "Cat II"           
[16] "Cecilia Reyes"     "Clea"              "Clock King"       
[19] "Colin Wagner"      "Colossal Boy"      "Corsair"          
[22] "Cypher"            "Danny Cooper"      "Darkside"         
[25] "ERG-1"             "Fixer"             "Franklin Storm"   
[28] "Giant-Man"         "Giant-Man II"      "Goliath"          
[31] "Goliath"           "Goliath"           "Guardian"         
[34] "Hawkwoman"         "Hawkwoman II"      "Hawkwoman III"    
[37] "Howard the Duck"   "Jack Bauer"        "Jesse Quick"      
[40] "Jessica Sanders"   "Jigsaw"            "Jyn Erso"         
[43] "Kid Flash II"      "Kingpin"           "Meteorite"        
[46] "Mister Zsasz"      "Mogo"              "Moloch"           
[49] "Morph"             "Nite Owl II"       "Omega Red"        
[52] "Paul Blart"        "Penance"           "Penance I"        
[55] "Plastic Lad"       "Power Man"         "Renata Soliz"     
[58] "Ronin"             "Shrinking Violet"  "Snake-Eyes"       
[61] "Spider-Carnage"    "Spider-Woman II"   "Stacy X"          
[64] "Thunderbird II"    "Two-Face"          "Vagabond"         
[67] "Vision II"         "Vulcan"            "Warbird"          
[70] "White Queen"       "Wiz Kid"           "Wondra"           
[73] "Wyatt Wingfoot"    "Yellow Claw"      
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите всех супергероев, которые присутствуют в \texttt{powers}, но отсутствуют в \texttt{heroes}. Ответом должен быть строковый вектор с именами супергероев.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{anti_join}\NormalTok{(powers, heroes, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{"hero_names"}\NormalTok{ =}\StringTok{ "name"}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pull}\NormalTok{(hero_names)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 [1] "3-D Man"           "Bananaman"         "Bizarro-Girl"     
 [4] "Black Vulcan"      "Blue Streak"       "Bradley"          
 [7] "Clayface"          "Concrete"          "Dementor"         
[10] "Doctor Poison"     "Fire"              "Hellgramite"      
[13] "Lara Croft"        "Little Epic"       "Lord Voldemort"   
[16] "Orion"             "Peek-a-Boo"        "Queen Hippolyta"  
[19] "Reactron"          "SHDB"              "Stretch Armstrong"
[22] "TEST"              "Tommy Clarke"      "Tyrant"           
\end{verbatim}

\hypertarget{solution_join}{%
\section{Tidy data}\label{solution_join}}

\begin{itemize}
\tightlist
\item
  Для начала создайте тиббл \texttt{heroes\_weight}, скопировав код:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes_weight <-}\StringTok{ }\NormalTok{heroes }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(Publisher }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"DC Comics"}\NormalTok{, }\StringTok{"Marvel Comics"}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(Gender, Publisher) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{weight_mean =} \KeywordTok{mean}\NormalTok{(Weight, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{drop_na}\NormalTok{()}
\NormalTok{heroes_weight }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 4 x 3
# Groups:   Gender [2]
  Gender Publisher     weight_mean
  <chr>  <chr>               <dbl>
1 Female DC Comics            76.8
2 Female Marvel Comics        80.1
3 Male   DC Comics           113. 
4 Male   Marvel Comics       134. 
\end{verbatim}

\begin{quote}
Функция \texttt{drop\_na()} позволяет выбросить все строчки, в которых встречается \texttt{NA}.
\end{quote}

\begin{itemize}
\tightlist
\item
  Превратите тиббл \texttt{heroes\_weight} в широкий тиббл:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes_weight }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pivot_wider}\NormalTok{(}\DataTypeTok{names_from =} \StringTok{"Publisher"}\NormalTok{, }\DataTypeTok{values_from =} \StringTok{"weight_mean"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 2 x 3
# Groups:   Gender [2]
  Gender `DC Comics` `Marvel Comics`
  <chr>        <dbl>           <dbl>
1 Female        76.8            80.1
2 Male         113.            134. 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Затем превратите его обратно в длинный тиббл:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes_weight }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pivot_wider}\NormalTok{(}\DataTypeTok{names_from =} \StringTok{"Publisher"}\NormalTok{, }\DataTypeTok{values_from =} \StringTok{"weight_mean"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pivot_longer}\NormalTok{(}\DataTypeTok{cols =} \OperatorTok{!}\NormalTok{Gender,}
               \DataTypeTok{names_to =} \StringTok{"Publisher"}\NormalTok{,}
               \DataTypeTok{values_to =} \StringTok{"weight_mean"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 4 x 3
# Groups:   Gender [2]
  Gender Publisher     weight_mean
  <chr>  <chr>               <dbl>
1 Female DC Comics            76.8
2 Female Marvel Comics        80.1
3 Male   DC Comics           113. 
4 Male   Marvel Comics       134. 
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сделайте \texttt{powers} длинным тибблом с тремя колонками: \texttt{hero\_names}, \texttt{power} (названгие суперсилы) и \texttt{has} (наличие суперсилы у данного супергероя).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{powers }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pivot_longer}\NormalTok{(}\DataTypeTok{cols =} \OperatorTok{!}\NormalTok{hero_names,}
               \DataTypeTok{names_to =} \StringTok{"power"}\NormalTok{,}
               \DataTypeTok{values_to =} \StringTok{"has"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 111,389 x 3
   hero_names power                 has  
   <chr>      <chr>                 <lgl>
 1 3-D Man    Agility               TRUE 
 2 3-D Man    Accelerated Healing   FALSE
 3 3-D Man    Lantern Power Ring    FALSE
 4 3-D Man    Dimensional Awareness FALSE
 5 3-D Man    Cold Resistance       FALSE
 6 3-D Man    Durability            FALSE
 7 3-D Man    Stealth               FALSE
 8 3-D Man    Energy Absorption     FALSE
 9 3-D Man    Flight                FALSE
10 3-D Man    Danger Sense          FALSE
# ... with 111,379 more rows
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сделайте тиббл \texttt{powers} обратно широким, но с новой структурой: каждая строчка означает суперсилу, а каждая колонка - супергероя (за исключением первой колонки - названия суперсилы).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{powers }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pivot_longer}\NormalTok{(}\DataTypeTok{cols =} \OperatorTok{!}\NormalTok{hero_names,}
               \DataTypeTok{names_to =} \StringTok{"power"}\NormalTok{,}
               \DataTypeTok{values_to =} \StringTok{"has"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pivot_wider}\NormalTok{(}\DataTypeTok{names_from =}\NormalTok{ hero_names,}
              \DataTypeTok{values_from =}\NormalTok{ has)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
# A tibble: 167 x 668
   power `3-D Man` `A-Bomb` `Abe Sapien` `Abin Sur` Abomination Abraxas
   <chr> <lgl>     <lgl>    <lgl>        <lgl>      <lgl>       <lgl>  
 1 Agil~ TRUE      FALSE    TRUE         FALSE      FALSE       FALSE  
 2 Acce~ FALSE     TRUE     TRUE         FALSE      TRUE        FALSE  
 3 Lant~ FALSE     FALSE    FALSE        TRUE       FALSE       FALSE  
 4 Dime~ FALSE     FALSE    FALSE        FALSE      FALSE       TRUE   
 5 Cold~ FALSE     FALSE    TRUE         FALSE      FALSE       FALSE  
 6 Dura~ FALSE     TRUE     TRUE         FALSE      FALSE       FALSE  
 7 Stea~ FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  
 8 Ener~ FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  
 9 Flig~ FALSE     FALSE    FALSE        FALSE      FALSE       TRUE   
10 Dang~ FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  
# ... with 157 more rows, and 661 more variables: `Absorbing Man` <lgl>, `Adam
#   Monroe` <lgl>, `Adam Strange` <lgl>, `Agent Bob` <lgl>, `Agent Zero` <lgl>,
#   `Air-Walker` <lgl>, Ajax <lgl>, `Alan Scott` <lgl>, `Alex Mercer` <lgl>,
#   `Alex Woolsly` <lgl>, Alien <lgl>, `Allan Quatermain` <lgl>, Amazo <lgl>,
#   Ammo <lgl>, `Ando Masahashi` <lgl>, Angel <lgl>, `Angel Dust` <lgl>, `Angel
#   Salvadore` <lgl>, Angela <lgl>, `Animal Man` <lgl>, Annihilus <lgl>,
#   `Ant-Man` <lgl>, `Ant-Man II` <lgl>, `Anti-Monitor` <lgl>,
#   `Anti-Spawn` <lgl>, `Anti-Venom` <lgl>, Apocalypse <lgl>, Aquababy <lgl>,
#   Aqualad <lgl>, Aquaman <lgl>, Arachne <lgl>, Archangel <lgl>,
#   Arclight <lgl>, Ardina <lgl>, Ares <lgl>, Ariel <lgl>, Armor <lgl>, `Astro
#   Boy` <lgl>, Atlas <lgl>, Atom <lgl>, `Atom Girl` <lgl>, `Atom II` <lgl>,
#   `Atom III` <lgl>, `Atom IV` <lgl>, Aurora <lgl>, Azazel <lgl>,
#   Azrael <lgl>, Aztar <lgl>, Bananaman <lgl>, Bane <lgl>, Banshee <lgl>,
#   Bantam <lgl>, Batgirl <lgl>, `Batgirl IV` <lgl>, `Batgirl VI` <lgl>,
#   Batman <lgl>, `Batman II` <lgl>, Battlestar <lgl>, `Batwoman V` <lgl>,
#   Beak <lgl>, Beast <lgl>, `Beast Boy` <lgl>, `Ben 10` <lgl>, `Beta Ray
#   Bill` <lgl>, Beyonder <lgl>, `Big Barda` <lgl>, `Big Daddy` <lgl>, `Big
#   Man` <lgl>, `Bill Harken` <lgl>, `Billy Kincaid` <lgl>, Binary <lgl>,
#   `Bionic Woman` <lgl>, `Bird-Brain` <lgl>, `Bird-Man` <lgl>, `Bird-Man
#   II` <lgl>, Birdman <lgl>, Bishop <lgl>, Bizarro <lgl>,
#   `Bizarro-Girl` <lgl>, `Black Abbott` <lgl>, `Black Adam` <lgl>, `Black
#   Bolt` <lgl>, `Black Canary` <lgl>, `Black Cat` <lgl>, `Black Flash` <lgl>,
#   `Black Knight III` <lgl>, `Black Lightning` <lgl>, `Black Mamba` <lgl>,
#   `Black Manta` <lgl>, `Black Panther` <lgl>, `Black Vulcan` <lgl>, `Black
#   Widow` <lgl>, Blackout <lgl>, Blackwing <lgl>, Blackwulf <lgl>,
#   Blade <lgl>, `Bling!` <lgl>, Blink <lgl>, Blizzard <lgl>, `Blizzard
#   II` <lgl>, ...
\end{verbatim}

  \bibliography{bibliography.bib}

\end{document}
