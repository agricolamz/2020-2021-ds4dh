[["index.html", "Наука о данных в R для программы Цифровых гуманитарных исследований 1 О курсе", " Наука о данных в R для программы Цифровых гуманитарных исследований Г. А. Мороз, И. С. Поздняков 1 О курсе Материалы для курса Наука о данных для магистерской программы Цифровых гуманитарные исследования НИУ ВШЭ. "],["intro.html", "2 Введение в R 2.1 Наука о данных 2.2 Установка R и RStudio 2.3 Полезные ссылки 2.4 Rstudio 2.5 Введение в R 2.6 Логические операторы 2.7 Типы данных 2.8 Вектор 2.9 Матрицы (matrix) 2.10 Списки (list) 2.11 Датафрейм", " 2 Введение в R 2.1 Наука о данных Наука о данных — это новая область знаний, которая активно развивается в последнее время. Она находиться на пересечении компьютерных наук, статистики и математики, и трудно сказать, действительно ли это наука. При этом это движение развивается в самых разных научных направлениях, иногда даже оформляясь в отдельную отрасль: биоинформатика вычислительная криминалистика цифровые гуманитарные исследования датажурналистика … Все больше книг “Data Science for …”: psychologists (Hansjörg 2019) immunologists (Thomas and Pallett 2019) business (Provost and Fawcett 2013) public policy (Brooks and Cooper 2013) fraud detection (Baesens, Van Vlasselaer, and Verbeke 2015) … Среди умений датасаентистов можно перечислить следующие: сбор и обработка данных трансформация данных визуализация данных статистическое моделирование данных представление полученных результатов организация всей работы воспроизводимым способом Большинство этих тем в той или иной мере будет представлено в нашем курсе. 2.2 Установка R и RStudio В данной книге используется исключительно R (R Core Team 2019), так что для занятий понадобятся: R на Windows на Mac на Linux, также можно добавить зеркало и установить из командной строки: sudo apt-get install r-cran-base RStudio — IDE для R (можно скачать здесь) и некоторые пакеты на R Часто можно увидеть или услышать, что R — язык программирования для “статистической обработки данных.” Изначально это, конечно, было правдой, но уже давно R — это полноценный язык программирования, который при помощи своих пакетов позволяет решать огромный спектр задач. В данной книге используется следующая версия R: ## [1] &quot;R version 4.1.0 (2021-05-18)&quot; Некоторые люди не любят устанавливать лишние программы себе на компьютер, несколько вариантов есть и для них: RStudio cloud — полная функциональность RStudio, пока бесплатная, но скоро это исправят; RStudio on rollApp — облачная среда, позволяющая разворачивать программы. Первый и вполне закономерный вопрос: зачем мы ставили R и отдельно еще какой-то RStudio? Если опустить незначительные детали, то R — это сам язык программирования, а RStudio — это среда (IDE), которая позволяет в этом языке очень удобно работать. 2.3 Полезные ссылки В интернете легко найти документацию и туториалы по самым разным вопросам в R, так что главный залог успеха — грамотно пользоваться поисковиком, и лучше на английском языке. книга (Wickham and Grolemund 2016) является достаточно сильной альтернативой всему курсу stackoverflow — сервис, где достаточно быстро отвечают на любые вопросы (не обязательно по R) RStudio community — быстро отвечают на вопросы, связанные с R русский stackoverflow R-bloggers — сайт, где собираются новинки, связанные с R чат, где можно спрашивать про R на русском (но почитайте правила чата, перед тем как спрашивать) чат по визуализации данных, чат датажурналистов канал про визуализацию, дата-блог “Новой газеты”, … 2.4 Rstudio Когда вы откроете RStudio первый раз, вы увидите три панели: консоль, окружение и историю, а также панель для всего остального. Если ткнуть в консоли на значок уменьшения, то можно открыть дополнительную панель, где можно писать скрипт. Существуют разные типы пользователей: одни любят работать в консоли (на картинке это 2 — R Console), другие предпочитают скрипты (1 — Code Editor). Консоль позволяет использовать интерактивный режим команда-ответ, а скрипт является по сути текстовым документом, фрагменты которого можно для отладки запускать в консоли. 3 — Workspace and History: Здесь можно увидеть переменные. Это поле будет автоматически обновляться по мере того, как Вы будете запускать строчки кода и создавать новые переменные. Еще там есть вкладка с историей последних команд, которые были запущены. 4 — Plots and files: Здесь есть очень много всего. Во-первых, небольшой файловый менеджер, во-вторых, там будут появляться графики, когда вы будете их рисовать. Там же есть вкладка с вашими пакетами (Packages) и Help по функциям. Но об этом потом. 2.5 Введение в R 2.5.1 R как калькулятор Ой-ей, консоль, скрипт че-то все непонятно. Давайте начнем с самого простого и попробуем использовать R как простой калькулятор. +, -, *, /, ^ (степень), () и т.д. Просто запускайте в консоли пока не надоест: 40 + 2 ## [1] 42 3 - 2 ## [1] 1 5 * 6 ## [1] 30 99 / 9 ## [1] 11 2 ^ 3 ## [1] 8 (2 + 2) * 2 ## [1] 8 Ничего сложного, верно? Вводим выражение и получаем результат. Порядок выполнения арифметических операций как в математике, так что не забывайте про скобочки. Подсказку по порядку выполнения операций в R можно получить с помощью следующей команды: ?Syntax Если Вы не уверены в том, какие операции имеют приоритет, то используйте скобочки, чтобы точно обозначить, в каком порядке нужно производить операции. 2.5.2 Функции Давайте теперь извлечем корень из какого-нибудь числа. В принципе, тем, кто помнит школьный курс математики, возведения в степень вполне достаточно: 16 ^ 0.5 ## [1] 4 Ну а если нет, то можете воспользоваться специальной функцией: это обычно какие-то буквенные символы с круглыми скобками сразу после названия функции. Мы подаем на вход (внутрь скобочек) какие-то данные, внутри этих функций происходят какие-то вычисления, которые выдают в ответ какие-то другие данные (или же функция записывает файл, рисует график и т.д.). Данные на входе называются аргументом функции, а иногда — параметром функции. В обыденной речи часто говорят инпут (калька с английского input). Вот, например, функция для корня: sqrt(16) ## [1] 4 R — case-sensitive язык, т.е. регистр важен. SQRT(16) не будет работать. А вот так выглядит функция логарифма: log(8) ## [1] 2.079442 Так, вроде бы все нормально, но… Если Вы еще что-то помните из школьной математики, то должны понимать, что что-то здесь не так. Здесь не хватает основания логарифма! Логарифм — показатель степени, в которую надо возвести число, называемое основанием, чтобы получить данное число. То есть у логарифма 8 по основанию 2 будет значение 3: \\(\\log_2 8 = 3\\) То есть если возвести 2 в степень 3 у нас будет 8: \\(2^3 = 8\\) Только наша функция считает все как-то не так. Чтобы понять, что происходит, нам нужно залезть в хэлп этой функции: ?log Справа внизу в RStudio появится вот такое окно: Действительно, у этой функции есть еще аргумент base =. По умолчанию он равен числу Эйлера (2.7182818…), т.е. функция считает натуральный логарифм. В большинстве функций R есть какой-то основной инпут — данные в том или ином формате, а есть и дополнительные параметры, которые можно прописывать вручную, если параметры по умолчанию вас не устраивают. log(x = 8, base = 2) ## [1] 3 …или просто (если Вы уверены в порядке аргументов): log(8, 2) ## [1] 3 Более того, Вы можете использовать результат выполнения одних функций в качестве аргумента для других: log(8, sqrt(4)) ## [1] 3 Если эксплицитно писать имена аргументов, то их порядок в функции не важен: log(base = 2, x = 8) ## [1] 3 А еще можно недописывать имена аргументов, если они не совпадают с другими: log(b = 2, x = 8) ## [1] 3 Мы еще много раз будем возвращаться к функциям. Вообще, функции — это одна из важнейших штук в R (примерно так же как и в Python). Мы будем создавать свои функции, использовать функции как инпут для функций и многое-многое другое. В R очень крутые возможности работы с функциями. Поэтому подружитесь с функциями, они клевые. Арифметические знаки, которые мы использовали: +,-,/,^ и т.д. называются операторами и на самом деле тоже являются функциями: &#39;+&#39;(3,4) ## [1] 7 2.5.3 Переменные Важная штука в программировании на практически любом языке — возможность сохранять значения в переменных. В R это обычно делается с помощью вот этих символов: &lt;- (но можно использовать и обычное =, хотя это не очень принято). Для этого есть удобное сочетание клавиш: нажмите одновременно Alt - (или option - на Маке). a &lt;- 2 a ## [1] 2 Справа от &lt;- находится значение, которое вы хотите сохранить, или же какое-то выражение, результат которого вы хотите сохранить в эту переменную1: a &lt;- log(9, 3) Слева от &lt;- находится название будущей переменной. Название переменных может быть самым разным. Есть несколько ограничений для синтаксически валидных имен переменных: они должны включать в себя буквы, цифры, . или _, начинаться на букву (или точку, за которой не будет следовать цифра), не должны совпадать с коротким списком зарезервированных слов. Короче говоря, название не должно включать в себя пробелы и большинство других знаков. Нельзя: - new variable - _new_variable - .1var - v-r Можно: - new_variable - .new.variable - var_2 Обязательно делайте названия переменных осмысленными! Старайтесь делать при этом их понятными и короткими, это сохранит вам очень много времени, когда вы (или кто-то еще) будете пытаться разобраться в написанном ранее коде. Если название все-таки получается длинным и состоящим из нескольких слов, то лучше всего использовать нижнее подчеркивание в качестве разделителя: some_variable2. После присвоения переменная появляется во вкладке Environment в RStudio: Можно использовать переменные в функциях и просто вычислениях: b &lt;- a ^ a + a * a b ## [1] 8 log(b, a) ## [1] 3 2.6 Логические операторы Вы можете сравнивать разные переменные: a == b ## [1] FALSE Заметьте, что сравнивая две переменные мы используем два знака равно ==, а не один =. Иначе это будет означать присвоение. a = b #присвоение, а не сравнение! a ## [1] 8 b ## [1] 8 Теперь Вы сможете понять комикс про восстание роботов на следующей странице (пусть он и совсем про другой язык программирования) Этот комикс объясняет, как важно не путать присваивание и сравнение (хотя я иногда путаю до сих пор =( ). Иногда нам нужно проверить на неравенство: a &lt;- 2 b &lt;- 3 a == b ## [1] FALSE a != b ## [1] TRUE Восклицательный язык в программировании вообще и в R в частности стандартно означает отрицание. Еще мы можем сравнивать на больше/меньше: a &gt; b ## [1] FALSE a &lt; b ## [1] TRUE a &gt;= b ## [1] FALSE a &lt;= b ## [1] TRUE Этим мы будем пользоваться в дальнейшем регулярно! Именно на таких простых логических операциях построено большинство операций с данными. 2.7 Типы данных До этого момента мы работали только с числами (numeric): class(a) ## [1] &quot;numeric&quot; На самом деле, в R три типа numeric: integer (целые), double (дробные), complex (комплексные числа)3. R сам будет конвертировать числа в нужный тип numeric при необходимости, поэтому этим можно не заморачиваться. Если же все-таки нужно задать конкретный тип числа эксплицитно, то можно воспользоваться функциями as.integer(), as.double() и as.complex(). Кроме того, при создании числа можно поставить в конце L, чтобы обозначить число как integer: is.integer(5) ## [1] FALSE is.integer(5L) ## [1] TRUE Про double есть еще один маленький секрет. Дело в том, что дробные числа хранятся в R как числа с плавающей запятой двойной точности. Дробные числа в компьютере могут быть записаны только с определенной степенью точности, поэтому иногда встречаются вот такие вот ситуации: sqrt(2)^2 == 2 ## [1] FALSE Это довольно стандартная ситуация, характерная не только для R. Чтобы ее избежать, можно воспользоваться функцией all.equal(): all.equal(sqrt(2)^2, 2) ## [1] TRUE Теперь же нам нужно ознакомиться с двумя другими важными типами данных в R: character: строки символов. Они должны выделяться кавычками. s &lt;- &#39;Всем привет!&#39; s ## [1] &quot;Всем привет!&quot; class(s) ## [1] &quot;character&quot; Можно использовать как \", так и ' (что удобно, когда строчка внутри уже содержит какие-то кавычки). &quot;Ph&#39;nglui mglw&#39;nafh Cthulhu R&#39;lyeh wgah&#39;nagl fhtagn&quot; ## [1] &quot;Ph&#39;nglui mglw&#39;nafh Cthulhu R&#39;lyeh wgah&#39;nagl fhtagn&quot; logical: просто TRUE или FALSE. t1 &lt;- TRUE f1 &lt;- FALSE t1 ## [1] TRUE f1 ## [1] FALSE Вообще, можно еще писать T и F (но не True и False!). t2 &lt;- T f2 &lt;- F Это дурная практика, так как R защищает от перезаписи переменные TRUE и FALSE, но не защищает от этого T и F. TRUE &lt;- FALSE ## Error in TRUE &lt;- FALSE: invalid (do_set) left-hand side to assignment TRUE ## [1] TRUE T &lt;- FALSE T ## [1] FALSE Мы уже встречались с логическими значениями при сравнении двух числовых переменных. Теперь вы можете догадаться, что результаты сравнения, например, числовых или строковых переменных, можно тоже сохранять в переменные! comparison &lt;- a == b comparison ## [1] FALSE Это нам очень понадобится, когда мы будем работать с реальными данными: нам нужно будет постоянно вытаскивать какие-то данные из датасета, что как раз и построено на игре со сравнением переменных. Чтобы этим хорошо уметь пользоваться, нам нужно еще освоить как работать с логическими операторами. Про один мы немного уже говорили — это логическое НЕ (!). ! превращает TRUE в FALSE, а FALSE в TRUE: t1 ## [1] TRUE !t1 ## [1] FALSE !!t1 #Двойное отрицание! ## [1] TRUE Еще есть логическое И (выдаст TRUE только в том случае если обе переменные TRUE): t1 &amp; t2 ## [1] TRUE t1 &amp; f1 ## [1] FALSE А еще логическое ИЛИ (выдаст TRUE в случае если хотя бы одна из переменных TRUE): t1 | f1 ## [1] TRUE f1 | f2 ## [1] FALSE Если кому-то вдруг понадобится другое ИЛИ (строгое ЛИБО) — есть функция xor(), принимающая два аргумента. Итак, мы только что разобрались с самой занудной (хотя и важной) частью - с основными типа данных в R и как с ними работать4. Пора переходить к чему-то более интересному и специфическому для R. Вперед к ВЕКТОРАМ! 2.8 Вектор Если у вас не было линейной алгебры (или у вас с ней было все плохо), то просто запомните, что вектор (или atomic vector или atomic) — это набор (столбик) чисел в определенном порядке. Если вы привыкли из школьного курса физики считать вектора стрелочками, то не спешите возмущаться и паниковать. Представьте стрелочки как точки из нуля координат {0,0} до какой-то точки на координатной плоскости, например, {2,3}: Вот последние два числа и будем считать вектором. Попытайтесь теперь мысленно стереть координатную плоскость и выбросить стрелочки из головы, оставив только последовательность чисел {2,3}: На самом деле, мы уже работали с векторами в R, но, возможно, вы об этом даже не догадывались. Дело в том, что в R нет как таковых “значений,” есть вектора длиной 1. Такие дела! Чтобы создать вектор из нескольких значений, нужно воспользоваться функцией c(): c(4, 8, 15, 16, 23, 42) ## [1] 4 8 15 16 23 42 c(&quot;Хэй&quot;, &quot;Хэй&quot;, &quot;Ха&quot;) ## [1] &quot;Хэй&quot; &quot;Хэй&quot; &quot;Ха&quot; Одна из самых мерзких и раздражающих причин ошибок в коде — это использование с из кириллицы вместо c из латиницы. Видите разницу? И я не вижу. А R видит. И об этом сообщает: с(3, 4, 5) ## Error in с(3, 4, 5): could not find function &quot;с&quot; Для создания числовых векторов есть удобный оператор : 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 5:-3 ## [1] 5 4 3 2 1 0 -1 -2 -3 Этот оператор создает вектор от первого числа до второго с шагом 1. Вы не представляете, как часто эта штука нам пригодится… Если же нужно сделать вектор с другим шагом, то есть функция seq(): seq(10, 100, by = 10) ## [1] 10 20 30 40 50 60 70 80 90 100 Кроме того, можно задавать не шаг, а длину вектора. Тогда шаг функция seq() посчитает сама: seq(1, 13, length.out = 4) ## [1] 1 5 9 13 Другая функция — rep() — позволяет создавать вектора с повторяющимися значениями. Первый аргумент — значение, которое нужно повторять, а второй аргумент — сколько раз повторять. rep(1, 5) ## [1] 1 1 1 1 1 И первый, и второй аргумент могут быть векторами! rep(1:3, 3) ## [1] 1 2 3 1 2 3 1 2 3 rep(1:3, 1:3) ## [1] 1 2 2 3 3 3 Еще можно объединять вектора (что мы, по сути, и делали, просто с векторами длиной 1): v1 &lt;- c(&quot;Hey&quot;, &quot;Ho&quot;) v2 &lt;- c(&quot;Let&#39;s&quot;, &quot;Go!&quot;) c(v1, v2) ## [1] &quot;Hey&quot; &quot;Ho&quot; &quot;Let&#39;s&quot; &quot;Go!&quot; 2.8.1 Приведение типов Что будет, если вы объедините два вектора с значениями разных типов? Ошибка? Мы уже обсуждали, что в atomic может быть только один тип данных. В некоторых языках программирования при операции с данными разных типов мы бы получили ошибку. А вот в R при несовпадении типов пройзойдет попытка привести типы к “общему знаменателю,” то есть конвертировать данные в более “широкий” тип. Например: c(FALSE, 2) ## [1] 0 2 FALSE превратился в 0 (а TRUE превратился бы в 1), чтобы оба значения можно было объединить в вектор. То же самое произошло бы в случае операций с векторами: 2 + TRUE ## [1] 3 Это называется неявным приведением типов (implicit coercion). Вот более сложный пример: c(TRUE, 3, &quot;Привет&quot;) ## [1] &quot;TRUE&quot; &quot;3&quot; &quot;Привет&quot; У R есть иерархия приведения типов: NULL &lt; raw &lt; logical &lt; integer &lt; double &lt; complex &lt; character &lt; list &lt; expression. Мы из этого списка еще многого не знаем, сейчас важно запомнить, что логические данные — TRUE и FALSE — превращаются в 0 и 1 соответственно, а 0 и 1 в строчки \"0\" и \"1\". Если Вы боитесь полагаться на приведение типов, то можете воспользоваться функциями as.нужныйтипданных для явного приведения типов (explicit coercion): as.numeric(c(T, F, F)) ## [1] 0 0 0 as.character(as.numeric(c(T, F, F))) ## [1] &quot;0&quot; &quot;0&quot; &quot;0&quot; Можно превращать и обратно, например, строковые значения в числовые. Если среди числа встретится буква или другой неподходящий знак, то мы получим предупреждение NA — пропущенное значение (мы очень скоро научимся с ними работать). as.numeric(c(&quot;1&quot;, &quot;2&quot;, &quot;три&quot;)) ## Warning: NAs introduced by coercion ## [1] 1 2 NA Один из распространенных примеров использования неявного приведения типов — использования функций sum() и mean() для подсчета в логическом векторе количества и доли TRUE соответсвенно. Мы будем много раз пользоваться этим приемом в дальнейшем! 2.8.2 Векторизация Все те арифметические операторы, что мы использовали ранее, можно использовать с векторами одинаковой длины: n &lt;- 1:4 m &lt;- 4:1 n + m ## [1] 5 5 5 5 n - m ## [1] -3 -1 1 3 n * m ## [1] 4 6 6 4 n / m ## [1] 0.2500000 0.6666667 1.5000000 4.0000000 n ^ m + m * (n - m) ## [1] -11 5 11 7 Если применить операторы на двух векторах одинаковой длины, то мы получим результат поэлементного применения оператора к двум векторам. Это называется векторизацией (vectorization). Если после какого-нибудь MATLAB Вы привыкли, что по умолчанию операторы работают по правилам линейной алгебры и m*n будет давать скалярное произведение (dot product), то снова нет. Для скалярного произведения нужно использовать операторы с % по краям: n %*% m ## [,1] ## [1,] 20 Абсолютно так же и с операциями с матрицами в R, хотя про матрицы будет немного позже. В принципе, большинство функций в R, которые работают с отдельными значениями, так же хорошо работают и с целыми векторами. Скажем, Вы хотите извлечь корень из нескольких чисел, для этого не нужны никакие циклы (как это обычно делается в других языках программирования). Можно просто “скормить” вектор функции и получить результат применения функции к каждому элементу вектора: sqrt(1:10) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 Таких векторизованных функций в R очень много. Многие из них написаны на более низкоуровневых языках программирования (C, C++, FORTRAN), за счет чего использование таких функций приводит не только к более элегантному, лаконичному, но и к более быстрому коду. Векторизация в R — это очень важная фишка, которая отличает этот язык программирования от многих других. Если вы уже имеете опыт программирования на другом языке, то вам во многих задачах захочется использовать циклы типа for и while 4.2. Не спешите этого делать! В очень многих случаях циклы можно заменить векторизацией. Тем не менее, векторизация — это не единственный способ избавить от циклов типа for и while 5.5.1. 2.8.3 Ресайклинг Допустим мы хотим совершить какую-нибудь операцию с двумя векторами. Как мы убедились, с этим обычно нет никаких проблем, если они совпадают по длине. А что если вектора не совпадают по длине? Ничего страшного! Здесь будет работать правило ресайклинга (правило переписывания, recycling rule). Это означает, что если мы делаем операцию на двух векторах разной длины, то если короткий вектор кратен по длине длинному, короткий вектор будет повторяться необходимое количество раз: n &lt;- 1:4 m &lt;- 1:2 n * m ## [1] 1 4 3 8 А что будет, если совершать операции с вектором и отдельным значением? Можно считать это частным случаем ресайклинга: короткий вектор длиной 1 будет повторятся столько раз, сколько нужно, чтобы он совпадал по длине с длинным: n * 2 ## [1] 2 4 6 8 Если же меньший вектор не кратен большему (например, один из них длиной 3, а другой длиной 4), то R посчитает результат, но выдаст предупреждение. n + c(3,4,5) ## Warning in n + c(3, 4, 5): longer object length is not a multiple of shorter ## object length ## [1] 4 6 8 7 Проблема в том, что эти предупреждения могут в неожиданный момент стать причиной ошибок. Поэтому не стоит полагаться на ресайклинг некратных по длине векторов. См. здесь. А вот ресайклинг кратных по длине векторов — это очень удобная штука, которая используется очень часто. 2.8.4 Индексирование векторов Итак, мы подошли к одному из самых сложных моментов. И одному из основных. От того, как хорошо вы научись с этим работать, зависит весь Ваш дальнейший успех на R-поприще! Речь пойдет об индексировании векторов. Задача, которую Вам придется решать каждые пять минут работы в R - как выбрать из вектора (или же списка, матрицы и датафрейма) какую-то его часть. Для этого используются квадратные скобочки [] (не круглые - они для функций!). Самое простое - индексировать по номеру индекса, т.е. порядку значения в векторе. n &lt;- 1:10 n[1] ## [1] 1 n[10] ## [1] 10 Если вы знакомы с другими языками программирования (не MATLAB, там все так же) и уже научились думать, что индексация с 0 — это очень удобно и очень правильно (ну или просто свыклись с этим), то в R Вам придется переучиться обратно. Здесь первый индекс — это 1, а последний равен длине вектора — ее можно узнать с помощью функции length(). С обоих сторон индексы берутся включительно. С помощью индексирования можно не только вытаскивать имеющиеся значения в векторе, но и присваивать им новые: n[3] &lt;- 20 n ## [1] 1 2 20 4 5 6 7 8 9 10 Конечно, можно использовать целые векторы для индексирования: n[4:7] ## [1] 4 5 6 7 n[10:1] ## [1] 10 9 8 7 6 5 4 20 2 1 Индексирование с минусом выдаст вам все значения вектора кроме выбранных: n[-1] ## [1] 2 20 4 5 6 7 8 9 10 n[c(-4, -5)] ## [1] 1 2 20 6 7 8 9 10 Минус здесь “выключает” выбранные значения из вектора, а не означает отсчет с конца как в Python. Более того, можно использовать логический вектор для индексирования. В этом случае нужен логический вектор такой же длины: n[c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)] ## [1] 1 20 5 7 9 Логический вектор работает здесь как фильтр: пропускает только те значения, где на соответствующей позиции в логическом векторе для индексирования содержится TRUE, и не пропускает те значения, где на соответствующей позиции в логическом векторе для индексирования содержится FALSE. Ну а если эти два вектора (исходный вектор и логический вектор индексов) не равны по длине, то тут будет снова работать правило ресайклинга! n[c(TRUE, FALSE)] #то же самое - recycling rule! ## [1] 1 20 5 7 9 Есть еще один способ индексирования векторов, но он несколько более редкий: индексирование по имени. Дело в том, что для значений векторов можно (но не обязательно) присваивать имена: my_named_vector &lt;- c(first = 1, second = 2, third = 3) my_named_vector[&#39;first&#39;] ## first ## 1 А еще можно “вытаскивать” имена из вектора с помощью функции names() и присваивать таким образом новые имена. d &lt;- 1:4 names(d) &lt;- letters[1:4] d[&quot;a&quot;] ## a ## 1 letters - это “зашитая” в R константа - вектор букв от a до z. Иногда это очень удобно! Кроме того, есть константа LETTERS - то же самое, но заглавными буквами. А еще в R есть названия месяцев на английском и числовая константа pi. Теперь посчитаем среднее вектора n: mean(n) ## [1] 7.2 А как вытащить все значения, которые больше среднего? Сначала получим логический вектор — какие значения больше среднего: larger &lt;- n &gt; mean(n) larger ## [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE А теперь используем его для индексирования вектора n: n[larger] ## [1] 20 8 9 10 Можно все это сделать в одну строчку: n[n&gt;mean(n)] ## [1] 20 8 9 10 Предыдущая строчка отражает то, что мы будем постоянно делать в R: вычленять (subset) из данных отдельные куски на основании разных условий. 2.8.5 NA — пропущенные значения В реальных данных у нас часто чего-то не хватает. Например, из-за технической ошибки или невнимательности не получилось записать какое-то измерение. Для обозначения пропущенных значений в R есть специальное значение NA. NA — это не строка \"NA\", не 0, не пустая строка \"\" и не FALSE. NA — это NA. Большинство операций с векторами, содержащими NA будут выдавать NA: missed &lt;- NA missed == &quot;NA&quot; ## [1] NA missed == &quot;&quot; ## [1] NA missed == NA ## [1] NA Заметьте: даже сравнение NA c NA выдает NA! Иногда NA в данных очень бесит: n[5] &lt;- NA n ## [1] 1 2 20 4 NA 6 7 8 9 10 mean(n) ## [1] NA Что же делать? Наверное, надо сравнить вектор с NA и исключить этих пакостников. Давайте попробуем: n == NA ## [1] NA NA NA NA NA NA NA NA NA NA Ах да, мы ведь только что узнали, что даже сравнение NA c NA приводит к NA! Чтобы выбраться из этой непростой ситуации, используйте функцию is.na(): is.na(n) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE Результат выполнения is.na(n) выдает FALSE в тех местах, где у нас числа и TRUE там, где у нас NA. Чтобы вычленить из вектора n все значения кроме NA нам нужно, чтобы было наоборот: TRUE, если это не NA, FALSE, если это NA. Здесь нам понадобится логический оператор НЕ ! (мы его уже встречали), который инвертирует логические значения: n[!is.na(n)] ## [1] 1 2 20 4 6 7 8 9 10 Ура, мы можем считать среднее! mean(n[!is.na(n)]) ## [1] 7.444444 Теперь Вы понимаете, зачем нужно отрицание (!) Вообще, есть еще один из способов посчитать среднее, если есть NA. Для этого надо залезть в хэлп по функции mean(): ?mean() В хэлпе мы найдем параметр na.rm =, который по умолчанию FALSE. Вы знаете, что нужно делать! mean(n, na.rm = TRUE) ## [1] 7.444444 NA может появляться в векторах других типов тоже. На самом деле, NA - это специальное значение в логических векторах, тогда как в векторах других типов NA появляется как NA_integer_, NA_real_, NA_complex_ или NA_character_, но R обычно сам все переводит в нужный формат и показывает как просто NA. Кроме NA есть еще NaN — это разные вещи. NaN расшифровывается как Not a Number и получается в результате таких операций как 0/0. 2.8.6 В любой непонятной ситуации — ищите в поисковике Если вдруг вы не знаете, что искать в хэлпе, или хэлпа попросту недостаточно, то ищите в поисковике! Нет ничего постыдного в том, чтобы искать в Интернете решения проблем. Это абсолютно нормально. Используйте силу интернета во благо и да помогут вам Stackoverflow и бесчисленные R-туториалы! Computer Programming To Be Officially Renamed “Googling Stack Overflow”Source: http://t.co/xu7acfXvFF pic.twitter.com/iJ9k7aAVhd — Stack Exchange July 20, 2015 Главное, помните: загуглить работающий ответ всегда недостаточно. Надо понять, как и почему он работает. Иначе что-то обязательно пойдет не так. Кроме того, правильно загуглить проблему — не так уж и просто. Does anyone ever get good at R or do they just get good at googling how to do things in R — 🔬🖤Lauren M. Seyler, Ph.D.❤️⚒ href=“https://twitter.com/mousquemere/status/1125522375141883907?ref_src=twsrc%5Etfw”&gt;May 6, 2019 Итак, с векторами мы более-менее разобрались. Помните, что вектора — это один из краеугольных камней Вашей работы в R. Если Вы хорошо с ними разобрались, то дальше все будет довольно несложно. Тем не менее, вектора — это не все. Есть еще два важных типа данных: списки (list) и матрицы (matrix). Их можно рассматривать как своеобразное “расширение” векторов, каждый в свою сторону. Ну а списки и матрицы нужны чтобы понять основной тип данных в R — data.frame. 2.9 Матрицы (matrix) Если вдруг Вас пугает это слово, то совершенно зря. Матрица — это всего лишь “двумерный” вектор: вектор, у которого есть не только длина, но и ширина. Создать матрицу можно с помощью функции matrix() из вектора, указав при этом количество строк и столбцов. A &lt;- matrix(1:20, nrow=5,ncol=4) A ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 Заметьте, значения вектора заполняются следующим образом: сначала заполняется первый столбик сверху вниз, потом второй сверху вниз и так до конца, т.е. заполнение значений матрицы идет в первую очередь по вертикали. Это довольно стандартный способ создания матриц, характерный не только для R. Если мы знаем сколько значений в матрице и сколько мы хотим строк, то количество столбцов указывать необязательно: A &lt;- matrix(1:20, nrow=5) A ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 Все остальное так же как и с векторами: внутри находится данные только одного типа. Поскольку матрица — это уже двумерный массив, то у него имеется два индекса. Эти два индекса разделяются запятыми. A[2,3] ## [1] 12 A[2:4, 1:3] ## [,1] [,2] [,3] ## [1,] 2 7 12 ## [2,] 3 8 13 ## [3,] 4 9 14 Первый индекс — выбор строк, второй индекс — выбор колонок. Если же мы оставляем пустое поле вместо числа, то мы выбираем все строки/колонки в зависимости от того, оставили мы поле пустым до или после запятой: A[,1:3] ## [,1] [,2] [,3] ## [1,] 1 6 11 ## [2,] 2 7 12 ## [3,] 3 8 13 ## [4,] 4 9 14 ## [5,] 5 10 15 A[2:4,] ## [,1] [,2] [,3] [,4] ## [1,] 2 7 12 17 ## [2,] 3 8 13 18 ## [3,] 4 9 14 19 A[,] ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 Если мы выберем только одну колонку/строчку, то на выходе получим уже вектор, а не матрицу: A[2,] ## [1] 2 7 12 17 Это называется “схлопыванием размерности.” Чтобы этого избежать, нужно поставить drop = FALSE после второй запятой внутри квадратных скобок. A[2,, drop = FALSE] ## [,1] [,2] [,3] [,4] ## [1,] 2 7 12 17 Для соединения двух или более матриц можно воспользоваться функциями rbind() и cbind() для соединения матриц по вертикали и по горизонтали соответственно. rbind(A, A) ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 ## [6,] 1 6 11 16 ## [7,] 2 7 12 17 ## [8,] 3 8 13 18 ## [9,] 4 9 14 19 ## [10,] 5 10 15 20 cbind(A, A) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 1 6 11 16 1 6 11 16 ## [2,] 2 7 12 17 2 7 12 17 ## [3,] 3 8 13 18 3 8 13 18 ## [4,] 4 9 14 19 4 9 14 19 ## [5,] 5 10 15 20 5 10 15 20 В принципе, это все, что нам нужно знать о матрицах. Матрицы используются в R довольно редко, особенно по сравнению, например, с MATLAB. Но вот индексировать матрицы хорошо бы уметь: это понадобится в работе с датафреймами. То, что матрица - это просто двумерный вектор, не является метафорой: в R матрица - это по сути своей вектор с дополнительными атрибутами dim и dimnames. Атрибуты — это неотъемлемые свойства объектов, для всех объектов есть обязательные атрибуты типа и длины и могут быть любые необязательные атрибуты. Можно задавать свои атрибуты или удалять уже присвоенные: удаление атрибута dim у матрицы превратит ее в обычный вектор. Про атрибуты подробнее можно почитать здесь или на стр. 99–101 книги “R in a Nutshell” (Adler 2010). 2.10 Списки (list) Теперь представим себе вектор без ограничения на одинаковые данные внутри. И получим список! simple_list &lt;- list(42, &quot;Пам пам&quot;, TRUE) simple_list ## [[1]] ## [1] 42 ## ## [[2]] ## [1] &quot;Пам пам&quot; ## ## [[3]] ## [1] TRUE А это значит, что там могут содержаться самые разные данные, в том числе и другие списки и векторы! complex_list &lt;- list(c(&quot;Wow&quot;, &quot;this&quot;, &quot;list&quot;, &quot;is&quot;, &quot;so&quot;, &quot;big&quot;), &quot;16&quot;, simple_list) complex_list ## [[1]] ## [1] &quot;Wow&quot; &quot;this&quot; &quot;list&quot; &quot;is&quot; &quot;so&quot; &quot;big&quot; ## ## [[2]] ## [1] &quot;16&quot; ## ## [[3]] ## [[3]][[1]] ## [1] 42 ## ## [[3]][[2]] ## [1] &quot;Пам пам&quot; ## ## [[3]][[3]] ## [1] TRUE Если у нас сложный список, то есть очень классная функция, чтобы посмотреть, как он устроен, под названием str(): str(complex_list) ## List of 3 ## $ : chr [1:6] &quot;Wow&quot; &quot;this&quot; &quot;list&quot; &quot;is&quot; ... ## $ : chr &quot;16&quot; ## $ :List of 3 ## ..$ : num 42 ## ..$ : chr &quot;Пам пам&quot; ## ..$ : logi TRUE Как и в случае с векторами мы можем давать имена элементам списка: named_list &lt;- list(age = 24, phd_student = T, language = &quot;Russian&quot;) named_list ## $age ## [1] 24 ## ## $phd_student ## [1] FALSE ## ## $language ## [1] &quot;Russian&quot; К списку можно обращаться как с помощью индексов, так и по именам. Начнем с последнего: named_list$age ## [1] 24 А вот с индексами сложнее, и в этом очень легко запутаться. Давайте попробуем сделать так, как мы делали это раньше: named_list[1] ## $age ## [1] 24 Мы, по сути, получили элемент списка - просто как часть списка, т.е. как список длиной один: class(named_list) ## [1] &quot;list&quot; class(named_list[1]) ## [1] &quot;list&quot; А вот чтобы добраться до самого элемента списка (и сделать с ним что-то хорошее) нам нужна не одна, а две квадратных скобочки: named_list[[1]] ## [1] 24 class(named_list[[1]]) ## [1] &quot;numeric&quot; Indexing lists in #rstats. Inspired by the Residence Inn pic.twitter.com/YQ6axb2w7t — Hadley Wickham (@ href=“https://twitter.com/hadleywickham/status/643381054758363136?ref_src=twsrc%5Etfw”&gt;September 14, 2015 Как и в случае с вектором, к элементу списка можно обращаться по имени. named_list[[&#39;age&#39;]] ## [1] 24 Хотя последнее — практически то же самое, что и использование знака $. Списки довольно часто используются в R, но реже, чем в Python. Со многими объектами в R, такими как результаты статистических тестов, объекты ggplot и т.д. удобно работать именно как со списками — к ним все вышеописанное применимо. Кроме того, некоторые данные мы изначально получаем в виде древообразной структуры — хочешь не хочешь, а придется работать с этим как со списком. Особенно это характерно для данных, выкачанных из веб-страниц (HTML страницы, XML данные) или полученных с помощью API различных веб-сайтов (например, в формате JSON). Но обычно после этого стоит как можно скорее превратить список в датафрейм. 2.11 Датафрейм Итак, мы перешли к самому главному. Самому-самому. Датафреймы (data.frames). Более того, сейчас станет понятно, зачем нам нужно было разбираться со всеми предыдущими темами. Без векторов мы не смогли бы разобраться с матрицами и списками. А без последних мы не сможем понять, что такое датафрейм. name &lt;- c(&quot;Ivan&quot;, &quot;Eugeny&quot;, &quot;Lena&quot;, &quot;Misha&quot;, &quot;Sasha&quot;) age &lt;- c(26, 34, 23, 27, 26) student &lt;- c(FALSE, FALSE, TRUE, TRUE, TRUE) df = data.frame(name, age, student) df str(df) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ name : chr &quot;Ivan&quot; &quot;Eugeny&quot; &quot;Lena&quot; &quot;Misha&quot; ... ## $ age : num 26 34 23 27 26 ## $ student: logi FALSE FALSE TRUE TRUE TRUE Вообще, очень похоже на список, не правда ли? Так и есть, датафрейм — это что-то вроде проименованного списка, каждый элемент которого является atomic вектором фиксированной длины. Скорее всего, список Вы представляли “горизонтально.” Если это так, то теперь “переверните” его у себя в голове. Так, чтоб названия векторов оказались сверху, а колонки стали столбцами. Поскольку длина всех этих векторов равна (обязательное условие!), то данные представляют собой табличку, похожую на матрицу. Но в отличие от матрицы, разные столбцы могут имет разные типы данных: первая колонка — character, вторая колонка — numeric, третья колонка — logical. Тем не менее, обращаться с датафреймом можно и как с проименованным списком, и как с матрицей: df$age[2:3] ## [1] 34 23 Здесь мы сначала вытащили колонку age с помощью оператора $. Результатом этой операции является числовой вектор, из которого мы вытащили кусок, выбрав индексы 2 и 3. Используя оператор $ и присваивание можно создавать новые колонки датафрейма: df$lovesR &lt;- TRUE #правило recycling - узнали? df Ну а можно просто обращаться с помощью двух индексов через запятую, как мы это делали с матрицей: df[3:5, 2:3] Как и с матрицами, первый индекс означает строчки, а второй — столбцы. А еще можно использовать названия колонок внутри квадратных скобок: df[1:2,&quot;age&quot;] ## [1] 26 34 И здесь перед нами открываются невообразимые возможности! Узнаем, любят ли R те, кто моложе среднего возраста в группе: df[df$age &lt; mean(df$age), 4] ## [1] TRUE TRUE TRUE TRUE Эту же задачу можно выполнить другими способами: df$lovesR[df$age &lt; mean(df$age)] ## [1] TRUE TRUE TRUE TRUE df[df$age &lt; mean(df$age), &#39;lovesR&#39;] ## [1] TRUE TRUE TRUE TRUE В большинстве случаев подходят сразу несколько способов — тем не менее, стоит овладеть ими всеми. Датафреймы удобно просматривать в RStudio. Для это нужно написать команду View(df) или же просто нажать на названии нужной переменной из списка вверху справа (там где Environment). Тогда увидите табличку, очень похожую на Excel и тому подобные программы для работы с таблицами. Там же есть и всякие возможности для фильтрации, сортировки и поиска… Но, конечно, интереснее все эти вещи делать руками, т.е. с помощью написания кода. На этом пора заканчивать с введением и приступать к реальным данным. Ссылки на литературу "],["real-data.html", "3 Импорт данных 3.1 Рабочая папка и проекты RStudio 3.2 Проверка импортированных данных 3.3 Экспорт данных 3.4 Импорт таблиц в бинарном формате: таблицы Excel, SPSS 3.5 Быстрый импорт данных", " 3 Импорт данных Итак, пришло время перейти к реальным данным. Мы начнем с использования датасета (так мы будем называть любой набор данных) по супергероям. Этот датасет представляет собой табличку, каждая строка которой - отдельный супергерой, а столбик — какая-либо информация о нем. Например, цвет глаз, цвет волос, вселенная супергероя5, рост, вес, пол и так далее. Несложно заметить, что этот датасет идеально подходит под структуру датафрейма: прямоугольная табличка, внутри которой есть разные колонки, каждая из которой имеет свой тип (числовой или строковый). 3.1 Рабочая папка и проекты RStudio Для начала скачайте файл по ссылке Он, скорее всего, появился у Вас в папке “Загрузки.” Если мы будем просто пытаться прочитать этот файл (например, с помощью read.csv() — мы к этой функцией очень скоро перейдем), указав его имя и разрешение, то наткнемся на такую ошибку: read.csv(&quot;heroes_information.csv&quot;) ## Warning in file(file, &quot;rt&quot;): cannot open file &#39;heroes_information.csv&#39;: No such ## file or directory ## Error in file(file, &quot;rt&quot;): cannot open the connection Это означает, что R не может найти нужный файл. Вообще-то мы даже не сказали, где искать. Нам нужно как-то совместить место, где R ищет загружаемые файлы и сами файлы. Для этого есть несколько способов. Магомет идет к горе: перемещение файлов в рабочую папку. Для этого нужно узнать, какая папка является рабочей с помощью функции getwd() (без аргументов), найти эту папку в проводнике и переместить туда файл. После этого можно использовать просто название файла с разрешением: heroes &lt;- read.csv(&quot;heroes_information.csv&quot;) Кроме того, путь к рабочей папке можно увидеть в RStudio во вкладке с консолью, в самой верхней части (прямо под надписью “Console”): Гора идет к Магомету: изменение рабочей папки. Можно просто сменить рабочую папку с помощью setwd() на ту, где сейчас лежит файл, прописав путь до этой папки. Теперь файл находится в рабочей папке: heroes &lt;- read.csv(&quot;heroes_information.csv&quot;) Этот вариант использовать не рекомендуется! Как минимум, это сразу делает невозможным запустить скрипт на другом компьютере. Гора находит Магомета по месту прописки: указание полного пути файла. heroes &lt;- read.csv(&quot;/Users/Username/Some_Folder/heroes_information.csv&quot;) Этот вариант страдает теми же проблемами, что и предыдущий, поэтому тоже не рекомендуется! Для пользователей Windows есть дополнительная сложность: знак / является особым знаком для R, поэтому вместо него нужно использовать двойной //. Магомет использует кнопочный интерфейс: Import Dataset. Во вкладке Environment справа в окне RStudio есть кнопка “Import Dataset.” Возможно, у Вас возникло непреодолимое желание отдохнуть от написания кода и понажимать кнопочки — сопротивляйтесь этому всеми силами, но не вините себя, если не сдержитесь. Гора находит Магомета в интернете. Многие функции в R, предназначенные для чтения файлов, могут прочитать файл не только на Вашем компьютере, но и сразу из интернета. Для этого просто используйте ссылку вместо пути: heroes &lt;- read.csv(&quot;https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/heroes_information.csv&quot;) Каждый Магомет получает по своей горе: использование проектов в RStudio. На первый взгляд это кажется чем-то очень сложным, но это не так. Это очень просто и ОЧЕНЬ удобно. При создании проекта создается отдельная папочка, где у Вас лежат данные, хранятся скрипты, вспомогательные файлы и отчеты. Если нужно вернуться к другому проекту — просто открываете другой проект, с другими файлами и скриптами. Это еще помогает не пересекаться переменным из разных проектов — а то, знаете, использование двух переменных data в разных скриптах чревато ошибками. Поэтому очень удобным решением будет выделение отдельного проекта под этот курс. При закрытии проекта все переменные по умолчанию тоже будут сохраняться, а при открытии — восстанавливаться. Это очень удобно, хотя некоторые рекомендуют от этого отказаться. Это можно сделать во вкладке Tool - Global Options... 3.1.1 Табличные данные: текстовые и бинарные данные Как Вы уже поняли, импортирование данных - одна из самых муторных и неприятных вещей в R. Если у Вас получится с этим справится, то все остальное - ерунда. Мы уже разобрались с первой частью этого процесса - нахождением файла с данными, осталось научиться их читать. Здесь стоит сделать небольшую ремарку. Довольно часто данные представляют собой табличку. Или же их можно свести к табличке. Такая табличка, как мы уже выяснили, удобно репрезентируется в виде датафрейма. Но как эти данные хранятся на компьютере? Есть два варианта: в бинарном и в текстовом файле. Текстовый файл означает, что такой файл можно открыть в программе “Блокнот” или аналоге (например, TextEdit на macOS) и увидеть напечатанный текст: скрипт, роман или упорядоченный набор цифр и букв. Нас сейчас интересует именно последний случай. Таблица может быть представлена как текст: отдельные строчки в файле будут разделять разные строчки таблицы, а какой-нибудь знак-разделитель отделять колонки друг от друга. Для чтения данных из текстового файла есть довольно удобная функция read.table(). Почитайте хэлп по ней и ужаснитесь: столько разных параметров на входе! Но там же вы увидете функции read.csv(), read.csv2() и некоторые другие — по сути, это тот же read.table(), но с другими параметрами по умолчанию, соответствующие формату файла, который мы загружаем. В данном случае используется формат .csv, что означает “Comma Separated Values” (Значения, Разделенные Запятыми). Формат .csv — это самый известный способ хранения табличных данных в файде на сегодняшний день. Файлы с расширением .csv можно легко открыть в любой программе, работающей с таблицами, в том числе Microsoft Excel и его аналогах. Файл с расширением .csv — это просто текстовый файл, в котором “закодирована” таблица: разные строчки разделяют разные строчки таблицы, а столбцы отделяются запятыми (отсюда и название). Вы можете вручную создать такие файлы в Блокноте и сохранять их с форматом .csv - и такая табличка будет нормально открываться в Microsoft Excel и других программах для работы с таблицами. Можете попробовать это сделать самостоятельно! Как говорилось ранее, в качестве разделителя ячеек по горизонтали — то есть разделителя между столбцами — используется запятая. С этим связана одна проблема: в некоторых странах (в т.ч. и России) принято использовать запятую для разделения дробной части числа, а не точку, как это делается в большинстве стран мира. Поэтому есть альтернативный вариант формата .csv, где значения разделены точкой с запятой (;), а дробные значения - запятой (,). В этом и различие функций read.csv() и read.csv2() — первая функция предназначена для “международного” формата, вторая - для (условно) “Российского.” Оба варианта формата имеют расширение .csv, поэтому заранее понять какой именно будет вариант довольно сложно, приходится либо пробовать оба, либо заранее открывать файл в текстовом редакторе. В первой строчке обычно содержатся названия столбцов - и это чертовски удобно, функции read.csv() и read.csv2() по умолчанию считают первую строчку именно как название для колонок. Кроме .csv формата есть и другие варианты хранения таблиц в виде текста. Например, .tsv — тоже самое, что и .csv, но разделитель - знак табуляции. Для чтения таких файлов есть функция read.delim() и read.delim2(). Впрочем, даже если бы ее и не было, можно было бы просто подобрать нужные параметры для функции read.table(). Есть даже функции, которые пытаются сами “угадать” нужные параметры для чтения — часто они справляются с этим довольно удачно. Но не всегда. Поэтому стоит научиться справляться с любого рода данными на входе. Итак, прочитаем наш файл. Для этого используем только параметр file =, который идет первым, и для параметра stringsAsFactors = поставим значение FALSE: heroes &lt;- read.csv(&quot;data/heroes_information.csv&quot;, stringsAsFactors = FALSE) Параметр stringsAsFactors = задает то, как будут прочитаны строковые значения - как уже знакомые нам строки или как факторы. По сути, факторы - это примерно то же самое, что и character, но закодированные числами. Когда-то это было придумано для экономии используемых времени и памяти, сейчас же обычно становится просто лишней морокой. Но некоторые функции требуют именно character, некоторые factor, в большинстве случаев это без разницы. Но иногда непонимание может привести к дурацким ошибкам. В данном случае мы просто пока обойдемся без факторов. Если у вас версия R выше 4.0, то stringsAsFactors = будет FALSE по умолчанию. Можете проверить с помощью View(heroes): все работает! Если же вылезает какая-то странная ерунда или же просто ошибка - попробуйте другие функции (read.table(), read.delim()) и покопаться с параметрами. Для этого читайте Help. 3.2 Проверка импортированных данных При импорте данных обратите внимания на предупреждения (если таковые появляются), в большинстве случаев они указывают на то, что данные импортированы некорректно. Проверим, что все прочиталось нормально с помощью уже известной нам функции str(): str(heroes) ## &#39;data.frame&#39;: 734 obs. of 11 variables: ## $ X : int 0 1 2 3 4 5 6 7 8 9 ... ## $ name : chr &quot;A-Bomb&quot; &quot;Abe Sapien&quot; &quot;Abin Sur&quot; &quot;Abomination&quot; ... ## $ Gender : chr &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; ... ## $ Eye.color : chr &quot;yellow&quot; &quot;blue&quot; &quot;blue&quot; &quot;green&quot; ... ## $ Race : chr &quot;Human&quot; &quot;Icthyo Sapien&quot; &quot;Ungaran&quot; &quot;Human / Radiation&quot; ... ## $ Hair.color: chr &quot;No Hair&quot; &quot;No Hair&quot; &quot;No Hair&quot; &quot;No Hair&quot; ... ## $ Height : num 203 191 185 203 -99 193 -99 185 173 178 ... ## $ Publisher : chr &quot;Marvel Comics&quot; &quot;Dark Horse Comics&quot; &quot;DC Comics&quot; &quot;Marvel Comics&quot; ... ## $ Skin.color: chr &quot;-&quot; &quot;blue&quot; &quot;red&quot; &quot;-&quot; ... ## $ Alignment : chr &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;bad&quot; ... ## $ Weight : int 441 65 90 441 -99 122 -99 88 61 81 ... Всегда проверяйте данные на входе и никогда не верьте на слово, если вам говорят, что данные вычищенные и не содержат никаких ошибок. На что нужно обращать внимание? Прочитаны ли пропущенные значения как NA. По умолчанию пропущенные значения обозначаются пропущенной строчкой или “NA,” но встречаются самые разнообразные варианты. Возможные варианты кодирования пропущенных значений можно задать в параметре na.strings = функции read.table() и ее вариантов. В нашем датасете как раз такая ситуация, где нужно самостоятельно задавать, какие значения будут прочитаны как NA. Попытайтесь самостоятельно догадаться, как именно. Прочитаны ли те столбики, которые должны быть числовыми, как int или num. Если в колонке содержатся числа, а написано chr (= \"character\") или Factor (в случае если stringsAsFactors = TRUE), то, скорее всего, одна из строчек содержит в себе нечисловые знаки, которые не были прочитаны как NA. Странные названия колонок. Это может случиться по самым разным причинам, но в таких случаях стоит открывать файл в другой программе и смотреть первые строчки. Например, может оказаться, что первые несколько строчек — пустые или что первая строчка не содержит название столбцов (тогда для параметра header = нужно поставить FALSE) Вместо строковых данных у вас кракозябры. Это означает проблемы с кодировкой. В первую очередь попробуйте выставить значение \"UTF-8\" для параметра encoding = в функции для чтения файла: heroes &lt;- read.csv(&quot;data/heroes_information.csv&quot;, stringsAsFactors = FALSE, encoding = &quot;UTF-8&quot;) В случае если это не помогает, попробуйте разобрать, что это за кодировка. Все прочиталось как одна колонка. В этом случае, скорее всего, неправильно подобран разделить колонок — параметр sep =. Откройте файл в текстовом редакторе, чтобы понять какой нужно использовать. В отдельных строчках все прочиталось как одна колонка, а в остальных нормально. Скорее всего, в файле есть значения типа \\ или \", которые в функциях read.csv(), read.delim(), read.csv2(), read.delim2() читаются как символы для закавычивания значений. Это может понадобиться, если у вас в таблице есть строковые значения со знаками , или ;, которые могут восприниматься как разделитель столбцов. Появились какие-то новые числовые колонки. Возможно неправильно поставлен разделитель дробной части. Обычно это либо . (read.table(), read.csv(), read.delim()), либо , (read.csv2(), read.delim2()). Конкретно в нашем случае все прочиталось хорошо с помощью функции read.csv(), но в строковых переменных есть много прочерков, которые обозначают отсутствие информации по данному параметру супергероя, т.е. пропущенное значение. А вот с числовыми значениями все не так просто: для всех супергероев прописано какое-то число, но во многих случаях это -99. Очевидно, отрицательного роста и массы не бывает, это просто обозначение пропущенных значений (такое часто используется). Таким образом, чтобы адекватно прочитать файл, нам нужно поменять параметр na.strings = функции read.csv(): heroes &lt;- read.csv(&quot;data/heroes_information.csv&quot;, stringsAsFactors = FALSE, na.strings = c(&quot;-&quot;, &quot;-99&quot;)) 3.3 Экспорт данных Представим, что вы хотите сохранить табличку с данными про супергероев из вселенной DC в виде отдельного файла .csv. dc &lt;- heroes[heroes$Publisher == &quot;DC Comics&quot;,] Функция write.csv() позволит записать датафрейм в файл формата .csv: write.csv(dc, &quot;data/dc_heroes_information.csv&quot;) Обычно названия строк не используются, и их лучше не записывать, поставив для row.names = значение FALSE: write.csv(dc, &quot;data/dc_heroes_information.csv&quot;, row.names = FALSE) По аналогии с read.csv2(), write.csv2() позволит записать файлы формата .csv с разделителем ;. write.csv2(dc, &quot;data/dc_heroes_information.csv&quot;, row.names = FALSE) 3.4 Импорт таблиц в бинарном формате: таблицы Excel, SPSS Тем не менее, далеко не всегда таблицы представлены в виде текстового файла. Самый распространенный пример таблицы в бинарном виде — родные форматы Microsoft Excel. Если Вы попробуете открыть .xlsx файл в Блокноте, то увидите кракозябры. Это делает работу с этим файлами гораздо менее удобной, поэтому стоит избегать экселевских форматов и стараться все сохранять в .csv. Такие файлы не получится прочитать при помощи базового инструментария R. Тем не менее, для чтения таких файлов есть много дополнительных пакетов: файлы Microsoft Excel: лучше всего справляется пакет readxl (является частью расширенного tidyverse), у него есть много альтернатив (xlsx, openxlsx). файлы SPSS, SAS, Stata: существуют два основных пакета — haven (часть расширенного tidyverse) и foreign. Что такое пакеты и как их устанавливать мы изучим очень скоро. 3.5 Быстрый импорт данных Чтение табличных данных обычно происходит очень быстро. По крайней мере, до тех пор пока ваши данные не содержат очень много значений. Если вы попробуете прочитать с помощью read.csv() таблицу с миллионами строчками, то заметите, что это происходит довольно медленно. Впрочем, эта проблема эффективно решается дополнительными пакетами. Пакет readr (часть базового tidyverse) предлагает функции, очень похожие на стандартные read.csv(), read.csv2() и тому подобные, только в названиях используется нижнее подчеркивание: read_csv() и read_csv2(). Они быстрее и немного удобнее, особенно если вы работаете в tidyverse. readr::read_csv(&quot;data/heroes_information.csv&quot;, na = c(&quot;-&quot;, &quot;-99&quot;)) ## Warning: Missing column names filled in: &#39;X1&#39; [1] ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## X1 = col_double(), ## name = col_character(), ## Gender = col_character(), ## `Eye color` = col_character(), ## Race = col_character(), ## `Hair color` = col_character(), ## Height = col_double(), ## Publisher = col_character(), ## `Skin color` = col_character(), ## Alignment = col_character(), ## Weight = col_double() ## ) Пакет vroom - это часть расширенного tidyverse. Это такая альтернатива readr из того же tidyverse, но еще быстрее (отсюда и название). vroom::vroom(&quot;data/heroes_information.csv&quot;) ## New names: ## * `` -&gt; ...1 ## Rows: 734 ## Columns: 11 ## Delimiter: &quot;,&quot; ## chr [8]: name, Gender, Eye color, Race, Hair color, Publisher, Skin color, Alignment ## dbl [3]: ...1, Height, Weight ## ## Use `spec()` to retrieve the guessed column specification ## Pass a specification to the `col_types` argument to quiet this message Пакет data.table - это не просто пакет, а целый фреймворк для работы с R, основной конкурент tidyverse. Одна из основных фишек data.table - быстрота работы. Это касается не только процессинга данных, но и их загрузки и записи. Поэтому некоторые используют функции data.table для чтения и записи данных в отдельности от всего остального пакета - они даже и называются соответствующе: fread() и fwrite(), где f означет fast6. data.table::fread(&quot;data/heroes_information.csv&quot;) Чем же пользоваться среди всего этого многообразия? Бенчмарки7 показывают, что быстрее всех vroom и data.table. Если же у вас нет задачи ускорить работу кода на несколько миллисекунд или прочитать датасет на много миллионов строк, то стандартного read.csv() (если вы работаете в базовом R) и readr::read_csv() (если вы работаете в tidyverse) должно быть достаточно. Все перечисленные пакеты повзоляют не только быстро импортировать данные, но и быстро (и удобно!) экспортировать их: readr::write_csv(dc, &quot;data/dc_heroes_information.csv&quot;) readr::write_excel_csv(dc, &quot;data/dc_heroes_information.csv&quot;) #Если в Excel возникают проблемы с кодировками при открытии созданного .csv файла, то эта функция решает эти проблемы vroom::vroom_write(dc, &quot;data/dc_heroes_information.csv&quot;, delim = &quot;,&quot;) data.table::fwrite(dc, &quot;data/dc_heroes_information.csv&quot;) В плане скорости записи файлов соотношение сил примерно такое же, как и для чтения: vroom и data.table обгоняют всех, затем идет readr, и только после него - базовые функции R. супергерои в комиксах, фильмах и телесериалах часто взаимодействуют друг с другом, однако обычно это взаимодействие происходит между супергероями одного издателя. Два крупнейших издателя комиксов — DC и Marvel, поэтому принято говорить о вселенной DC и Marvel.↩︎ А еще friendly: fread() обычно самостоятельно хорошо угадывает формат таблицы на входе. vroom тоже так умеет.↩︎ бенчмаркинг — это тест производительности, в данном случае — сравнение скорости работы конкурирующих пакетов.↩︎ "],["loops-conditions.html", "4 Условные конструкции и циклы 4.1 Выражения if, else, else if 4.2 Циклы for 4.3 Векторизованные условные конструкции: функции ifelse() и dplyr::case_when()", " 4 Условные конструкции и циклы 4.1 Выражения if, else, else if Стандратная часть практически любого языка программирования — условные конструкции. R не исключение. Однако и здесь есть свои особенности. Начнем с самого простого варианта с одним условием. Выглядеть условная конcтрукция будет вот так: if (условие) выражение Вот так это будет работать на практике: number &lt;- 1 if (number &gt; 0) &quot;Положительное число&quot; ## [1] &quot;Положительное число&quot; Если выражение (expression) содержит больше одной строчки, то они объединяются фигурными скобками. Впрочем, использовать их можно, даже если строчка всего в выражении всего одна. number &lt;- 1 if (number &gt; 0) { &quot;Положительное число&quot; } ## [1] &quot;Положительное число&quot; В рассмотренной нами конструкции происходит проверка на условие. Если условие верно8, то происходит то, что записано в последующем выражении. Если же условие неверно9, то ничего не происходит. Оператор else позволяет задавать действие на все остальные случаи: if (условие) выражение else выражение Работает это так: number &lt;- -3 if (number &gt; 0) { &quot;Положительное число&quot; } else { &quot;Отрицательное число или ноль&quot; } ## [1] &quot;Отрицательное число или ноль&quot; Иногда нам нужна последовательная проверка на несколько условий. Для этого есть оператор else if. Вот как выглядит ее применение: number &lt;- 0 if (number &gt; 0) { &quot;Положительное число&quot; } else if (number &lt; 0){ &quot;Отрицательное число&quot; } else { &quot;Ноль&quot; } ## [1] &quot;Ноль&quot; Как мы помним, R — язык, в котором векторизация играет большое значение. Но вот незадача — условные конструкции не векторизованы в R! Давайте попробуем применить эти конструкции для вектора значений и посмотрим, что получится. number &lt;- -2:2 if (number &gt; 0) { &quot;Положительное число&quot; } else if (number &lt; 0){ &quot;Отрицательное число&quot; } else { &quot;Ноль&quot; } ## Warning in if (number &gt; 0) {: the condition has length &gt; 1 and only the first ## element will be used ## Warning in if (number &lt; 0) {: the condition has length &gt; 1 and only the first ## element will be used ## [1] &quot;Отрицательное число&quot; R выдает сообщение, что используется только первое значение логического вектора внутри условия. Остальные просто игнорируются. Как же посчитать для всего вектора сразу? 4.2 Циклы for Во-первых, можно использовать for. Синтаксис у for похож на синтаксис условных конструкций. for(переменная in последовательность) выражение Теперь мы можем объединить условные конструкции и for. Немножко монструозно, но это работает: for (i in number) { if (i &gt; 0) { print(&quot;Положительное число&quot;) } else if (i &lt; 0) { print(&quot;Отрицательное число&quot;) } else { print(&quot;Ноль&quot;) } } ## [1] &quot;Отрицательное число&quot; ## [1] &quot;Отрицательное число&quot; ## [1] &quot;Ноль&quot; ## [1] &quot;Положительное число&quot; ## [1] &quot;Положительное число&quot; Чтобы выводить в консоль результат вычислений внутри for, нужно использовать print(). Здесь стоит отметить, что for используется в R относительно редко. В подавляющем числе ситуаций использование for можно избежать. Обычно мы работаем в R с векторами или датафреймами, которые представляют собой множество относительно независимых наблюдений. Если мы хотим провести какие-нибудь операции с этими наблюдениями, то они обычно могут быть выполнены параллельно. Скажем, вы хотите для каждого испытуемого пересчитать его массу из фунтов в килограммы. Этот пересчет осуществляется по одинаковой формуле для каждого испытуемого. Эта формула не изменится из-за того, что какой-то испытуемый слишком большой или слишком маленький - для следующего испытуемого формула будет прежняя. Если Вы встречаете подобную задачу (где функцию можно применить независимо для всех значений), то без цикла for вполне можно обойтись. Даже во многих случаях, где расчеты для одной строчки зависят от расчетов предыдущих строчек, можно обойтись без for векторизованными функциями, например, cumsum() для подсчета кумулятивной суммы. cumsum(1:10) ## [1] 1 3 6 10 15 21 28 36 45 55 Если же нет подходящей векторизованной функции, то можно воспользоваться семейством функций apply() (см. @ref(apply_f) ). После этих объяснений кому-то может показаться странным, что я вообще упоминаю про эти циклы. Но для кого-то циклы for настолько привычны, что их полное отсутствие в курсе может показаться еще более странным. Поэтому лучше от меня, чем на улице. Зачем вообще избегать конструкций for? Некоторые говорят, что они слишком медленные, и частично это верно, если мы сравниваем с векторизованными функциями, которые написаны на более низкоуровневых языках. Но в большинстве случаев низкая скорость for связана с неправильным использованием этой конструкции. Например, стоит избегать ситуации, когда на каждой итерации for какой-то объект (вектор, список, что угодно) изменяется в размере. Лучше будет создать заранее объект нужного размера, который затем будет наполняться значениями: number_descriptions &lt;- character(length(number)) #создаем строковый вектор с такой же длиной, как и исходный вектор for (i in 1:length(number)) { if (number[i] &gt; 0) { number_descriptions[i] &lt;- &quot;Положительное число&quot; } else if (number[i] &lt; 0) { number_descriptions[i] &lt;- &quot;Отрицательное число&quot; } else { number_descriptions[i] &lt;- &quot;Ноль&quot; } } number_descriptions ## [1] &quot;Отрицательное число&quot; &quot;Отрицательное число&quot; &quot;Ноль&quot; ## [4] &quot;Положительное число&quot; &quot;Положительное число&quot; В общем, при правильном обращении с for особых проблем со скоростью не будет. Но все равно это будет громоздкая конструкция, в которой легко ошибиться, и которую, скорее всего, можно заменить одной короткой строчкой. Кроме того, без конструкции for код обычно легко превратить в набор функций, последовательно применяющихся к данным, что мы будем по максимуму использовать, работая в tidyverse и применяя пайпы (см. [pipe]). 4.3 Векторизованные условные конструкции: функции ifelse() и dplyr::case_when() Альтернатива сочетанию условных конструкций и циклов for является использование встроенной функции ifelse(). Функция ifelse() принимает три аргумента - 1) условие (т.е. просто логический вектор, состоящий из TRUE и FALSE), 2) что выдавать в случае TRUE, 3) что выдавать в случае FALSE. На выходе получается вектор такой же длины, как и изначальный логический вектор (условие). ifelse(number &gt; 0, &quot;Положительное число&quot;, &quot;Отрицательное число или ноль&quot;) ## [1] &quot;Отрицательное число или ноль&quot; &quot;Отрицательное число или ноль&quot; ## [3] &quot;Отрицательное число или ноль&quot; &quot;Положительное число&quot; ## [5] &quot;Положительное число&quot; Периодически я встречаю у студентов строчку вроде такой: ifelse(условие, TRUE, FALSE). Эта конструкция избыточна, т.к. получается, что логический вектор из TRUE и FALSE превращается в абсолютно такой же вектор из TRUE и FALSE на тех же самых местах. Выходит, что ничего не меняется! У ifelse() тоже есть недостаток: он не может включать в себя дополнительных условий по типу else if. В простых ситуациях можно вставлять ifelse() внутри ifelse(): ifelse(number &gt; 0, &quot;Положительное число&quot;, ifelse(number &lt; 0, &quot;Отрицательное число&quot;, &quot;Ноль&quot;)) ## [1] &quot;Отрицательное число&quot; &quot;Отрицательное число&quot; &quot;Ноль&quot; ## [4] &quot;Положительное число&quot; &quot;Положительное число&quot; Достаточно симпатичное решение предлогает пакет dplyr (основа tidyverse) — функция case_when(), которая работает с использованием формулы: dplyr::case_when( number &gt; 0 ~ &quot;Положительное число&quot;, number &lt; 0 ~ &quot;Отрицательное число&quot;, number == 0 ~ &quot;Ноль&quot;) ## [1] &quot;Отрицательное число&quot; &quot;Отрицательное число&quot; &quot;Ноль&quot; ## [4] &quot;Положительное число&quot; &quot;Положительное число&quot; В принципе, необязательно внутри должна быть проверка условий, достаточно просто значения TRUE.↩︎ Аналогично, достаточно просто значения FALSE.↩︎ "],["functional.html", "5 Функциональное программирование в R 5.1 Создание функций 5.2 Проверка на адекватность 5.3 Когда и зачем создавать функции? 5.4 Функции как объекты первого порядка 5.5 Семейство функций apply() 5.6 Вселенная tidyverse 5.7 Загрузка данных с помощью readr 5.8 magrittr::%&gt;% 5.9 Главные пакеты tidyverse: dplyr и tidyr 5.10 Работа с колонками тиббла 5.11 Работа со строками тиббла 5.12 Создание колонок: dplyr::mutate() и dplyr::transmute() 5.13 Агрегация данных в тиббле 5.14 Трансформация нескольких колонок: dplyr::across() 5.15 Объединение нескольких датафреймов 5.16 Tidy data: tidyr::pivot_longer(), tidyr::pivot_wider()", " 5 Функциональное программирование в R 5.1 Создание функций Поздравляю, сейчас мы выйдем на качественно новый уровень владения R. Вместо того, чтобы пользоваться теми функциями, которые уже написали за нас, мы можем сами создавать свои функции! В этом нет ничего сложного. Синтаксис создания функции внешне похож на создание циклов или условных конструкций. Мы пишем ключевое слово function, в круглых скобках обозначаем переменные, с которыми собираемся что-то делать. Внутри фигурных скобок пишем выражения, которые будут выполняться при запуске функции. У функции есть свое собственное окружение — место, где хранятся переменные. Именно те объекты, которые мы передаем в скобочках, и будут в окружении, так же как и “обычные” переменные для нас в глобальном окружении. Это означает, что функция будет искать переменные в первую очередь среди объектов, которые переданы в круглых скобочках. С ними функция и будет работать. На выходе функция выдаст то, что вычисляется внутри функции return(). Если return() появляется в теле функции несколько раз, то до результат будет возвращаться из той функции return(), до которой выполнение дошло первым. pow &lt;- function(x, p) { power &lt;- x ^ p return(power) } pow(3, 2) ## [1] 9 Если функция проработала до конца, а функция return() так и не встретилась, то возвращается последнее посчитанное значение. pow &lt;- function(x, p) { x ^ p } pow(3, 2) ## [1] 9 Если в последней строчке будет присвоение, то функция ничего не вернет обратно. Это очень распространенная ошибка: функция вроде бы работает правильно, но ничего не возвращает. Нужно писать так, как будто бы в последней строчке результат выполнения выводится в консоль. pow &lt;- function(x, p) { power &lt;- x ^ p #Функция ничего не вернет, потому что в последней строчке присвоение! } pow(3, 2) #ничего не возвращается из функции Если функция небольшая, то ее можно записать в одну строчку без фигурных скобок. pow &lt;- function(x, p) x ^ p pow(3, 2) ## [1] 9 Вообще, фигурные скобки используются для того, чтобы выполнить серию выражений, но вернуть только результат выполнения последнего выражения. Это можно использовать, чтобы не создавать лишних временных переменных в глобальном окружении. Мы можем оставить в функции параметры по умолчанию. pow &lt;- function(x, p = 2) x ^ p pow(3) ## [1] 9 pow(3, 3) ## [1] 27 В R работают ленивые вычисления (lazy evaluations). Это означает, что параметры функций будут только когда они понадобятся, а не заранее. Например, эта функция не будет выдавать ошибку, если мы не зададим параметр we_will_not_use_this_parameter =, потому что он нигде не используется в расчетах. pow &lt;- function(x, p = 2, we_will_not_use_this_parameter) x ^ p pow(x = 3) ## [1] 9 5.2 Проверка на адекватность Лучший способ не бояться ошибок и предупреждений — научиться прописывать их самостоятельно в собственных функциях. Это позволит понять, что за текстом предупреждений и ошибок, которые у вас возникают, стоит забота разработчиков о пользователях, которые хотят максимально обезопасить нас от наших непродуманных действий. Хорошо написанные функции не только выдают правильный результат на все возможные адекватные данные на входе, но и не дают получить правдоподобные результаты при неадекватных входных данных. Как вы уже знаете, если на входе у вас имеются пропущенные значения, то многие функции будут в ответ тоже выдавать пропущенные значения. И это вполне осознанное решение, которое позволяет избегать ситуаций вроде той, когда около одной пятой научных статей по генетике содержало ошибки в приложенных данных и замечать пропущенные значения на ранней стадии. Кроме того, можно проводить проверки на адекватность входящих данных (sanity check). Разберем это на примере самодельной функции imt(), которая выдает индекс массы тела, если на входе задать вес (аргумент weight =) в килограммах и рост (аргумент height =) в метрах. imt &lt;- function(weight, height) weight / height ^ 2 Проверим, что функция работает верно: w &lt;- c(60, 80, 120) h &lt;- c(1.6, 1.7, 1.8) imt(weight = w, height = h) ## [1] 23.43750 27.68166 37.03704 Очень легко перепутать и написать рост в сантиметрах. Было бы здорово предупредить об этом пользователя, показав ему предупреждающее сообщение, если рост больше, чем, например, 3. Это можно сделать с помощью функции warning() imt &lt;- function(weight, height) { if (height &gt; 3) warning(&quot;Рост в аргументе height больше 3: возможно, указан рост в сантиметрах, а не в метрах\\n&quot;) weight / height ^ 2 } imt(78, 167) ## Warning in imt(78, 167): Рост в аргументе height больше 3: возможно, указан рост в сантиметрах, а не в метрах ## [1] 0.002796802 В некоторых случаях ответ будет совершенно точно некорректным, хотя функция все посчитает и выдаст ответ, как будто так и надо. Например, если какой-то из аргументов функции imt() будет меньше или равен 0. В этом случае нужно прописать проверку на это условие, и если это действительно так, то выдать пользователю ошибку. imt &lt;- function(weight, height) { if (any(weight &lt;= 0 | height &lt;= 0)) stop(&quot;Индекс массы тела не может быть посчитан для отрицательных значений&quot;) if (height &gt; 3) warning(&quot;Рост в аргументе height больше 3: возможно, указан рост в сантиметрах, а не в метрах\\n&quot;) weight / height ^ 2 } imt(-78, 167) ## Error in imt(-78, 167): Индекс массы тела не может быть посчитан для отрицательных значений Когда вы попробуете самостоятельно прописывать предупреждения и ошибки в функциях, то быстро поймете, что ошибки - это вовсе не обязательно результат того, что где-то что-то сломалось и нужно паниковать. Совсем даже наоборот, прописанная ошибка - чья-то забота о пользователях, которых пытаются максимально проинформировать о том, что и почему пошло не так. Это естественно в начале работы с R (и вообще с программированием) избегать ошибок, конечно, в самом начале обучения большая часть из них остается непонятной. Но постарайтесь понять текст ошибки, вспомнить в каких случаях у вас возникала похожая ошибка. Очень часто этого оказывается достаточно чтобы понять причину ошибки даже если вы только-только начали изучать R. Ну а в дальнейшем я советую ознакомиться со средствами отладки кода в R для того, чтобы научиться справляться с ошибками в своем коде на более продвинутом уровне. 5.3 Когда и зачем создавать функции? Когда стоит создавать функции? Существует “правило трех” — если у вас есть три куска очень похожего кода, то самое время превратить код в функцию. Это очень условное правило, но, действительно, стоит избегать копипастинга в коде. В этом случае очень легко ошибиться, а сам код становится нечитаемым. Есть и другой подход к созданию функций: их стоит создавать не столько для того, чтобы использовать тот же код снова, сколько для абстрагирования от того, что происходит в отдельных строчках кода. Если несколько строчек кода были написаны для того, чтобы решить одну задачу, которой можно дать понятное название (например, подсчет какой-то особенной метрики, для которой нет готовой функции в R), то этот код стоит обернуть в функцию. Если функция работает корректно, то теперь не нужно думать над тем, что происходит внутри нее. Вы ее можете мысленно представить как операцию, которая имеет определенный вход и выход — как и встроенные функции в R. Отсюда следует важный вывод, что хорошее название для функции — это очень важно. Очень, очень, очень важно. 5.4 Функции как объекты первого порядка Ранее мы убедились, что арифметические операторы — это тоже функции. На самом деле, практически все в R — это функции. Даже function — это функция function(). Даже скобочки (, { — это функции! А сами функции — это объекты первого порядка в R. Это означает, что с функциями вы можете делать практически все то же самое, что и с другими объектами в R (векторами, датафреймами и т.д.). Небольшой пример, который может взорвать ваш мозг: list(mean, min, `{`) ## [[1]] ## function (x, ...) ## UseMethod(&quot;mean&quot;) ## &lt;bytecode: 0x55b0a9afcd90&gt; ## &lt;environment: namespace:base&gt; ## ## [[2]] ## function (..., na.rm = FALSE) .Primitive(&quot;min&quot;) ## ## [[3]] ## .Primitive(&quot;{&quot;) Мы можем создать список из функций! Зачем — это другой вопрос, но ведь можем же! Еще можно создавать функции внутри функций,10 использовать функции в качестве аргументов функций, сохранять функции как переменные. Пожалуй, самое важное из этого всего - это то, что функция может быть аргументом в функции. Не просто название функции как строковая переменная, не результат выполнения функции, а именно сама функция. Это лежит в основе использования семейства функций apply() (@ref(apply_f) и многих фишек tidyverse. В Python дело обстоит похожим образом: функции там тоже являются объектами первого порядка, поэтому все эти фишки функционального программирования (с поправкой на синтаксис, конечно) будут работать и там. 5.5 Семейство функций apply() 5.5.1 Применение apply() для матриц Семейство? Да, их целое множество: apply(), lapply(),sapply(), vapply(),tapply(),mapply(), rapply()… Ладно, не пугайтесь, всех их знать не придется. Обычно достаточно первых двух-трех. Проще всего пояснить как они работают на простой матрице с числами: A &lt;- matrix(1:12, 3, 4) A ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Функция apply() предназначена для работы с матрицами (или многомерными массивами). Если вы скормите функции apply() датафрейм, то этот датафрейм будет сначала превращен в матрицу. Главное отличие матрицы от датафрейма в том, что в матрице все значения одного типа, поэтому будьте готовы, что сработает имплицитное приведение к общему типу данных. Например, если среди колонок датафрейма есть хотя бы одна строковая колонка, то все колонки станут строковыми. Теперь представим, что нам нужно посчитать что-нибудь (например, сумму) по каждой из строк. С помощью функции apply() вы можете в буквальном смысле “применить” функцию к матрице или датафрейму. Синтаксис такой: apply(X, MARGIN, FUN, ...), где X — данные, MARGIN это 1 (для строк), 2 (для колонок), c(1,2) для строк и колонок (т.е. для каждого элемента по отдельности), а FUN — это функция, которую вы хотите применить! apply() будет брать строки/колонки из X в качестве первого аргумента для функции. apply Заметьте, мы вставляем функцию без скобок и кавычек как аргумент в функцию. Это как раз тот случай, когда аргументом в функции выступает сама функция, а не ее название или результат ее выполнения. Давайте разберем на примере: apply(A, 1, sum) #сумма по каждой строчке ## [1] 22 26 30 apply(A, 2, sum) #сумма по каждой колонке ## [1] 6 15 24 33 apply(A, c(1,2), sum) #кхм... сумма каждого элемента ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Конкретно для подсчета сумм и средних по столбцам и строкам в R есть функции colSums(), rowSums(), colMeans() и rowMeans(), которые можно использовать как альтернативы apply() в данном случае. Если же мы хотим прописать дополнительные аргументы для функции, то их можно перечислить через запятую после функции: apply(A, 1, sum, na.rm = TRUE) ## [1] 22 26 30 apply(A, 1, weighted.mean, w = c(0.2, 0.4, 0.3, 0.1)) ## [1] 4.9 5.9 6.9 5.5.2 Анонимные функции Что делать, если мы хотим сделать что-то более сложное, чем просто применить одну функцию? А если функция принимает не первым, а вторым аргументом данные из матрицы? В этом случае нам помогут анонимные функции. Анонимные функции - это функции, которые будут использоваться один раз и без названия. Питонистам знакомо понятие лямбда-функций. Да, это то же самое. Например, мы можем посчитать отклонения от среднего без называния этой функции: apply(A, 1, function(x) x - mean(x)) #отклонения от среднего по строчке ## [,1] [,2] [,3] ## [1,] -4.5 -4.5 -4.5 ## [2,] -1.5 -1.5 -1.5 ## [3,] 1.5 1.5 1.5 ## [4,] 4.5 4.5 4.5 apply(A, 2, function(x) x - mean(x)) #отклонения от среднего по столбцу ## [,1] [,2] [,3] [,4] ## [1,] -1 -1 -1 -1 ## [2,] 0 0 0 0 ## [3,] 1 1 1 1 apply(A, c(1,2), function(x) x - mean(x)) #отклонения от одного значения, т.е. ноль ## [,1] [,2] [,3] [,4] ## [1,] 0 0 0 0 ## [2,] 0 0 0 0 ## [3,] 0 0 0 0 Как и в случае с обычной функцией, в качестве x выступает объект, с которым мы хотим что-то сделать, а дальше следует функция, которую мы собираемся применить к х. Можно использовать не х, а что угодно, как и в обычных функциях: apply(A, 1, function(whatevername) whatevername - mean(whatevername)) ## [,1] [,2] [,3] ## [1,] -4.5 -4.5 -4.5 ## [2,] -1.5 -1.5 -1.5 ## [3,] 1.5 1.5 1.5 ## [4,] 4.5 4.5 4.5 5.5.3 Другие функции семейства apply() Ок, с apply() разобрались. А что с остальными? Некоторые из них еще проще и не требуют индексов, например, lapply (для применения к каждому элементу списка) и sapply() - упрощенная версия lapply(), которая пытается по возможности “упростить” результат до вектора или матрицы. some_list &lt;- list(some = 1:10, list = letters) lapply(some_list, length) ## $some ## [1] 10 ## ## $list ## [1] 26 sapply(some_list, length) ## some list ## 10 26 Использование sapply() на векторе приводит к тем же результатам, что и просто применить векторизованную функцию обычным способом. sapply(1:10, sqrt) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 sqrt(1:10) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 Зачем вообще тогда нужен sapply(), если мы можем просто применить векторизованную функцию? Ключевое слово здесь векторизованная функция. Если функция не векторизована, то sapply() становится удобным вариантом для того, чтобы избежать итерирования с помощью циклов for. Еще одна альтернатива - это векторизация невекторизованной функции с помощью Vectorize(). Эта функция просто оборачивает функцию одним из вариантов apply(). Можно применять функции lapply() и sapply() на датафреймах. Поскольку фактически датафрейм - это список из векторов одинаковой длины (см. 2.11), то итерироваться эти функции будут по колонкам: heroes &lt;- read.csv(&quot;data/heroes_information.csv&quot;, na.strings = c(&quot;-&quot;, &quot;-99&quot;)) sapply(heroes, class) ## X name Gender Eye.color Race Hair.color ## &quot;integer&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; ## Height Publisher Skin.color Alignment Weight ## &quot;numeric&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;integer&quot; Еще одна функция из семейства apply() - функция replicate() - самый простой способ повторить одну и ту же операцию много раз. Обычно эта функция используется при симуляции данных и моделировании. Например, давайте сделаем выборку из логнормального распределения: samp &lt;- rlnorm(30) hist(samp) А теперь давайте сделаем 1000 таких выборок и из каждой возьмем среднее: sampdist &lt;- replicate(1000, mean(rlnorm(30))) hist(sampdist) Про функции для генерации случайных чисел и про визуализацию мы поговорим в следующие дни. Если хотите познакомиться с семейством apply() чуточку ближе, то рекомендую вот этот туториал. В заключение стоит сказать, что семейство функций apply() — это очень сильное колдунство, но в tidyverse оно практически полностью перекрывается функциями из пакета purrr. Впрочем, если вы поняли логику apply(), то при желании вы легко сможете переключиться на альтернативы из пакета purrr. #Введение в tidyverse {#tidy_intro} 5.6 Вселенная tidyverse tidyverse - это не один, а целое множество пакетов. Есть ключевые пакеты (ядро тайдиверса), а есть побочные - в основном для работы со специфическими видами данных. tidyverse — это набор пакетов: ggplot2, для визуализации tibble, для работы с тибблами, продвинутый вариант датафрейма tidyr, для формата tidy data readr, для чтения файлов в R purrr, для функционального программирования (замена семейства функций *apply()) dplyr, для преобразованиия данных stringr, для работы со строковыми переменными forcats, для работы с переменными-факторами Полезно также знать о следующих пакетах, не включенных в ядро, но также считающихся частью тайдиверса: vroom, для быстрой загрузки табоичных данных readxl, для чтения .xls и .xlsx jsonlite, для работы с JSON xml, для работы с XML DBI, для работы с базами данных rvest, для веб-скреппинга lubridate, для работы с временем tidytext, для работы с текстами и корпусами glue, для продвинутого объединения строк magrtittr, с несколькими вариантами pipe оператора tidymodels, для моделирования и машинного обучения11 dtplyr, для ускорения dplyr за счет перевод синтаксиса на data.table И это еще не все пакеты tidyverse! Есть еще много других небольших пакетов, которые тоже считаются частью tidyverse. Кроме официальных пакетов tidyverse есть множество пакетов, которые пытаются соответствовать принципам tidyverse и дополняют его. Все пакеты tidyverse объединены tidy философией и взаимосовместимым синтаксисом. Это означает, что, во многих случаях даже не нужно думать о том, из какого именно пакета тайдиверса пришла функция. Можно просто установить и загрузить пакет tidyverse. install.packages(&quot;tidyverse&quot;) Пакет tidyverse — это такой пакет с пакетами. library(&quot;tidyverse&quot;) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.3 ✓ purrr 0.3.4 ## ✓ tibble 3.1.2 ✓ dplyr 1.0.6 ## ✓ tidyr 1.1.3 ✓ stringr 1.4.0 ## ✓ readr 1.4.0 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() Подключение пакета tidyverse автоматически приводит к подключению ядра tidyverse, остальные же пакеты нужно подключать дополнительно при необходимости. 5.7 Загрузка данных с помощью readr Стандартной функцией для чтения .csv файлов в R является функция read.csv(), но мы будем использовать функцию read_csv() из пакета readr. Синтаксис функции read_csv() очень похож на read.csv(): первым аргументом является путь к файлу (в том числе можно использовать URL), некоторые остальные параметры тоже совпадают. heroes &lt;- read_csv(&quot;data/heroes_information.csv&quot;, na = c(&quot;-&quot;, &quot;-99&quot;)) ## Warning: Missing column names filled in: &#39;X1&#39; [1] ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## X1 = col_double(), ## name = col_character(), ## Gender = col_character(), ## `Eye color` = col_character(), ## Race = col_character(), ## `Hair color` = col_character(), ## Height = col_double(), ## Publisher = col_character(), ## `Skin color` = col_character(), ## Alignment = col_character(), ## Weight = col_double() ## ) Подробнее про импорт данных, в том числе в tidyverse, смотри в @ref(real_data). ##tibble Когда мы загрузили данные с помощью read_csv(), то мы получили tibble, а не data.frame: class(heroes) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Тиббл (tibble) - это такой “усовершенствованный” data.frame. Почти все, что работает с data.frame, работает и с тибблами. Однако у тибблов есть свои дополнительные фишки. Самая очевидная из них - более аккуратный вывод в консоль: heroes Выводятся только первые 10 строк, если какие-то колонки не влезают на экран, то они просто перечислены внизу. Ну а тип данных написан прямо под названием колонки. Функции различных пакетов tidyverse сами конвертируют в тиббл при необходимости. Если же нужно это сделать самостоятельно, то можно это сделать так: heroes_df &lt;- as.data.frame(heroes) #создаем простой датафрейм class(heroes_df) ## [1] &quot;data.frame&quot; as_tibble(heroes_df) #превращаем обратно в тиббл В дальнейшем мы будем работать только с tidyverse, а это значит, что только с тибблами, а не обычными датафреймами. Тем не менее, тибблы и датафреймы будут в дальнейшем использоваться как синонимы. Можно создавать тибблы вручную с помощью функции tibble(), которая работает аналогично функции data.frame(): tibble( a = 1:3, b = letters[1:3] ) 5.8 magrittr::%&gt;% Оператор %&gt;% называется “пайпом” (pipe), т.е. “трубой.” Он означает, что следующая функция (справа от пайпа) принимает на вход в качестве первого аргумента результат выполнения предыдущей функции (той, что слева). Фактически, это примерно то же самое, что и вставлять результат выполнения функции в качестве первого аргумента в другую функцию. Просто выглядит это красивее и читабельнее. Как будто данные пропускаются через трубы функций или конвеерную ленту на заводе, если хотите. А то, что первый параметр функции - это почти всегда данные, работает нам здесь на руку. Этот оператор взят из пакета magrittr12. Возможно, даже если вы не захотите пользоваться tidyverse, использование пайпов Вам понравится. Важно понимать, что пайп не дает какой-то дополнительной функциональности или дополнительной скорости работы13. Он создан исключительно для читабельности и комфорта. С помощью пайпов вот эту команду… sum(sqrt(abs(sin(1:22)))) ## [1] 16.72656 …можно переписать вот так: 1:22 %&gt;% sin() %&gt;% abs() %&gt;% sqrt() %&gt;% sum() ## [1] 16.72656 В очень редких случаях результат выполнения функции нужно вставить не на первую позицию (или же мы хотим использовать его несколько раз). В этих случаях можно использовать ., чтобы обозначить, куда мы хотим вставить результат выполнения выражения слева от %&gt;%. &quot;Всем привет!&quot; %&gt;% c(&quot;--&quot;, ., &quot;--&quot;) ## [1] &quot;--&quot; &quot;Всем привет!&quot; &quot;--&quot; 5.9 Главные пакеты tidyverse: dplyr и tidyr dplyr14 — это самая основа всего tidyverse. Этот пакет предоставляет основные функции для манипуляции с тибблами. Пакет dplyr является наследником и более усовершенствованной версией plyr, так что если увидите использование пакета plyr, то, скорее всего, скрипт был написан очень давно. Пакет tidyr дополняет dplyr, предоставляя полезные функции для тайдификации тибблов. Тайдификация (“аккуратизация”) данных означает приведение табличных данных к такому формату, в котором: Каждая переменная имеет собственный столбец Каждый наблюдение имеет собственную строку Каждое значение имеет свою собственную ячейку Впрочем, многие функции dplyr часто используются при тайдификации, так же как и многие функции tidyr имеет применение вне тайдификации. В общем, функционал этих двух пакетов несколько смешался, поэтому мы будем рассматривать их вместе. А чтобы представлять, какая функция относится к какому пакету (хотя запоминать это необязательно), я буду использовать запись с двумя двоеточиями ::, которая обычно используется для использования функции без подгрузки всего пакета, при первом упоминании функции. Пакет tidyr — это более усовершенствованная версия пакета reshape2, который в свою очередь является усовершенствованной версией reshape. По аналогии с plyr, если вы видите использование этих пакетов, то это указывает на то, что перед вами морально устаревший код. Код с использованием dplyr и tidyrсильно непохож на то, что мы видели раньше. Большинство функций dplyr и tidyr работают с целым тибблом сразу, принимая его в качестве первого аргумента и возвращая измененный тиббл. Это позволяет превратить весь код в последовательный набор применяемых функций, соединенный пайпами. На практике это выглядит очень элегантно, и вы в этом скоро убедитесь. 5.10 Работа с колонками тиббла 5.10.1 Выбор колонок: dplyr::select() Функция dplyr::select() позволяет выбирать колонки по номеру или имени (кавычки не нужны). heroes %&gt;% select(1,5) heroes %&gt;% select(name, Race, Publisher, `Hair color`) Обратите внимание, если в названии колонки присутствует пробел или, например, колонка начинается с цифры или точки и цифры, то это синтаксически невалидное имя (2.5.3). Это не значит, что такие названия колонок недопустимы. Но такие названия колонок нужно обособлять ` грависом (правый штрих, на клавиатуре находится там же где и буква ё и ~). Еще обратите внимание на то, что функции tidyverse не изменяют сами изначальные тибблы/датафреймы. Это означает, что если вы хотите полученный результат сохранить, то нужно добавить присвоение: heroes_some_cols &lt;- heroes %&gt;% select(name, Race, Publisher, `Hair color`) heroes_some_cols 5.10.2 Мини-язык tidyselect для выбора колонок Для выбора столбцов (не только в select(), но и для других функций tidyverse) используется специальный мини-язык tidyselect из одноименного пакета15. tidyselect дает очень широкие возможности для выбора колонок. Можно использовать оператор : для выбора нескольких соседних колонок (по аналогии с созданием числового вектора с шагом 1). heroes %&gt;% select(name:Publisher) heroes %&gt;% select(name:`Eye color`, Publisher:Weight) Используя ! можно вырезать ненужные колонки. heroes %&gt;% select(!X1) heroes %&gt;% select(!(Gender:Height)) Другие известные нам логические операторы (&amp; и |) тоже работают в tidyselect. В дополнение к логическим операторам и :, в tidyselect есть набор вспомогательных функций, работающих исключительно в контексте выбора колонок с помощью tidyselect. Вспомогательная функция last_col() позволит обратиться к последней колонке тиббла: heroes %&gt;% select(name:last_col()) А функция everything() позволяет выбрать все колонки. heroes %&gt;% select(everything()) При этом everything() не будет дублировать выбранные колонки, поэтому можно использовать everything() для перестановки колонок в тиббле: heroes %&gt;% select(name, Publisher, everything()) Впрочем, для перестановки колонок удобнее использовать специальную функцию relocate() (@ref(tidy_relocate)) Можно даже выбирать колонки по паттернам в названиях. Например, с помощью ends_with() можно выбрать все колонки, заканчивающиеся одинаковым суффиксом: heroes %&gt;% select(ends_with(&quot;color&quot;)) Аналогично, с помощью функции starts_with() можно найти колонки с одинаковым префиксом, с помощью contains() — все колонки с выбранным паттерном в любой части названия колонки16. heroes %&gt;% select(starts_with(&quot;Eye&quot;) &amp; ends_with(&quot;color&quot;)) heroes %&gt;% select(contains(&quot;eight&quot;)) Ну и наконец, можно выбирать по содержимому колонок с помощью where(). Это напоминает применение sapply()(@ref(apply_other)) на датафрейме для индексирования колонок: в качестве аргумента для where принимается функция, которая применяется для каждой из колонок, после чего выбираются только те колонки, для которых было получено TRUE. heroes %&gt;% select(where(is.numeric)) Функция where() дает невиданную мощь. Например, можно выбрать все колонки без NA: heroes %&gt;% select(where(function(x) !any(is.na(x)))) ###Переименование колонок: dplyr::rename() Внутри select() можно не только выбирать колонки, но и переименовывать их: heroes %&gt;% select(id = X1) Однако удобнее для этого использовать специальную функцию dplyr::rename(). Синтаксис у нее такой же, как и у select(), но rename() не выбрасывает колонки, которые не были упомянуты. heroes %&gt;% rename(id = X1) Для массового переименования колонок можно использовать функцию rename_with(). Эта функция так же использует tidyselect синтаксис для выбора колонок (по умолчанию выбираются все колонки) и применяет функцию в качестве аргумента, которая изменяет heroes %&gt;% rename_with(make.names) ###Перестановка колонок: dplyr::relocate() {#tidy_relocate} Для изменения порядка колонок можно использовать функцию relocate(). Она тоже работает похожим образом на select() и rename()17. Как и rename(), функция relocate() не выкидывает неиспользованные колонки: heroes %&gt;% relocate(Publisher) При этом relocate() имеет дополнительные параметры .after = и .before =, которые позволяют выбирать, куда поместить выбранные колонки. heroes %&gt;% relocate(Publisher, .after = name) relocate() очень хорошо работает в сочетании с выбором колонок с помощью tidyselect. Например, можно передвинуть в одно место все колонки с одним типом данных: heroes %&gt;% relocate(Publisher, where(is.numeric), .after = name) Последняя важная функция для выбора колонок — pull(). Эта функция делает то же самое, что и индексирование с помощью $, т.е. вытаскивает из тиббла вектор с выбранным названием. Это лучше вписывается в логику tidyverse, поскольку позволяет извлечь колонку из тиббла с использованием пайпа: heroes %&gt;% select(Height) %&gt;% pull() %&gt;% head() ## [1] 203 191 185 203 NA 193 heroes %&gt;% pull(Height) %&gt;% head() ## [1] 203 191 185 203 NA 193 У функции pull() есть аргумент name =, который позволяет создать проименованный вектор: heroes %&gt;% pull(Height, name) %&gt;% head() ## A-Bomb Abe Sapien Abin Sur Abomination Abraxas ## 203 191 185 203 NA ## Absorbing Man ## 193 В отличие от базового R, tidyverse нигде не сокращает имплицитно результат вычислений до вектора, поэтому функция pull() - это основной способ извлечения колонки из тиббла как вектора. 5.11 Работа со строками тиббла 5.11.1 Выбор строк по номеру: dplyr::slice() Начнем с выбора строк. Функция dplyr::slice() выбирает строчки по их числовому индексу. heroes %&gt;% slice(1:3) 5.11.2 Выбор строк по условию: dplyr::filter() Функция dplyr::filter() делает то же самое, что и slice(), но уже по условию. Причем для условий нужно использовать не векторы из тиббла, а название колонок (без кавычек) как будто бы они были переменными в окружении. heroes %&gt;% filter(Publisher == &quot;DC Comics&quot;) 5.11.3 Семейство функций slice() У функции slice() есть множество родственников, которые объединяют функционал обычного slice() и filter(). Например, с помощью функций dplyr::slice_max() и dplyr::slice_min() можно выбрать заданное количество строк, содержащих наибольшие или наименьшие значения по колонке соответственно: heroes %&gt;% slice_max(Weight, n = 3) heroes %&gt;% slice_min(Weight, n = 3) Функция slice_sample() позволяет выбирать заданное количество случайных строчек: heroes %&gt;% slice_sample(n = 3) Или же долю строчек: heroes %&gt;% slice_sample(prop = .01) Если поставить значение параметра prop = равным 1, то таким образом можно перемешать порядок строчек в тиббле: heroes %&gt;% slice_sample(prop = 1) 5.11.4 Удаление строчек с NA: tidyr::drop_na() Если нужно выбрать только строчки без пропущенных значений, то можно воспользоваться удобной функцией tidyr::drop_na(). heroes %&gt;% drop_na() Можно выбрать колонки, наличие NA в которых будет приводить к удалению соответствующих строчек (не затрагивая другие строчки, в которых есть NA в остальных столбцах). heroes %&gt;% drop_na(Weight) Для выбора колонок в drop_na() используется tidyselect, с которым мы недавно познакомились (5.10.2). 5.11.5 Сортировка строк: dplyr::arrange() Функция dplyr::arrange() сортирует строчки от меньшего к большему (или по алфавиту - для текстовых значений) по выбранной колонке. heroes %&gt;% arrange(Weight) Чтобы отсортировать в обратном порядке, воспользуйтесь функцией desc(). heroes %&gt;% arrange(desc(Weight)) Можно сортировать по нескольким колонкам сразу. В таких случаях удобно в качестве первой переменной выбирать переменную, обозначающую принадлежность к группе, а в качестве второй — континуальную числовую переменную: heroes %&gt;% arrange(Gender, desc(Weight)) 5.12 Создание колонок: dplyr::mutate() и dplyr::transmute() Функция dplyr::mutate() позволяет создавать новые колонки в тиббле. heroes %&gt;% mutate(imt = Weight/(Height/100)^2) %&gt;% select(name, imt) %&gt;% arrange(desc(imt)) dplyr::transmute() - это аналог mutate(), который не только создает новые колонки, но и сразу же выкидывает все старые: heroes %&gt;% transmute(imt = Weight/(Height/100)^2) Внутри mutate() и transmute() мы можем использовать либо векторизованные операции (длина новой колонки должна равняться длине датафрейма), либо операции, которые возвращают одно значение. В последнем случае значение будет одинаковым на всю колонку, т.е. будет работать правило ресайклинга (2.8.3): heroes %&gt;% transmute(name, weight_mean = mean(Weight, na.rm = TRUE)) Однако в функциях mutate() и transmute() правило ресайклинга не будет работать в остальных случаях: если полученный вектор будет не равен 1 или длине датафрейма, то мы получим ошибку. heroes %&gt;% mutate(one_and_two = 1:2) ## Error: Problem with `mutate()` column `one_and_two`. ## ℹ `one_and_two = 1:2`. ## ℹ `one_and_two` must be size 734 or 1, not 2. Это не баг, а фича: авторы пакета dplyr считают, что ресайклинг кратных друг другу векторов — это слишком удобное место для выстрелов себе в ногу. Поэтому в таких случаях разработчики dplyr рекомендуют использовать функцию rep(), знакомую нам уже очень давно (2.8). heroes %&gt;% mutate(one_and_two = rep(1:2, length.out = nrow(.))) 5.13 Агрегация данных в тиббле 5.13.1 Подытоживание: summarise() Аггрегация по группам - это очень часто возникающая задача, например, это может использоваться для усреднения данных по испытуемым или условиям. Сделать аггрегацию в датафрейме удобной Хэдли Уикхэм пытался еще в предшественнике dplyr, пакете plyr. dplyr позволяет делать аггрегацию очень симпатичным и понятным способым. Аггрегация в dplyr состоит из двух этапов: группировки (group_by()) и подытоживания (summarise()). Начнем с последнего. Функция dplyr::summarise()18 позволяет аггрегировать данные в тиббле. Работает она очень похоже на mutate(), но если внутри mutate() используются векторизованные функции, возвращающие вектор такой же длины, что и колонки, использовавшиеся для расчетов, то в summarise() используются функции, которые возвращают вектор длиной 1. Например, min(), mean(), max() и т.д. Можно создавать несколько колонок через запятую (это работает и для mutate()). heroes %&gt;% mutate(imt = Weight/(Height/100)^2) %&gt;% summarise(min(imt, na.rm = TRUE), max(imt, na.rm = TRUE)) В dplyr есть дополнительные суммирующие функции для более удобного индексирования в стиле tidyverse. Например, функции dplyr::nth(), dplyr::first() и dplyr::last(), которые позволяют вытаскивать значения из вектора по индексу (что-то вроде slice(), но для векторов) heroes %&gt;% mutate(imt = Weight/(Height/100)^2) %&gt;% arrange(imt) %&gt;% summarise(first = first(imt), tenth = nth(imt, 10), last = last(imt)) В отличие от mutate(), функции внутри summarise() вполне позволяют функциям внутри возвращать вектор из нескольких значений, создавая тиббл такой же длины, как и получившийся вектор. heroes %&gt;% mutate(imt = Weight/(Height/100)^2) %&gt;% summarise(imt_range = range(imt, na.rm = TRUE)) #функция range() возвращает вектор из двух значений: минимальное и максимальное 5.13.2 Группировка: group_by() dplyr::group_by() - это функция для группировки данных в тиббле по дискретной переменной для дальнейшей аггрегации с помощью summarise(). После применения group_by() тиббл будет выглядеть так же, но у него появятся атрибут groups19: heroes %&gt;% group_by(Gender) Если после этого применить на тиббле функцию summarise(), то мы получим не тиббл длиной один, а тиббл со значением для каждой из групп. heroes %&gt;% mutate(imt = Weight/(Height/100)^2) %&gt;% group_by(Gender) %&gt;% summarise(min(imt, na.rm = TRUE), max(imt, na.rm = TRUE)) Схематически это выглядит вот так: 5.13.3 Подсчет строк: dplyr::n(), dplyr::count() Для подсчет количества значений можно воспользоваться функцией n(). heroes %&gt;% group_by(Gender) %&gt;% summarise(n = n()) Функция n() вместе с group_by() внутри filter() позволяет удобным образом “отрезать” от тиббла редкие группы… heroes %&gt;% group_by(Race) %&gt;% filter(n() &gt; 10) %&gt;% select(name, Race) или же наоборот, выделить только маленькие группы: heroes %&gt;% group_by(Race) %&gt;% filter(n() == 1) %&gt;% select(name, Race) Таблицу частот можно создать без group_by() и summarise(n = n()). Функция count() заменяет эту конструкцию: heroes %&gt;% count(Gender) Эту таблицу частот удобно сразу проранжировать, указав в параметре sort = значение TRUE. heroes %&gt;% count(Gender, sort = TRUE) Функция count(), несмотря на свою простоту, является одной из наиболее используемых в tidyverse. 5.13.4 Уникальные значения: dplyr::distinct() dplyr::distinct() - это более быстрый аналог unique(), позволяет извлекать уникальные значения для одной или нескольких колонок. heroes %&gt;% distinct(Gender) heroes %&gt;% distinct(Gender, Race) Иногда нужно аггрегировать данные, но при этом сохранить исходную структуру тиббла. Например, нужно посчитать размер групп или посчитать средние значения по группе для последующего сравнения с индивидуальными значениями. 5.13.5 Создание колонок с группировкой В tidyverse это можно сделать с помощью сочетания group_by() и mutate() (вместо summarise()): heroes %&gt;% group_by(Race) %&gt;% mutate(Race_n = n()) %&gt;% select(Race, name, Gender, Race_n) Результаты аггрегации были записаны в отдельную колонку, при этом значения этой колонки внутри одной группы повторяются: 5.14 Трансформация нескольких колонок: dplyr::across() Допустим, вы хотите посчитать среднюю массу и рост, группируя по полу супергероев. Можно посчитать это внутри одного summarise(), использую запятую: heroes %&gt;% group_by(Gender) %&gt;% summarise(height = mean(Height, na.rm = TRUE), weight = mean(Weight, na.rm = TRUE)) Если таких колонок будет много, то это уже станет сильно неудобным, нам придется много копировать код, а это чревато ошибками и очень скучно. Поэтому в dplyr есть функция для операций над несколькими колонками сразу: dplyr::across()20. Эта функция работает похожим образом на функции семейства apply() и использует tidyselect для выбора колонок. Таким образом, конструкции с функцией across() можно разбить на три части: Выбор колонок с помощью tidyselect. Здесь работают все те приемы, которые мы изучили при выборе колонок (5.10.2). Собственно применение функции across(). Первый аргумент .col — колонки, выбранные на первом этапе с помощью tidyselect, по умолчанию это everything(), т.е. все колонки. Второй аргумент .fns — это функция или целый список из функций, которые будут применены к выбранным колонкам. Если функции требуют дополнительных аргументов, то они могут быть перечислены внутри across(). Использование summarise() или другой функции dplyr. В этом случае в качестве аргумента для функции используется результат работы функции across(). Вот такой вот бутерброд выходит. Давайте посмотрим, как это работает на практике и посчитаем среднее значение по колонкам Height и Weight. heroes %&gt;% group_by(Gender) %&gt;% summarise(across(c(Height,Weight), mean)) Здесь мы столкнулись с уже известной нам проблемой: функция mean() при столкновении хотя бы с одним NA будет возвращать NA, если мы не изменим параметр na.rm =. Как и в случае с функциями семейства apply() (@ref(apply_f)), дополнительные параметры для функции можно перечислить через запятую после самой функции: heroes %&gt;% group_by(Gender) %&gt;% summarise(across(c(Height, Weight), mean, na.rm = TRUE)) До этого мы просто использовали выбор колонок по их названию. Но именно внутри across() использование tidyselect раскрывается как удивительно элегантный и мощный инструмент. Например, можно посчитать среднее для всех numeric колонок: heroes %&gt;% drop_na(Height, Weight) %&gt;% group_by(Gender) %&gt;% summarise(across(where(is.numeric), mean, na.rm = TRUE)) Или длину строк для строковых колонок. Для этого нам понадобится вспомнить, как создавать анонимные функции (@ref(anon_f)). heroes %&gt;% group_by(Gender) %&gt;% summarise(across(where(is.character), function(x){mean(nchar(x), na.rm = TRUE)})) Или же даже посчитать и то, и другое внутри одного summarise()! heroes %&gt;% group_by(Gender) %&gt;% summarise(across(where(is.numeric), mean, na.rm = TRUE), across(where(is.character), function(x){mean(nchar(x), na.rm = TRUE)})) Внутри одного across() можно применить не одну функцию к каждой из выбранных колонок, а сразу несколько функций для каждой из колонок. Для этого нам нужно использовать список функций (желательно - проименованный). heroes %&gt;% group_by(Gender) %&gt;% summarise(across(c(Height, Weight), list(minimum = min, average = mean, maximum = max), na.rm = TRUE)) Вот нам и понадобился список функций (@ref(functions_objects))! heroes %&gt;% group_by(Gender) %&gt;% summarise(across(c(Height, Weight), list(min = function(x) min(x, na.rm = TRUE), mean = function(x) mean(x, na.rm = TRUE), max = function(x) max(x, na.rm = TRUE), na_n = function(x, ...) sum(is.na(x))) ) ) Хотя основное применение функции across() — это массовое подытоживание с помощью summarise(), across() можно использовать и с другими функциями dplyr. Например, можно делать массовые операции с колонками с помощью mutate(): heroes %&gt;% mutate(across(where(is.character), as.factor)) Менее очевидный способ применения across() - использование across() внутри count() вместе с функцией n_distinct(), которая считает количество уникальных значений в векторе. Это позволяет посмотреть таблицу частот для группирующих переменных: heroes %&gt;% select(where(function(x) n_distinct(x) &lt;= 6)) heroes %&gt;% count(across(where(function(x) n_distinct(x) &lt;= 6))) 5.15 Объединение нескольких датафреймов 5.15.1 Соединение структурно схожих датафреймов: bind_rows(), bind_cols() Для начала создадим следующие тибблы и сохраним их как dc, marvel и other_publishers: dc &lt;- heroes %&gt;% filter(Publisher == &quot;DC Comics&quot;) %&gt;% group_by(Gender) %&gt;% summarise(weight_mean = mean(Weight, na.rm = TRUE)) dc marvel &lt;- heroes %&gt;% filter(Publisher == &quot;Marvel Comics&quot;) %&gt;% group_by(Gender) %&gt;% summarise(weight_mean = mean(Weight, na.rm = TRUE)) marvel other_publishers &lt;- heroes %&gt;% filter(!(Publisher %in% c(&quot;DC Comics&quot;,&quot;Marvel Comics&quot;))) %&gt;% group_by(Gender) %&gt;% summarise(weight_mean = mean(Weight, na.rm = TRUE)) other_publishers Несколько тибблов можно объединить вертикально с помощью функции bind_rows(). Для корректного объединения тибблы должны иметь одинаковые названия колонок. bind_rows(dc, marvel) Чтобы соединить тибблы горизонтально, воспользуйтесь функцией bind_cols(). bind_cols(dc, marvel) ## New names: ## * Gender -&gt; Gender...1 ## * weight_mean -&gt; weight_mean...2 ## * Gender -&gt; Gender...3 ## * weight_mean -&gt; weight_mean...4 Функции bind_rows() и bind_cols() могут работать не только с двумя, но сразу с несколькими датафреймами. bind_rows(dc, marvel, other_publishers) На входе в функции bind_rows() и bind_cold() можно подавать как сами датафреймы или тибблы через запятую, так и список из датафреймов/тибблов. heroes_list_of_df &lt;- list(DC = dc, Marvel = marvel, Other = other_publishers) bind_rows(heroes_list_of_df) Чтобы не потерять, из какого датафрейма какие данные, можно указать любое строковое значение (название будущей колонки) для необязательного аргумента .id =. bind_rows(heroes_list_of_df, .id = &quot;Publisher&quot;) bind_rows() обычно используется, когда ваши данные находятся в разных файлах с одинаковой структурой. Тогда вы можете прочитать все таблицы в папке, сохранить их в качестве списка из датафреймов и объединить в один датафрейм с помощью bind_rows(). 5.15.2 Реляционные данные: *_join() В реальности иногда возникает ситуация, когда нужно соединить две таблички, у которых есть общий столбец (или несколько столбцов), но все остальные столбцы различаются. Табличек может быть и больше, это может быть целая сеть таблиц, некоторые из которых содержат основные данные, а некоторые - дополнительные, которые необходимо на определенном этапе “включить” в анализ. Например, таблица с расшифровкой аббревиатур или сокращений вроде коротких названий стран или таблица телефонных кодов разных стран. Совокупность нескольких связанных друг с другом таблиц называют реляционными данными. В случае с реляционными данными простых bind_rows() и bind_cols() становится недостаточно. Эти две таблички нужно объединить (join). Эта задача обычно возникает не очень часто, обычно это происходит один-два раза в одном проекте, когда нужно дополнить имеющиеся данные дополнительной информацией извне или объединить два набора данных, обрабатывавшихся в разных программах. Всякий раз, когда такая задача возникает, это доставляет много боли. dplyr предлагает интуитивно понятный инструмент для объединения реляционных данных - семейство функций *_join(). Возьмем для примера два тиббла band_members и band_instruments, встроенных в dplyr специально для демонстрации работы функций *_join(). band_members band_instruments У этих двух тибблов есть колонка с одинаковым названием, которая по своему смыслу соединяет данные обоих тибблов. Такая колонка называется ключом. Ключ должен однозначно идентифицировать наблюдения21. Давайте попробуем посоединять band_members и band_instruments разными вариантами *_join() и посмотрим, что у нас получится. Все эти функции имеют на входе два обязательных аргумента (x = и y =) в которые мы должны подставить два датафрейма/тиббла которые мы хотим объединить. Главное различие между этими функциями заключается в том, что они будут делать, если уникальные значения в ключах x и y не соответствуют друг другу. left_join(): band_members %&gt;% left_join(band_instruments) ## Joining, by = &quot;name&quot; left_join() - это самая простая для понимания и самая используемая функция из семейства *_join(). Она как бы “дополняет” информацию из первого тиббла вторым тибблом. В этом случае сохраняются все уникальные наблюдения в x, но отбрасываются лишние наблюдения в тиббле y. Тем значениям, которым не нашлось соотвествия в y, в колонках, взятых их y, ставятся значения NA. Вы можете сами задать колонки-ключи параметром by =, по умолчанию это все колонки с одинаковыми названиями в двух тибблах. band_members %&gt;% left_join(band_instruments, by = &quot;name&quot;) Часто случается, что колонки-ключи называются по-разному в двух тибблах. Их необязательно переименовывать, можно поставить соответстие вручную используя проименованный вектор: band_members %&gt;% left_join(band_instruments2, by = c(&quot;name&quot; = &quot;artist&quot;)) right_join(): band_members %&gt;% right_join(band_instruments) ## Joining, by = &quot;name&quot; right_join() отбрасывает строчки в x, которых не было в y, но сохраняет соответствующие строчки y - left_join() наоборот. full_join(): band_members %&gt;% full_join(band_instruments) ## Joining, by = &quot;name&quot; Функция full_join() сохраняет все строчки и из x и y. Пожалуй, наиболее используемая функция после left_join() — благодаря full_join() вы точно ничего не потеряете при объединении. inner_join(): band_members %&gt;% inner_join(band_instruments) ## Joining, by = &quot;name&quot; Функция full_join() сохраняет только строчки, которые присутствуют и в x, и в y. semi_join(): band_members %&gt;% semi_join(band_instruments) ## Joining, by = &quot;name&quot; anti_join(): band_members %&gt;% anti_join(band_instruments) ## Joining, by = &quot;name&quot; Функции semi_join() и anti_join() не присоединяют второй датафрейм/тиббл (y) к первому. Вместо этого они используются как некоторый словарь-фильтр для отделения только тех значений в x, которые есть в y (semi_join()) или, наоборот, которых нет в y (anti_join()). 5.16 Tidy data: tidyr::pivot_longer(), tidyr::pivot_wider() Принцип tidy data предполагает, что каждая строчка содержит в себе одно измерение, а каждая колонка - одну характеристику. Тем не менее, это не говорит однозначно о том, как именно хранить повторные измерения. Их можно хранить как одну колонку для каждого измерения (широкий формат) и как две колонки: одна колонка - для идентификатора измерения, другая колонка - для записи самого измерения. Это лучше понять на примере. Например, вес до и после прохождения курса. Как это лучше записать - как два числовых столбца (один испытуемый - одна строка) или же создать отдельную “группирующую” колонку, в которой будет написано время измерения, а в другой - измеренные значения (одно измерение - одна строка)? Широкий формат: Студент До курса по R После курса по R Маша 70 63 Рома 80 74 Антонина 86 71 Длинный\" формат: Студент Время измерения Масса (кг) Маша До курса по R 70 Рома До курса по R 80 Антонина До курса по R 86 Маша После курса по R 63 Рома После курса по R 74 Антонина После курса по R 71 На самом деле, оба варианта приемлимы, оба варианта возможны в реальных данных, а разные функции и статистические пакеты могут требовать от вас как длинный, так и широкий форматы. Таким образом, нам нужно научиться переводить из широкого формата в длинный и наоборот. tidyr::pivot_longer(): из широкого в длинный формат tidyr::pivot_wider(): из длинного в широкий формат new_diet &lt;- tibble( student = c(&quot;Маша&quot;, &quot;Рома&quot;, &quot;Антонина&quot;), before_r_course = c(70, 80, 86), after_r_course = c(63, 74, 71) ) new_diet Тиббл new_diet - это пример широкого формата данных. Превратим тиббл new_diet длинный: new_diet %&gt;% pivot_longer(cols = before_r_course:after_r_course, names_to = &quot;measurement_time&quot;, values_to = &quot;weight_kg&quot;) А теперь обратно в короткий: new_diet %&gt;% pivot_longer(cols = before_r_course:after_r_course, names_to = &quot;measurement_time&quot;, values_to = &quot;weight_kg&quot;) %&gt;% pivot_wider(names_from = &quot;measurement_time&quot;, values_from = &quot;weight_kg&quot;) Функция, которая создает другие функции, называется фабрикой функций.↩︎ Как и пакет tidyverse, tidymodels — это пакет с несколькими пакетами.↩︎ Если быть точным, то оператор %&gt;% был импортирован во все основные пакеты tidyverse, а сам пакет magrittr не входит в базовый набор tidyverse. Тем не менее, в самом magrittr есть еще несколько интересных операторов.↩︎ Даже наоборот, использование пайпов незначительно снижает скорость выполнения команды.↩︎ Есть споры о том, как это правильно читать. Используемые варианты: диплаер, диплюр, диплир.↩︎ Как и в случае с magrittr, пакет tidyselect не содержатся в базовом tidyverse, но функции импортируются основыми пакетами tidyverse.↩︎ Выбранный паттерн будет найден посимвольно, если же вы хотите искать по регулярным выражениям, то вместо contains() нужно использовать matches().↩︎ relocate() не позволяет переименовывать колонки в отличие от select() и rename()↩︎ У функции dplyr::summarise() есть синоним dplyr::summarize(), которая делает абсолбтно то же самое. Просто потому что в американском английском и британском английском это слово пишется по-разному.↩︎ Снять группировку можно с помощью функции ungroup().↩︎ Функция across() появилась в пакете dplyr относительно недавно, до этого для работы с множественными колонками в tidyverse использовались многочисленные функции *_at(), *_if(), *_all(), например, summarise_at(), summarise_if(), summarize_all(). Эти функции до сих пор присутствуют в dplyr, но считаются устаревшими. Другая альтернатива - использование пакета purrr (??) или семейства функций apply() (@ref(apply_f)).↩︎ Если ключи будут неуникальными, то функции *_join() не будут выдавать ошибку. Вместо этого они добавят в итоговую таблицу все возможные пересечения повторяющихся ключей. С этим нужно быть очень осторожным, поэтому рекомендуется, во-первых, проверять уникальность ключей на входе и, во-вторых, проверять тиббл на выходе. Ну или использовать эту особенность работы функции *_join() себе во благо.↩︎ "],["viz-1.html", "6 Визуализация данных 6.1 Зачем визуализировать данные? 6.2 Основы ggplot2 6.3 Столбчатые диаграммы (barplots) 6.4 Факторы 6.5 Дотплот 6.6 Гистограммы 6.7 Функции плотности 6.8 Точки, джиттер (jitter), вайолинплот (violinplot), ящики с усами (boxplot), 6.9 Фасетизация 6.10 Визуализация комбинаций признаков", " 6 Визуализация данных library(&quot;tidyverse&quot;) 6.1 Зачем визуализировать данные? 6.1.1 Квартет Анскомба В работе Anscombe, F. J. (1973). “Graphs in Statistical Analysis” представлен следующий датасет: quartet &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/anscombe.csv&quot;) quartet quartet %&gt;% group_by(dataset) %&gt;% summarise(mean_X = mean(x), mean_Y = mean(y), sd_X = sd(x), sd_Y = sd(y), cor = cor(x, y), n_obs = n()) %&gt;% select(-dataset) %&gt;% round(2) 6.1.2 Датазаурус В работе Matejka and Fitzmaurice (2017) “Same Stats, Different Graphs” были представлены следующие датасеты: datasaurus &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/datasaurus.csv&quot;) datasaurus datasaurus %&gt;% group_by(dataset) %&gt;% summarise(mean_X = mean(x), mean_Y = mean(y), sd_X = sd(x), sd_Y = sd(y), cor = cor(x, y), n_obs = n()) %&gt;% select(-dataset) %&gt;% round(1) 6.2 Основы ggplot2 Пакет ggplot2 – современный стандарт для создания графиков в R. Для этого пакета пишут массу расширений. В сжатом виде информация про ggplot2 содержиться здесь. 6.2.1 Диаграмма рассеяния (Scaterplot) ggplot2 ggplot(data = diamonds, aes(carat, price)) + geom_point() dplyr, ggplot2 diamonds %&gt;% ggplot(aes(carat, price))+ geom_point() 6.2.2 Слои diamonds %&gt;% ggplot(aes(carat, price))+ geom_point()+ geom_smooth() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; diamonds %&gt;% ggplot(aes(carat, price))+ geom_smooth()+ geom_point() ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 6.2.3 aes() diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point() diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(color = &quot;green&quot;) diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(aes(color = cut)) diamonds %&gt;% ggplot(aes(carat, price, shape = cut))+ geom_point() diamonds %&gt;% ggplot(aes(carat, price, label = color))+ geom_text() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_label() Иногда аннотации налезают друг на друга: library(ggrepel) diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_text_repel() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color))+ geom_text_repel()+ geom_point() diamonds %&gt;% slice(1:100) %&gt;% ggplot(aes(carat, price, label = color, fill = cut))+ # fill отвечает за закрашивание geom_label_repel(alpha = 0.5)+ # alpha отвечает за прозрачность geom_point() 6.2.4 Оформление diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point() + labs(x = &quot;вес (в каратах)&quot;, y = &quot;цена (в долларах)&quot;, title = &quot;Связь цены и веса бриллиантов&quot;, subtitle = &quot;Данные взяты из датасеты diamonds&quot;, caption = &quot;график сделан при помощи пакета ggplot2&quot;)+ theme(legend.position = &quot;bottom&quot;) # у функции theme() огромный функционал 6.2.5 Логарифмические шкалы Рассмотрим словарь [Ляшевской, Шарова 2011] freqdict &lt;- read_tsv(&quot;https://github.com/agricolamz/2020-2021-ds4dh/raw/master/data/freq_dict_2011.csv&quot;) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## lemma = col_character(), ## pos = col_character(), ## freq_ipm = col_double() ## ) freqdict %&gt;% arrange(desc(freq_ipm)) %&gt;% mutate(id = 1:n()) %&gt;% slice(1:150) %&gt;% ggplot(aes(id, freq_ipm))+ geom_point() freqdict %&gt;% arrange(desc(freq_ipm)) %&gt;% mutate(id = 1:n()) %&gt;% slice(1:150) %&gt;% ggplot(aes(id, freq_ipm, label = lemma))+ geom_point()+ geom_text_repel()+ scale_y_log10() 6.2.6 annotate() Функция annotate добавляет geom к графику. diamonds %&gt;% ggplot(aes(carat, price, color = cut))+ geom_point()+ annotate(geom = &quot;rect&quot;, xmin = 4.8, xmax = 5.2, ymin = 17500, ymax = 18500, fill = &quot;red&quot;, alpha = 0.2) + annotate(geom = &quot;text&quot;, x = 4.7, y = 16600, label = &quot;помогите...\\n я в розовом\\nквадратике&quot;) Скачайте вот этот датасет и постройте диаграмму рассеяния. 6.3 Столбчатые диаграммы (barplots) Одна и та же информация может быть представлена в агрегированном и не агрегированном варианте: misspelling &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/misspelling_dataset.csv&quot;) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## correct = col_character(), ## spelling = col_character(), ## count = col_double() ## ) misspelling переменные spelling аггрегирована: для каждого значения представлено значение в столбце count, которое обозначает количество каждого из написаний переменные correct неаггрегированы: в этом столбце она повторяется, для того, чтобы сделать вывод, нужно отдельно посчитать количество вариантов Для аггрегированных данных используется geom_col() misspelling %&gt;% slice(1:20) %&gt;% ggplot(aes(spelling, count))+ geom_col() Перевернем оси: misspelling %&gt;% slice(1:20) %&gt;% ggplot(aes(spelling, count))+ geom_col()+ coord_flip() Для неаггрегированных данных используется geom_bar() misspelling %&gt;% ggplot(aes(correct))+ geom_bar() Перевернем оси: misspelling %&gt;% ggplot(aes(correct))+ geom_bar()+ coord_flip() Неаггрегированный вариант можно перевести в аггрегированный: diamonds %&gt;% count(cut) Аггрегированный вариант можно перевести в неаггрегированный: diamonds %&gt;% count(cut) %&gt;% uncount(n) 6.4 Факторы Как можно заметить по предыдущему разделу, переменные на графике упорядочены по алфавиту. Чтобы это исправить нужно обсудить факторы: my_factor &lt;- factor(misspelling$correct) head(my_factor) ## [1] deschanel deschanel deschanel deschanel deschanel deschanel ## 15 Levels: deschanel galifianakis johansson kaepernick labeouf ... shyamalan levels(my_factor) ## [1] &quot;deschanel&quot; &quot;galifianakis&quot; &quot;johansson&quot; &quot;kaepernick&quot; &quot;labeouf&quot; ## [6] &quot;macaulay&quot; &quot;mcconaughey&quot; &quot;mcgwire&quot; &quot;mclachlan&quot; &quot;minaj&quot; ## [11] &quot;morissette&quot; &quot;palahniuk&quot; &quot;picabo&quot; &quot;poehler&quot; &quot;shyamalan&quot; levels(my_factor) &lt;- rev(levels(my_factor)) head(my_factor) ## [1] shyamalan shyamalan shyamalan shyamalan shyamalan shyamalan ## 15 Levels: shyamalan poehler picabo palahniuk morissette minaj ... deschanel misspelling %&gt;% mutate(correct = factor(correct, levels = c(&quot;deschanel&quot;, &quot;galifianakis&quot;, &quot;johansson&quot;, &quot;kaepernick&quot;, &quot;labeouf&quot;, &quot;macaulay&quot;, &quot;mcgwire&quot;, &quot;mclachlan&quot;, &quot;minaj&quot;, &quot;morissette&quot;, &quot;palahniuk&quot;, &quot;picabo&quot;, &quot;poehler&quot;, &quot;shyamalan&quot;, &quot;mcconaughey&quot;))) %&gt;% ggplot(aes(correct))+ geom_bar()+ coord_flip() Для работы с факторами удобно использовать пакет forcats (входит в tidyverse, вот ссылка на cheatsheet). Иногда полезной бывает функция fct_reorder(): misspelling %&gt;% count(correct) misspelling %&gt;% count(correct) %&gt;% ggplot(aes(fct_reorder(correct, n), n))+ geom_col()+ coord_flip() Кроме того, в функцию fct_reorder() можно добавит функцию, которая будет считаться на векторе, по которому группируют: diamonds %&gt;% mutate(cut = fct_reorder(cut, price, mean)) %&gt;% ggplot(aes(cut)) + geom_bar() В этом примере переменная cut упорядочена по средней mean цене price. Естественно, вместо mean можно использовать другие функции (median, min, max или даже собственные функции). Можно совмещать разные geom_...: misspelling %&gt;% count(correct) %&gt;% ggplot(aes(fct_reorder(correct, n), n, label = n))+ geom_col()+ geom_text(nudge_y = 150)+ coord_flip() На Pudding вышла статья про английские пабы. Здесь лежит немного обработанный датасет, которые они использовали. Визуализируйте 30 самых частотоных названий пабов в Великобритании. 📋 список подсказок ➡ На новостном портале meduza.io недавно вышла новость о применения закона “о неуважении к власти в интернете”. Постройте графики из этой новости. При построении графиков я использовал цвет “tan3”. 📋 список подсказок ➡ 6.5 Дотплот Иногда для случаев, когда мы исследуем числовую переменную подходит простой график, который отображает распределение наших наблюдений на одной соответствующей числовой шкале. mtcars %&gt;% ggplot(aes(mpg)) + geom_dotplot(method = &quot;histodot&quot;) ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. По оси x отложена наша переменная, каждая точка – одно наблюдение, а отложенное по оси y стоит игнорировать – оно появляется из-за ограничений пакета ggplot2. Возможно чуть понятнее будет, если добавить geom_rug(), который непосредственно отображает каждое наблюдение. mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_dotplot(method = &quot;histodot&quot;) ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. Больший смысл имеет раскрашенный вариант: mtcars %&gt;% mutate(cyl = factor(cyl)) %&gt;% ggplot(aes(mpg, fill = cyl)) + geom_rug()+ geom_dotplot(method = &quot;histodot&quot;)+ scale_y_continuous(NULL, breaks = NULL) # чтобы убрать ось y ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. Как видно, на графике, одна синяя точка попала под одну зеленую: значит они имеют общее наблюдение. 6.6 Гистограммы Если наблюдений слишком много, дотплот не имеем много смысла: diamonds %&gt;% ggplot(aes(price)) + geom_dotplot(method = &quot;histodot&quot;)+ scale_y_continuous(NULL, breaks = NULL) # чтобы убрать ось y ## `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. diamonds %&gt;% ggplot(aes(price)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Обсудим на предыдущем примере mtcars %&gt;% ggplot(aes(mpg))+ geom_rug()+ geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. По оси x отложена наша переменная, а высота столбца говорит, сколько наблюдений имеют такое же наблюдение. Однако многое зависит от того, что мы считаем одинаковым значением: mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_histogram(bins = 100) mtcars %&gt;% ggplot(aes(mpg)) + geom_rug()+ geom_histogram(bins = 5) Существует три алгоритма встроенные в R, которые можно использовать и снимать с себя ответственность: [Sturgers 1926] nclass.Sturges(mtcars$mpg) [Scott 1979] nclass.scott(mtcars$mpg) [Freedman, Diaconis 1981] nclass.FD(mtcars$mpg) mtcars %&gt;% ggplot(aes(mpg)) + geom_histogram(bins = nclass.FD(mtcars$mpg)) Какой из методов использовался при создании следующего графика на основе встроенного датасета iris? В этом типе графика точно так же можно раскрашивать на основании другой переменной: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 6.7 Функции плотности Кроме того, существует способ использовать не такой рубленный график, а его сглаженную вариант, ыйторый строиться при помои функции плотядерной оценки ности. Важное свойство, которое стоит понимать про функцию плотности — что кривая, получаемая ядерной оценкой плотности, не зависит от величины коробки гистделения (хотя есть аргумент, который от adjustвечает за степень “близости” функции плотности к гистограмме). iris %&gt;% ggplot(aes(Petal.Length)) + geom_rug()+ geom_density() Таким образом мы можем сравнивать распределения: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_density() Часто имеет смысл настроить прозрачность: iris %&gt;% ggplot(aes(Petal.Length, fill = Species)) + geom_rug()+ geom_density(alpha = 0.6) # значение прозрачности изменяется от 0 до 1 Кроме того, иногда удобно разделять группы на разные уровни: # install.packages(ggridges) library(ggridges) iris %&gt;% ggplot(aes(Petal.Length, Species, fill = Species)) + geom_density_ridges(alpha = 0.6) # значение прозрачности изменяется от 0 до 1 ## Picking joint bandwidth of 0.155 В длинный список “2015 Kantar Information is Beautiful Awards” попала визуализация Perceptions of Probability, сделанная пользователем zonination в ggplot2. Попробуйте воспроизвести ее с этими данными. 📋 список подсказок ➡ 6.8 Точки, джиттер (jitter), вайолинплот (violinplot), ящики с усами (boxplot), Вот другие способы показать распределение числовой переменной: iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_point() iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_jitter() iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_jitter(width = 0.3) library(&quot;ggbeeswarm&quot;) iris %&gt;% ggplot(aes(Species, Petal.Length))+ geom_quasirandom() diamonds %&gt;% ggplot(aes(cut, price))+ geom_violin() diamonds %&gt;% ggplot(aes(cut, price))+ geom_boxplot() 6.9 Фасетизация Достаточно мощным инструментом анализа данных является фасетизация, которая позволяет разбивать графики на основе какой-то переменной. diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut) При этом иногда так бывает, что наличие какой-то одного значение в одном из фасетов, заставляет иметь одну и ту же шкалу для всех остальных. Это можно изменить при помощи аргумента scales: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut, scales = &quot;free&quot;) Кроме того, можно добавлять дополнительные аргументы: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_wrap(~cut+color) Кроме того, можно создавать сетки переменных используя geom_grid(), они facet_grid()ньше места, чем facet_wrap(): diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_grid(cut~color, scales = &quot;free&quot;) Кроме того facet_grid() позволяет делать обощающие поля, где представлены все данные по какой-то строчке или столбцу: diamonds %&gt;% ggplot(aes(carat, price))+ geom_point(size = 0.3)+ facet_grid(cut~color, scales = &quot;free&quot;, margins = TRUE) 6.10 Визуализация комбинаций признаков 6.10.1 Потоковая Диаграмма (Sankey diagram) Один из способов визуализации отношений между признаками называется потоковая диаграмма. library(&quot;ggforce&quot;) zhadina &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/zhadina.csv&quot;) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## word_1 = col_character(), ## word_2 = col_character(), ## word_3 = col_character(), ## type = col_character(), ## n = col_double() ## ) zhadina %&gt;% gather_set_data(1:3) %&gt;% ggplot(aes(x, id = id, split = y, value = n))+ geom_parallel_sets(aes(fill = type), alpha = 0.6, axis.width = 0.5) + geom_parallel_sets_axes(axis.width = 0.5, color = &quot;lightgrey&quot;, fill = &quot;white&quot;) + geom_parallel_sets_labels(angle = 0) + theme_no_axes()+ theme(legend.position = &quot;bottom&quot;) А как поменять порядок? Снова факторы. zhadina %&gt;% gather_set_data(1:3) %&gt;% mutate(y = fct_reorder(y, n, mean)) %&gt;% ggplot(aes(x, id = id, split = y, value = n))+ geom_parallel_sets(aes(fill = type), alpha = 0.6, axis.width = 0.5) + geom_parallel_sets_axes(axis.width = 0.5, color = &quot;lightgrey&quot;, fill = &quot;white&quot;) + geom_parallel_sets_labels(angle = 0) + theme_no_axes()+ theme(legend.position = &quot;bottom&quot;) Можно донастроить, задав собственный порядок в аргументе levels функции factor(). 6.10.2 UpSet Plot Если диаграмма Sankey визуализирует попарные отношения между переменными, то график UpSet потенциально может визуализировать все возможные комбинации и является хорошей альтернативой диаграмме Вена, с большим количеством переменных (см. эту статью Лауры Эллис). library(UpSetR) movies &lt;- read.csv( system.file(&quot;extdata&quot;, &quot;movies.csv&quot;, package = &quot;UpSetR&quot;), header=TRUE, sep=&quot;;&quot; ) str(movies) ## &#39;data.frame&#39;: 3883 obs. of 21 variables: ## $ Name : chr &quot;Toy Story (1995)&quot; &quot;Jumanji (1995)&quot; &quot;Grumpier Old Men (1995)&quot; &quot;Waiting to Exhale (1995)&quot; ... ## $ ReleaseDate: int 1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ... ## $ Action : int 0 0 0 0 0 1 0 0 1 1 ... ## $ Adventure : int 0 1 0 0 0 0 0 1 0 1 ... ## $ Children : int 1 1 0 0 0 0 0 1 0 0 ... ## $ Comedy : int 1 0 1 1 1 0 1 0 0 0 ... ## $ Crime : int 0 0 0 0 0 1 0 0 0 0 ... ## $ Documentary: int 0 0 0 0 0 0 0 0 0 0 ... ## $ Drama : int 0 0 0 1 0 0 0 0 0 0 ... ## $ Fantasy : int 0 1 0 0 0 0 0 0 0 0 ... ## $ Noir : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Horror : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Musical : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Mystery : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Romance : int 0 0 1 0 0 0 1 0 0 0 ... ## $ SciFi : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Thriller : int 0 0 0 0 0 1 0 0 0 1 ... ## $ War : int 0 0 0 0 0 0 0 0 0 0 ... ## $ Western : int 0 0 0 0 0 0 0 0 0 0 ... ## $ AvgRating : num 4.15 3.2 3.02 2.73 3.01 3.88 3.41 3.01 2.66 3.54 ... ## $ Watches : int 2077 701 478 170 296 940 458 68 102 888 ... upset(movies[,3:19], nsets = 16, order.by = &quot;freq&quot;) "],["strings.html", "7 Работа со строками 7.1 Работа со строками в R 7.2 Как получить строку? 7.3 Соединение и разделение строк 7.4 Количество символов 7.5 Сортировка 7.6 Поиск подстроки 7.7 Изменение строк 7.8 Регулярные выражения 7.9 Определение языка 7.10 Расстояния между строками 7.11 Дополнительные задания:", " 7 Работа со строками 7.1 Работа со строками в R Для работы со строками можно использовать: базовый R пакет stringr (часть tidyverse) пакет stringi – отдельный пакет, так что не забудьте его установить: install.packages(&quot;stringi&quot;) library(tidyverse) library(stringi) Мы будем пользоваться в основном пакетами stingr и stringi, так как они в большинстве случаях удобнее. К счастью функции этих пакетов легко отличить от остальных: функции пакет stringr всегда начинаются с str_, а функции пакета stringi — c stri_. Существует cheat sheet по stringr. 7.2 Как получить строку? следите за кавычками &quot;the quick brown fox jumps over the lazy dog&quot; ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; &#39;the quick brown fox jumps over the lazy dog&#39; ## [1] &quot;the quick brown fox jumps over the lazy dog&quot; &quot;the quick &#39;brown&#39; fox jumps over the lazy dog&quot; ## [1] &quot;the quick &#39;brown&#39; fox jumps over the lazy dog&quot; &#39;the quick &quot;brown&quot; fox jumps over the lazy dog&#39; ## [1] &quot;the quick \\&quot;brown\\&quot; fox jumps over the lazy dog&quot; пустая строка &quot;&quot; ## [1] &quot;&quot; &#39;&#39; ## [1] &quot;&quot; character(3) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; преобразование typeof(4:7) ## [1] &quot;integer&quot; as.character(4:7) ## [1] &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; встроенные векторы letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; LETTERS ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; ## [20] &quot;T&quot; &quot;U&quot; &quot;V&quot; &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; month.name ## [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; ## [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; Создание рандомных строк set.seed(42) stri_rand_strings(n = 10, length = 5:14) ## [1] &quot;uwHpd&quot; &quot;Wj8ehS&quot; &quot;ivFSwy7&quot; &quot;TYu8zw5V&quot; ## [5] &quot;OuRpjoOg0&quot; &quot;p0CubNR2yQ&quot; &quot;xtdycKLOm2k&quot; &quot;fAGVfylZqBGp&quot; ## [9] &quot;gE28DTCi0NV0a&quot; &quot;9MemYE55If0Cvv&quot; Перемешивает символы внутри строки stri_rand_shuffle(&quot;любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч&quot;) ## [1] &quot;,цо м,пюзгу сл аиъ—в кжряд,ыщьчебэн х—штё фй&quot; stri_rand_shuffle(month.name) ## [1] &quot;aJayunr&quot; &quot;eyrbraFu&quot; &quot;achMr&quot; &quot;Aplri&quot; &quot;ayM&quot; &quot;Jnue&quot; ## [7] &quot;uJly&quot; &quot;usuAgt&quot; &quot;tpebermSe&quot; &quot;tOecrbo&quot; &quot;oeNembvr&quot; &quot;Dmceerbe&quot; Генерирует псевдорандомный текст22 stri_rand_lipsum(nparagraphs = 2) ## [1] &quot;Lorem ipsum dolor sit amet, donec sit nunc urna sed ultricies ac pharetra orci luctus iaculis, ac tincidunt cum. Neque eu semper at sociosqu hendrerit. Eu aliquet lacus, eu hendrerit donec aliquam eros. Risus nibh, quam in sit facilisi ipsum. Amet sem sed donec sed molestie scelerisque tincidunt. Nisl donec et facilisis interdum non sed dolor purus. In ipsum dignissim torquent velit nec aliquam pellentesque. Ac, adipiscing, neque et at torquent, vestibulum ullamcorper. Ad dictumst enim velit non nulla felis habitant. Egestas placerat consectetur, dictum nostra sed nec. Erat phasellus dolor libero aliquam viverra. Vestibulum leo et. Suscipit egestas in in montes, sapien gravida? Conubia purus varius ut nec feugiat.&quot; ## [2] &quot;Risus eleifend magnis neque diam, suspendisse ullamcorper nulla adipiscing malesuada massa, nisi sociosqu velit id et. Aliquam facilisis et aenean. Parturient vel ac in convallis, massa diam nibh. Nulla interdum cursus et. Natoque amet, ut praesent. Tortor ultrices a consectetur, augue natoque class faucibus? Ut sed arcu elementum magna. Dignissim ac facilisi quis ut nisl eu, massa.&quot; 7.3 Соединение и разделение строк Соединенить строки можно используя функцию str_c(), в которую, как и в функции с(), можно перечислять элементы через запятую: tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller)) Кроме того, если хочется, можно использовать особенный разделитель, указав его в аргументе sep: tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller, sep = &quot;_&quot;)) Аналогичным образом, для разделение строки на подстроки можно использовать функцию separate(). Это функция разносит разделенные элементы строки в соответствующие столбцы. У функции три обязательных аргумента: col — колонка, которую следует разделить, into — вектор названий новых столбец, sep — разделитель. tibble(upper = rev(LETTERS), smaller = letters) %&gt;% mutate(merge = str_c(upper, smaller, sep = &quot;_&quot;)) %&gt;% separate(col = merge, into = c(&quot;column_1&quot;, &quot;column_2&quot;), sep = &quot;_&quot;) Кроме того, есть инструмент str_split(), которая позволяет разбивать строки на подстроки, но возвращает список. str_split(month.name, &quot;r&quot;) ## [[1]] ## [1] &quot;Janua&quot; &quot;y&quot; ## ## [[2]] ## [1] &quot;Feb&quot; &quot;ua&quot; &quot;y&quot; ## ## [[3]] ## [1] &quot;Ma&quot; &quot;ch&quot; ## ## [[4]] ## [1] &quot;Ap&quot; &quot;il&quot; ## ## [[5]] ## [1] &quot;May&quot; ## ## [[6]] ## [1] &quot;June&quot; ## ## [[7]] ## [1] &quot;July&quot; ## ## [[8]] ## [1] &quot;August&quot; ## ## [[9]] ## [1] &quot;Septembe&quot; &quot;&quot; ## ## [[10]] ## [1] &quot;Octobe&quot; &quot;&quot; ## ## [[11]] ## [1] &quot;Novembe&quot; &quot;&quot; ## ## [[12]] ## [1] &quot;Decembe&quot; &quot;&quot; 7.4 Количество символов 7.4.1 Подсчет количества символов tibble(mn = month.name) %&gt;% mutate(n_charactars = str_count(mn)) 7.4.2 Подгонка количества символов Можно обрезать строки, используя функцию str_trunc(): tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6)) Можно решить с какой стороны обрезать, используя аргумент side: tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6, side = &quot;left&quot;)) tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 6, side = &quot;center&quot;)) Можно заменить многоточие, используя аргумент ellipsis: tibble(mn = month.name) %&gt;% mutate(mn_new = str_trunc(mn, 3, ellipsis = &quot;&quot;)) Можно наоборот “раздуть” строку: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10)) Опять же есть аргумент side: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10, side = &quot;right&quot;)) Также можно выбрать, чем “раздувать строку”: tibble(mn = month.name) %&gt;% mutate(mn_new = str_pad(mn, 10, pad = &quot;.&quot;)) На Pudding вышла статья про английские пабы. Здесь лежит немного обработанный датасет, которые они использовали. Визуализируйте 40 самых частотоных названий пабов в Великобритании, отложив по оси x количество символов, а по оси y – количество баров с таким названием. 📋 список подсказок ➡ 👁 Датасет скачался, что дальше? ➡ Перво-наперво следует создать переменную, в которой бы хранилось количество каждого из баров. 👁 А как посчитать количество баров? ➡ Это можно сделать при помощи функции count(). 👁 Бары пересчитали, что дальше? ➡ Теперь нужно создать новую переменную, где бы хранилась информация о количестве символов. 👁 Все переменные есть, теперь рисуем? ➡ Не совсем. Перед тем как рисовать нужно отфильтровать 50 самых популярных. 👁 Так, все готово, а какие geom_()? ➡ На графике geom_point() и geom_text_repel() из пакета ggrepel. 👁 А-а-а-а! could not find function \"geom_text_repel\" ➡ А вы включили библиотеку ggrepel? Если не включили, то функция, естественно будет недоступна. 👁 А-а-а-а! geom_text_repel requires the following missing aesthetics: label\" ➡ Все, как написала программа: чтобы писать какой-то текст в функции aes() нужно добавить аргумент label = pub_name. Иначе откуда он узнает, что ему писать? 👁 Фуф! Все готово! ➡ А оси подписаны? А заголовок? А подпись про источник данных? 7.5 Сортировка Для сортировки существует базовая функция sort() и функция из stringr str_sort(): unsorted_latin &lt;- c(&quot;I&quot;, &quot;♥&quot;, &quot;N&quot;, &quot;Y&quot;) sort(unsorted_latin) ## [1] &quot;♥&quot; &quot;I&quot; &quot;N&quot; &quot;Y&quot; str_sort(unsorted_latin) ## [1] &quot;♥&quot; &quot;I&quot; &quot;N&quot; &quot;Y&quot; str_sort(unsorted_latin, locale = &quot;lt&quot;) ## [1] &quot;♥&quot; &quot;I&quot; &quot;Y&quot; &quot;N&quot; unsorted_cyrillic &lt;- c(&quot;я&quot;, &quot;i&quot;, &quot;ж&quot;) str_sort(unsorted_cyrillic) ## [1] &quot;i&quot; &quot;ж&quot; &quot;я&quot; str_sort(unsorted_cyrillic, locale = &quot;ru_UA&quot;) ## [1] &quot;ж&quot; &quot;я&quot; &quot;i&quot; Список локалей на копмьютере можно посмотреть командой stringi::stri_locale_list(). Список всех локалей вообще приведен на этой странице. Еще полезные команды: stringi::stri_locale_info и stringi::stri_locale_set. Не углубляясь в разнообразие алгоритмов сортировки, отмечу, что алгоритм по-умолчанию хуже работает с большими данными: set.seed(42) huge &lt;- sample(letters, 1e7, replace = TRUE) head(huge) ## [1] &quot;q&quot; &quot;e&quot; &quot;a&quot; &quot;y&quot; &quot;j&quot; &quot;d&quot; system.time( sort(huge) ) ## user system elapsed ## 6.502 0.029 6.531 system.time( sort(huge, method = &quot;radix&quot;) ) ## user system elapsed ## 0.270 0.028 0.298 system.time( str_sort(huge) ) ## user system elapsed ## 5.658 0.056 5.715 huge_tbl &lt;- tibble(huge) system.time( huge_tbl %&gt;% arrange(huge) ) ## user system elapsed ## 30.557 0.057 30.615 Предварительный вывод: для больших данных – sort(..., method = \"radix\"). 7.6 Поиск подстроки Можно использовать функцию str_detect(): tibble(mn = month.name) %&gt;% mutate(has_r = str_detect(mn, &quot;r&quot;)) Кроме того, существует функция, которая возвращает индексы, а не значения TRUE/FALSE: tibble(mn = month.name) %&gt;% slice(str_which(mn, &quot;r&quot;)) Также можно посчитать количество вхождений какой-то подстроки: tibble(mn = month.name) %&gt;% mutate(has_r = str_count(mn, &quot;r&quot;)) 7.7 Изменение строк 7.7.1 Изменение регистра latin &lt;- &quot;tHe QuIcK BrOwN fOx JuMpS OvEr ThE lAzY dOg&quot; cyrillic &lt;- &quot;лЮбЯ, сЪеШь ЩиПцЫ, — вЗдОхНёТ мЭр, — кАйФ жГуЧ&quot; str_to_upper(latin) ## [1] &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&quot; str_to_lower(cyrillic) ## [1] &quot;любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч&quot; str_to_title(latin) ## [1] &quot;The Quick Brown Fox Jumps Over The Lazy Dog&quot; 7.7.2 Выделение подстроки Подстроку в строке можно выделить двумя способами: по индексам функцией str_sub(), и по подстроке функцией str_png(). extract(images/5.07_str_sub.png) tibble(mn = month.name) %&gt;% mutate(mutate = str_sub(mn, start = 1, end = 2)) tibble(mn = month.name) %&gt;% mutate(mutate = str_extract(mn, &quot;r&quot;)) По умолчанию функция str_extract() возвращает первое вхождение подстроки, соответствующей шаблону. Также существует функция str_extract_all(), которая возвращает все вхождения подстрок, соответствующих шаблону, однако возвращает объект типа список. str_extract_all(month.name, &quot;r&quot;) ## [[1]] ## [1] &quot;r&quot; ## ## [[2]] ## [1] &quot;r&quot; &quot;r&quot; ## ## [[3]] ## [1] &quot;r&quot; ## ## [[4]] ## [1] &quot;r&quot; ## ## [[5]] ## character(0) ## ## [[6]] ## character(0) ## ## [[7]] ## character(0) ## ## [[8]] ## character(0) ## ## [[9]] ## [1] &quot;r&quot; ## ## [[10]] ## [1] &quot;r&quot; ## ## [[11]] ## [1] &quot;r&quot; ## ## [[12]] ## [1] &quot;r&quot; 7.7.3 Замена подстроки Существует функция str_replace(), которая позволяет заменить одну подстроку в строке на другую: tibble(mn = month.name) %&gt;% mutate(mutate = str_replace(mn, &quot;r&quot;, &quot;R&quot;)) Как и другие функции str_replace() делает лишь одну замену, чтобы заменить все вхождения подстроки следует использовать функцию str_replace_all(): tibble(mn = month.name) %&gt;% mutate(mutate = str_replace_all(mn, &quot;r&quot;, &quot;R&quot;)) 7.7.4 Удаление подстроки Для удаления подстроки на основе шаблона, используется функция str_remove() и str_remove_all() tibble(month.name) %&gt;% mutate(mutate = str_remove(month.name, &quot;r&quot;)) tibble(month.name) %&gt;% mutate(mutate = str_remove_all(month.name, &quot;r&quot;)) 7.7.5 Транслитерация строк В пакете stringi сууществует достаточно много методов транслитераций строк, которые можно вывести командой stri_trans_list(). Вот пример использования некоторых из них: stri_trans_general(&quot;stringi&quot;, &quot;latin-cyrillic&quot;) ## [1] &quot;стринги&quot; stri_trans_general(&quot;сырники&quot;, &quot;cyrillic-latin&quot;) ## [1] &quot;syrniki&quot; stri_trans_general(&quot;stringi&quot;, &quot;latin-greek&quot;) ## [1] &quot;στριγγι&quot; stri_trans_general(&quot;stringi&quot;, &quot;latin-armenian&quot;) ## [1] &quot;ստրինգի&quot; Вот два датасета: список городов России частотный словарь русского языка [Шаров, Ляшевская 2011] Определите сколько городов называется обычным словом русского языка (например, город Орёл)? Не забудьте поменять ё на е. 📋 список подсказок ➡ 👁 Датасеты скачались, что дальше? ➡ Надо их преобразовать к нужному виду и объединить. 👁 А как их соединить? Что у них общего? ➡ В одном датасете есть переменная city, в другом – переменная lemma. Все города начинаются с большой буквы, все леммы с маленькой буквы. Я бы уменьшил букву в датасете с городами, сделал бы новый столбец в датасете с городами (например, town), соединил бы датасеты и посчитал бы сколько в результирующем датасете значений town. 👁 А как соеднить? ➡ Я бы использовал dict %&gt;% ... %&gt;% inner_join(cities). Если в датасетах разные названия столбцов, то следует указывать какие столбцы, каким соответствуют:dict %&gt;% ... %&gt;% inner_join(cities, by = c(\"lemma\" = \"city\")) 👁 Соединилось вроде… А как посчитать? ➡ Я бы, как обычно, использовал функцию count(). 7.8 Регулярные выражения Большинство функций из раздела об операциях над векторами (str_detect(), str_extract(), str_remove() и т. п.) имеют следующую структуру: строка, с которой работает функция образец (pattern) Дальше мы будем использовать функцию str_view_all(), которая позволяет показывать, выделенное образцом в исходной строке. str_view_all(&quot;Я всегда путаю с и c&quot;, &quot;c&quot;) # я ищу латинскую c 7.8.1 Экранирование метасимволов a &lt;- &quot;Всем известно, что 4$\\\\2 + 3$ * 5 = 17$? Да? Ну хорошо (а то я не был уверен). [|}^{|]&quot; str_view_all(a, &quot;$&quot;) str_view_all(a, &quot;\\\\$&quot;) str_view_all(a, &quot;\\\\.&quot;) str_view_all(a, &quot;\\\\*&quot;) str_view_all(a, &quot;\\\\+&quot;) str_view_all(a, &quot;\\\\?&quot;) str_view_all(a, &quot;\\\\(&quot;) str_view_all(a, &quot;\\\\)&quot;) str_view_all(a, &quot;\\\\|&quot;) str_view_all(a, &quot;\\\\^&quot;) str_view_all(a, &quot;\\\\[&quot;) str_view_all(a, &quot;\\\\]&quot;) str_view_all(a, &quot;\\\\{&quot;) str_view_all(a, &quot;\\\\}&quot;) str_view_all(a, &quot;\\\\\\\\&quot;) 7.8.2 Классы знаков \\\\d – цифры. \\\\D – не цифры. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\d&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\D&quot;) \\\\s – пробелы. \\\\S – не пробелы. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\s&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\S&quot;) \\\\w – не пробелы и не знаки препинания. \\\\W – пробелы и знаки препинания. str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\w&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;\\\\W&quot;) произвольная группа символов и обратная к ней str_view_all(&quot;Умей мечтать, не став рабом мечтанья&quot;, &quot;[оауиыэёеяю]&quot;) str_view_all(&quot;И мыслить, мысли не обожествив&quot;, &quot;[^оауиыэёеяю]&quot;) встроенные группы символов str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;[0-9]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[а-я]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[А-Я]&quot;) str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;[А-я]&quot;) str_view_all(&quot;The quick brown Fox jumps over the lazy Dog&quot;, &quot;[a-z]&quot;) str_view_all(&quot;два 15 42. 42 15. 37 08 5. 20 20 20!&quot;, &quot;[^0-9]&quot;) выбор из нескольких групп str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;лар|рал|арл&quot;) произвольный символ str_view_all(&quot;Везет Сенька Саньку с Сонькой на санках. Санки скок, Сеньку с ног, Соньку в лоб, все — в сугроб&quot;, &quot;[Сс].н&quot;) знак начала и конца строки str_view_all(&quot;от топота копыт пыль по полю летит.&quot;, &quot;^о&quot;) str_view_all(&quot;У ежа — ежата, у ужа — ужата&quot;, &quot;жата$&quot;) есть еще другие группы и другие обозначения уже приведенных групп, см. ?regex 7.8.3 Квантификация ? – ноль или один раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;еее?&quot;) * – ноль и более раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;ее*&quot;) + – один и более раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е+&quot;) {n} – n раз str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{2}&quot;) {n,} – n раз и более str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{1,}&quot;) {n,m} – от n до m. Отсутствие пробела важно: {1,2} – правильно, {1,␣2} – неправильно. str_view_all(&quot;хорошее длинношеее животное&quot;, &quot;е{2,3}&quot;) группировка символов str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;(ов)+&quot;) str_view_all(&quot;беловатый, розоватый, розововатый&quot;, &quot;(ов)+&quot;) жадный vs. нежадный алоритмы str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;в.*ед&quot;) str_view_all(&quot;Пушкиновед, Лермонтовед, Лермонтововед&quot;, &quot;в.*?ед&quot;) 7.8.4 Позиционная проверка (look arounds) Позиционная проверка – выглядит достаточно непоследовательно даже в свете остальных регулярных выражений. Давайте найдем все а перед р: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;а(?=р)&quot;) А теперь все а перед р или л: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;а(?=[рл])&quot;) Давайте найдем все а после р str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;=р)а&quot;) А теперь все а после р или л: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;=[рл])а&quot;) Также у этих выражений есть формы с отрицанием. Давайте найдем все р не перед а: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;р(?!а)&quot;) А теперь все р не после а: str_view_all(&quot;Карл у Клары украл кораллы, а Клара у Карла украла кларнет&quot;, &quot;(?&lt;!а)р&quot;) Запомнить с ходу это достаточно сложно, так что подсматривайте сюда: Вот отсюда можно скачать файл с текстом стихотворения Н. Заболоцкого “Меркнут знаки задиака.” Посчитайте долю женских (ударение падает на предпоследний слог рифмующихся слов) и мужских (ударение падает на последний слог рифмующихся слов) рифм в стихотворении. 📋 список подсказок ➡ 👁 Датасеты скачивается с ошибкой, почему? ➡ Дело в том, что исходный файл в формате .txt, а не .csv. Его нужно скачивать, например, командой read_lines() 👁 Ошибка: ...applied to an object of class \"character\" ➡ Скачав файл Вы получили вектор со строками, где каждая элимент вектора – строка стихотворения. Создайте tibble(), тогда можно будет применять стандартные инструменты tidyverse. 👁 Хорошо, tibble() создан, что дальше? ➡ Дальше нужно создать переменную, из которой будет понятно, мужская в каждой строке рифма, или женская. 👁 А как определить, какая рифма? Нужно с словарем сравнивать? ➡ Формально говоря, определять рифму можно по косвенным признакам. Все стихотворение написано четырехстопным хореем, значит в нем либо 7, либо 8 слогов. Значит, посчитав количество слогов, мы поймем, какая перед нами рифма. 👁 А как посчитать гласные? ➡ Нужно написать регулярное выражение… вроде бы это тема нашего занятия… 👁 Гласные посчитаны. А что дальше? ➡ Ну теперь нужно посчитать, сколько каких длин (в количестве слогов) бывает в стихотворении. Это можно сделать при помощи функции count(). 👁 А почему у меня есть строки длины 0 слогов ➡ Ну, видимо, в стихотворении были пустые строки. Они использовались для разделения строф. 👁 А почему у меня есть строки длины 6 слогов ➡ Ну, видимо, Вы написали регулярное выражение, которое не учитывает, что гласные буквы могут быть еще и в начале строки, а значит написаны с большой буквы. В ходе анализа данных чаще всего бороться со строками и регулярными выражениями приходится в процессе обработки неаккуратнособранных анкет. Предлагаю обработать переменные sex и age такой вот неудачно собранной анкеты и построить следующий график: 📋 список подсказок ➡ 👁 А что это за geom_...()? ➡ Это geom_dotplot() с аргументом method = \"histodot\" и с удаленной осью y при помощи команды scale_y_continuous(NULL, breaks = NULL) 👁 Почему на графике рисутеся каждое значение возраста? ➡ Если Вы все правильно преобразовали, должно помочь преобразование строковой переменной age в числовую при помощи функции as.integer(). 7.9 Определение языка Для определения языка существует два пакета cld2 (вероятностный) и cld3 (нейросеть). udhr_24 &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/article_24_from_UDHR.csv&quot;) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## article_text = col_character() ## ) udhr_24 cld2::detect_language(udhr_24$article_text) ## [1] &quot;ru&quot; &quot;en&quot; &quot;fr&quot; &quot;es&quot; &quot;ar&quot; &quot;zh&quot; cld2::detect_language(udhr_24$article_text, lang_code = FALSE) ## [1] &quot;RUSSIAN&quot; &quot;ENGLISH&quot; &quot;FRENCH&quot; &quot;SPANISH&quot; &quot;ARABIC&quot; &quot;CHINESE&quot; cld3::detect_language(udhr_24$article_text) ## [1] &quot;ru&quot; &quot;en&quot; &quot;fr&quot; &quot;es&quot; &quot;ar&quot; &quot;zh&quot; cld2::detect_language(&quot;Ты женат? Говорите ли по-английски?&quot;) ## [1] &quot;bg&quot; cld3::detect_language(&quot;Ты женат? Говорите ли по-английски?&quot;) ## [1] NA cld2::detect_language(&quot;Варкалось. Хливкие шорьки пырялись по наве, и хрюкотали зелюки, как мюмзики в мове.&quot;) ## [1] &quot;ru&quot; cld3::detect_language(&quot;Варкалось. Хливкие шорьки пырялись по наве, и хрюкотали зелюки, как мюмзики в мове.&quot;) ## [1] &quot;ru&quot; cld2::detect_language(&quot;Варчилось… Хлив&#39;язкі тхурки викрули, свербчись навкрузі, жасумновілі худоки гривіли зехряки в чузі.&quot;) ## [1] &quot;uk&quot; cld3::detect_language(&quot;Варчилось… Хлив&#39;язкі тхурки викрули, свербчись навкрузі, жасумновілі худоки гривіли зехряки в чузі.&quot;) ## [1] &quot;uk&quot; cld2::detect_language_mixed(&quot;Многие в нашей команде OpenDataScience занимаются state-of-the-art технологиями машинного обучения: DL-фреймворками, байесовскими методами машинного обучения, вероятностным программированием и не только.&quot;) ## $classification ## language code latin proportion ## 1 RUSSIAN ru FALSE 0.87 ## 2 ENGLISH en TRUE 0.11 ## 3 UNKNOWN un TRUE 0.00 ## ## $bytes ## [1] 353 ## ## $reliabale ## [1] TRUE cld3::detect_language_mixed(&quot;Многие в нашей команде OpenDataScience занимаются state-of-the-art технологиями машинного обучения: DL-фреймворками, байесовскими методами машинного обучения, вероятностным программированием и не только.&quot;) 7.10 Расстояния между строками Существует много разных метрик для измерения расстояния между строками (см. ?`stringdist-metrics`), в примерах используется расстояние Дамерау — Левенштейна. Данное расстояние получается при подсчете количества операций, которые нужно сделать, чтобы перевести одну строку в другую. вставка ab → aNb удаление aOb → ab замена символа aOb → aNb перестановка символов ab → ba library(stringdist) ## ## Attaching package: &#39;stringdist&#39; ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract stringdist(&quot;корова&quot;,&quot;корова&quot;) ## [1] 0 stringdist(&quot;коровы&quot;, c(&quot;курица&quot;, &quot;бык&quot;, &quot;утка&quot;, &quot;корова&quot;, &quot;осел&quot;)) ## [1] 4 6 6 1 5 amatch(c(&quot;быки&quot;, &quot;коровы&quot;), c(&quot;курица&quot;, &quot;бык&quot;, &quot;утка&quot;, &quot;корова&quot;, &quot;осел&quot;), maxDist = 2) ## [1] 2 4 7.11 Дополнительные задания: В датасет записаны твиты Донольда Трампа взятые с kaggle. Постройте график рассеяния, которые показывает связь количества ретвитов и лайков. Чтобы убрать научную запись больших чисел используйте команду options(scipen = 999). Постройте гистограмму, которая показывает распределения длины твитов в символах. Какой метод определения размера ячейки использован на приведенном графике? [Sturgers 1926], [Scott 1979] или [Freedman, Diaconis 1981]? Постройте график рассеивания, который бы показывал связь с длиной твита во времени. Используя geom_hline(), наложите две линии: 140 символов и 280. Сделайте прозрачность 0.1. Постройте график рассеивания, который бы показывал связь с длиной твита во времени. Разбейте и раскрасьте твиты на основании наличия в них интернет ссылок. Можно ли утверждать, что твиты со ссылками длиннее? Постройте вайолинплот, которые показывает распределение значений длины твитов в зависимости от наличия в них интернет ссылок. Найдите твиты которые содержат корень america, которые встречаются больше одного раза, и фасетизируйте по таким словам. Lorem ipsum — классический текст-заполнитель на основе трактата Марка Туллия Цицерона “О пределах добра и зла.” Его используют, чтобы посмотреть, как страница смотриться, когда заполнена текстом↩︎ "],["data-presentation.html", "8 Представление данных: rmarkdown 8.1 rmarkdown 8.2 Бывают и другие способы представления данных", " 8 Представление данных: rmarkdown Достаточно важной частью работы с данными является их представление. Мы рассмотрим наиболее распространенный варианты: rmarkdown, flexdashboard и shiny. Смотрите книжку (Xie, Allaire, and Grolemund 2019)(https://bookdown.org/yihui/rmarkdown/) или cheatsheet. 8.1 rmarkdown rmarkdown – это пакет, который позволяет соединять R команды и их исполнения в один документ. В результате можно комбинировать текст и исполняемый код, что в свою очередь позволяет делать: * докумунты в формате .html, .pdf (используя , мы почти не будем это обсуждать), .docx * презентации в формате .html, .pdf (используя пакет beamer) .pptx-презентации * набор связанных .html документов (полноценный сайт или книга) 8.1.1 Установка Как и все пакеты rmarkdown можно установить из CRAN install.packages(&quot;rmarkdown&quot;) 8.1.2 Составляющие rmarkdown-документа yaml шапка (факультативна) обычный текст с markdown форматированием (расширенный при помощи Pandoc) блоки кода (не обязательно на языке R), оформленные с двух сторон тройным бэктиком ``` (у меня на клавиатуре этот знак на букве ё). 8.1.3 Пример rmarkdown-документа Создайте файл .Rmd в какой-нибудь папке (в RStudio, это можно сделать File &gt; New file &gt; R Markdown). Скомпелировать файл можно командой: rmarkdown::render(&quot;ваш_файл.Rmd&quot;) или кнопкой . Вот пример кода: --- output: html_document --- ## Данные В документе можно вставлять R код ```{r} summary(iris) ``` ## График И строить графики ```{r} library(tidyverse) iris %&gt;% ggplot(aes(Sepal.Length, Sepal.Width))+ geom_point() ``` Результат. Создайте и скомпелируйте свой rmarkdown-документ с заголовком, текстом и кодом. 8.1.4 Markdown Универсальны язык разметки, работает во многих современных он-лайн системах создания текста. 8.1.4.1 Заголовки ## Заголовок уровня 2 #### Заголовок уровня 4 8.1.4.2 Форматирование _италик_ или *другой италик* __жирный__ или **другой жирный** ~~зачеркивание~~ италик или другой италик жирный или другой жирный зачеркивание 8.1.4.3 Списки * кролик * заяц * заяц серый 1. машины 1. автобус 2. самолеты + можно еще ставить плюс - и минус кролик заяц заяц серый машины автобус самолеты можно еще ставить плюс и минус 8.1.4.4 Ссылки и картинки [Ссылка 1](https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html) &lt;https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html&gt; [Можно вставить ссылку потом, а пока отсавить метку][1] Или даже просто голую [метку]. ![](https://raw.githubusercontent.com/agricolamz/2018_ANDAN_course_winter/master/rmarkdown.png) Опять же можно вставить только метку ![][2] [1]: https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html [метку]: https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html [2]: https://raw.githubusercontent.com/agricolamz/2018_ANDAN_course_winter/master/rmarkdown.png Ссылка 1 https://agricolamz.github.io/2018_ANDAN_course_winter/2_ex.html Можно вставить ссылку потом, а пока отсавить метку Или даже просто голую метку. Опять же можно вставить только метку 8.1.4.5 Код Код нужно оформалять вот так `rmarkdown::render()` Код нужно оформалять вот так rmarkdown::render() ```{python} friends = [&#39;john&#39;, &#39;pat&#39;, &#39;gary&#39;, &#39;michael&#39;] for i, name in enumerate(friends): print &quot;iteration {iteration} is {name}&quot;.format(iteration=i, name=name) ``` collection = [&#39;hey&#39;, 5, &#39;d&#39;] for x in collection: print(x) hey 5 d Если хочется использовать результат работы кода в тексте, нужно в начале поставить язык, который будет исполнять код, например, в Фигурные скобки не обязательны, но тогда RStudio подсветит. 8.1.4.6 Цитаты &gt; Цитаты нужно офрмлять так. &gt; Это попадет в тот же фрагмент. &gt; А вот тут произошел разрыв. Кстати, здесь тоже можно использовать *markdown*. Цитаты нужно офрмлять так. Это попадет в тот же фрагмент. А вот тут произошел разрыв. Кстати, здесь тоже можно использовать markdown. 8.1.4.7 Разрыв страницы *** 8.1.4.8 HTML &lt;dl&gt; &lt;dt&gt;Чистый HTML&lt;/dt&gt; &lt;dd&gt;Еще можно писать в HTML.&lt;/dd&gt; &lt;dt&gt;и Markdown в HTML &lt;/dt&gt; &lt;dd&gt; даже работает **правильно**. Но можно использовать и &lt;em&gt;теги&lt;/em&gt;.&lt;/dd&gt; &lt;/dl&gt; Чистый HTML Еще можно писать в HTML. и Markdown в HTML даже работает правильно. Но можно использовать и теги. 8.1.4.9 Таблицы Еще есть целая наука как делать таблицы в Markdown, но я предпочитаю использовать он-лайн генератор. 8.1.5 Pandoc Pandoc это программа, созданная Дж. МакФарлэйном (J. MacFarlane), которая позволяет переходить из разных текстовых форматов в другие, а также смешивать их. Я покожу лишь несколько полезных расширений. 8.1.5.1 Верхние и нижние индексы 2^10^ C~n~^k^ 210 Cnk 8.1.5.2 Нумерованные примеры (@) Славный пример номер раз. (@) Славный пример номер два. (@three) Славный пример номер три, у которого есть *имя*. Я могу сослаться на пример (@three)! Славный пример номер раз. Славный пример номер два. Славный пример номер три, у которого есть имя. Я могу сослаться на пример (3)! 8.1.5.3 Сноски Вот и сноска[^1] [^1]: Сноска, сноска, сноска. Вот и сноска23 8.1.5.4 Математика: \\(\\LaTeX\\) $\\LaTeX$ код может быть в тексте $\\frac{\\pi}{\\sum{n+1}}$ или отдельной строчкой: $$\\frac{\\pi}{\\sum{n+1}}$$ \\(\\LaTeX\\) код может быть в тексте \\(\\frac{\\pi}{\\sum{n+1}}\\) или отдельной строчкой: \\[\\frac{\\pi}{\\sum{n+1}}\\] 8.1.6 Code chunks Фрагменты кода имеют свои наборы свойств, который можно записывать в фигурных скобках. 8.1.6.1 Язык программирования ```{r} summary(cars) ``` ```{python} x = &quot;my string&quot; print(x.split(&quot; &quot;)) ``` summary(cars) speed dist Min. : 4.0 Min. : 2.00 1st Qu.:12.0 1st Qu.: 26.00 Median :15.0 Median : 36.00 Mean :15.4 Mean : 42.98 3rd Qu.:19.0 3rd Qu.: 56.00 Max. :25.0 Max. :120.00 x = &quot;my string&quot; print(x.split(&quot; &quot;)) [&#39;my&#39;, &#39;string&#39;] 8.1.6.2 Появление и исполнение кода И код, и результат ```{r} plot(mtcars$mpg) ``` Только результат ```{r, echo = FALSE} plot(mtcars$mpg) ``` Только код ```{r, eval = FALSE} plot(mtcars$mpg) ``` Исполняется, но не показывается ни код, ни результат ```{r, include = FALSE} a &lt;- mtcars$mpg ``` Обратимся к переменной, созданной в фрагменте с аргументом `include = FALSE` ```{r} a ``` 8.1.6.3 Другие полезные аргументы Существует достаточно много аргументов, которые можно перечислить в фигурных скобках в фрагменте кода, вот некоторые из них: error: показывать ли ошибки. warning: показывать ли предупреждения. message: показывать ли сообщения (например, при подключении пакетов). comment: по умолчанию, результат работы кода предваряется знаком ##, используйте NA, чтобы их не было, или любую другую строку. cache: сохранить ли результат работы фрагмента кода. Очень полезно, если происходят какие-то операции, занимающая много времени. Сохранив результат, не нужно будет тратить время, на пересчет, при каждой новой компиляции. fig.width, fig.height (по умолчанию, 7) Все эти аргументы можно перечислить в функции knitr::opts_chunk$set(...): 8.1.6.4 Pets or livestock? В RMarkdown каждому фрагменту кода можно дать имя (но избегайте пробелов и точек): ```{r my_beautiful_graph, eval = FALSE} library(tidyverse) diamonds %&gt;% count(carat, color) %&gt;% ggplot(aes(carat, n, color = color))+ geom_point() ``` Maëlle Salmon написал отличный пост, почему полезно именовать фрагменты кода: проще ориентироваться код более читаемый ошибки при компеляции показывают имя, а не номер если фрагмент кэшировался, то добавление одного фрагменты перед ним, не заставит все пересчитываться в blogdown можно ссылаться 8.1.7 YAML шапка Факультативная YAML шапка обычно содержит метаданные документа, и аргументы, необходимые для работы некоторых дополнений. --- title: &quot;Мой RMarkdown&quot; author: Славный Автор date: 20 ноября 2019 --- 8.1.7.1 Тип получившегося файла output: html_document (по умолчанию) output: word_document output: pdf_document (но нужно договориться с \\(\\LaTeX\\)ом на вашем компьютере) output: ioslides_presentation output: slidy_presentation output: slidy_presentation output: beamer_presentation и др. 8.1.7.2 Библиография Существует несколько сопособов вставлять библиографию в RMarkdown. Я раскажу, как использовать пакет Bibtex (как видно из названия, сделанный для \\(\\LaTeX\\)). Для начала нужно создать файл с раширением .bib, в который записать все источники, которые будут использоваться (библиографию в формате BibTeX выдает, например, GoogleScholar): @book{ladefoged96, title={The sounds of the world&#39;s languages}, author={Ladefoged, P. and Maddieson, I.}, year={1996}, publisher={Oxford Publishers} } @article{gordon02, title={A cross-linguistic acoustic study of voiceless fricatives}, author={Gordon, M. and Barthmaier, P. and Sands, K.}, journal={Journal of the International Phonetic Association}, volume={32}, number={2}, pages={141--174}, year={2002}, publisher={Cambridge University Press} } На следующем шаге нужно добавить название файла с раширением .bib в YAML шапку: --- bibliography: bibliography.bib --- После этого, можно использовать сслыки в тексте В своей работе @gordon02 раскрыл... В своей работе Gordon, Barthmaier, and Sands (2002) раскрыл… Об этом можно узнать из [@ladefoged96; @gordon02], но ... Об этом можно узнать из (Ladefoged and Maddieson 1996; Gordon, Barthmaier, and Sands 2002), но … В своей работе [@gordon02] раскрыл... В своей работе (Gordon, Barthmaier, and Sands 2002) раскрыл… Об этом можно узнать из [см. @gordon02, с. 33--35; а также @ladefoged96, гл. 1]... Об этом можно узнать из (см. Gordon, Barthmaier, and Sands 2002, с. 33–35; а также Ladefoged and Maddieson 1996, гл. 1)… Список литературы автоматически появляется в конце. 8.1.7.3 Оглавление и пр. Существует сразу несколько аргументов, отвечающих за оглавление. toc вставлять ли оглавление toc_depth глубина иерархии, которую отражать в огловлении toc_float должно ли оглавление все время следовать за текстом collapsed должно ли оглавление быть все время полностью раскрыто collapsed должно ли оглавление быть все время полностью раскрыто number_sections автоматическая нумерация секций code_folding (hide) — делать ли кнопочку, показывающую/скрывающую весь код theme одна из Bootstrap тем highlight: “default,” “tango,” “pygments,” “kate,” “monochrome,” “espresso,” “zenburn,” “haddock” или “textmate” --- html_document: theme: spacelab highlight: pygments toc: yes toc_position: right toc_depth: 3 toc_float: yes smooth_scroll: false --- 8.1.7.4 Отображение датафреймов df_print: default df_print: kable df_print: tibble df_print: paged --- output: html_document: df_print: paged --- 8.1.8 Где хостить .html? Полученные .html можно разместить в интернете: на каком-то вашем хосте опубликовать на бесплатном хостинке Rpubs опубликовать на гитхабе и включить Github Pages Теперь создайте документ index.Rmd, в котором напишите код на R и на Python, вставьте картинку, сноску, ссылку на литературу, таблицу и оглавление. Скомпелируйте .html документ и опубликуйте его на Github, пройдя по этой ссылке. Cделайте Github Pages и заполните README.md файл. 8.2 Бывают и другие способы представления данных flexdashboard – динамические дэшборды shiny – динамические сайты, которые позволяют взаимодействовать с пользователем posterdown – постеры в RMarkdown pagedown – содержит много шаблонов: для книги, статьи, постера, резюме, визитки… да хоть приглашение на свадьбу можно сделать. Ссылки на литературу "],["работа-с-текстами-gutenbergr-tidytext-stopwords.html", "9 Работа с текстами: gutenbergr, tidytext, stopwords 9.1 Загрузка текста в R 9.2 Пакет gutenbergr 9.3 Библиотека tidytext 9.4 Пакет stopwords", " 9 Работа с текстами: gutenbergr, tidytext, stopwords library(tidyverse) 9.1 Загрузка текста в R В пакете readr (входит в tidyverse) для чтения текста есть функция read_lines(). В качестве первой переменной может выступать путь к файлу на компьютере или интернет ссылка: t &lt;- read_lines(&quot;https://raw.githubusercontent.com/agricolamz/2020_HSE_DPO/master/data/Chang.txt&quot;) head(t) [1] &quot;Тед Чан&quot; [2] &quot;История твоей жизни&quot; [3] &quot;Твой отец собирается задать мне вопрос. Это самый важный момент в нашей жизни, и я хочу&quot; [4] &quot;запомнить все до малейшей детали. Уже за полночь, но мы только что вернулись домой после&quot; [5] &quot;ужина в ресторане и веселого шоу и сразу выходим в патио полюбоваться полной луной. Хочу&quot; [6] &quot;танцевать! — объявляю я, и твой отец подтрунивает надо мной, но мы начинаем скользить в&quot; Тексты хранятся в интернете по разному. Часто бывает так, что текст дигитализировали так, как он напечатан, так что в результате каждая строка в печатной книжке соответствует строке в текстовом файле (так, например, в нашем примере). Такой файл следует склеить воедино, используя пробел в качестве разделителя: t2 &lt;- str_c(t, collapse = &quot; &quot;) length(t2) [1] 1 str_length(t2) [1] 117398 При таком слиянии, стоит проверить, не было ли в анализируемом тексте знаков переноса, иначе они сольются неправильно: str_c(c(&quot;... она запо-&quot;, &quot;лучила ...&quot;), collapse = &quot; &quot;) [1] &quot;... она запо- лучила ...&quot; 9.2 Пакет gutenbergr Пакет gutenbergr является API для очень старого проекта Gutenberg. library(gutenbergr) Все самое важное в этом пакете хранится в датасете gutenberg_metadata str(gutenberg_metadata) tibble [51,997 × 8] (S3: tbl_df/tbl/data.frame) $ gutenberg_id : int [1:51997] 0 1 2 3 4 5 6 7 8 9 ... $ title : chr [1:51997] NA &quot;The Declaration of Independence of the United States of America&quot; &quot;The United States Bill of Rights\\r\\nThe Ten Original Amendments to the Constitution of the United States&quot; &quot;John F. Kennedy&#39;s Inaugural Address&quot; ... $ author : chr [1:51997] NA &quot;Jefferson, Thomas&quot; &quot;United States&quot; &quot;Kennedy, John F. (John Fitzgerald)&quot; ... $ gutenberg_author_id: int [1:51997] NA 1638 1 1666 3 1 4 NA 3 3 ... $ language : chr [1:51997] &quot;en&quot; &quot;en&quot; &quot;en&quot; &quot;en&quot; ... $ gutenberg_bookshelf: chr [1:51997] NA &quot;United States Law/American Revolutionary War/Politics&quot; &quot;American Revolutionary War/Politics/United States Law&quot; NA ... $ rights : chr [1:51997] &quot;Public domain in the USA.&quot; &quot;Public domain in the USA.&quot; &quot;Public domain in the USA.&quot; &quot;Public domain in the USA.&quot; ... $ has_text : logi [1:51997] TRUE TRUE TRUE TRUE TRUE TRUE ... - attr(*, &quot;date_updated&quot;)= Date[1:1], format: &quot;2016-05-05&quot; Например, сейчас мы можем понять, сколько книг на разных языках можно скачать из проекта: gutenberg_metadata %&gt;% count(language, sort = TRUE) Как видно, в основном это тексты на английском. Сколько авторов в датасете? gutenberg_metadata %&gt;% count(author, sort = TRUE) Сколько произведений Джейн Остин (не перепутайте с другими Остин) есть в датасете? gutenberg_metadata %&gt;% filter(author == &quot;Austen, Jane&quot;) %&gt;% distinct(gutenberg_id, title) Давайте скачаем “Эмму”: emma &lt;- gutenberg_download(158) Determining mirror for Project Gutenberg from http://www.gutenberg.org/robot/harvest Using mirror http://aleph.gutenberg.org emma Можно скачивать сразу несколько книг. Давайте добавим еще “Леди Сьюзен”: books &lt;- gutenberg_download(c(158, 946), meta_fields = &quot;title&quot;) books books %&gt;% count(title) Сколько уникальных заголовков из базы данных содержит “Sherlock Holmes?” Скачайте все произведения Гертруды Стайн (по-английски, она Gertrude Stein) из базы данных и вставьте название самого длинного текста. 9.3 Библиотека tidytext Сейчас скачанные книги записаны в таблицу, где одна строка это один абзац. Хочется мочь посчитать слова. Для этого книги нужно привести в tidy формат и для этого написан пакет tidytext (онлайн книга доступна здесь). Основное “оружие” пакета tidytext функция unnest_tokens(), которая переводит текст в tidy формат. В аргумент output подается вектор с именем будущей переменной, а аргумент input принимает переменную с текстом. library(tidytext) books %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) Теперь можно посчитать самые частотные слова в обоих произведениях: books %&gt;% unnest_tokens(output = &quot;word&quot;, input = text) %&gt;% count(title, word, sort = TRUE) Ну… Это было ожидаемо. Нужно убрать стопслова. Английские стопслова встроены в пакет (переменная stop_words): books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% anti_join(stop_words) Joining, by = &quot;word&quot; Постройте следующий график, на котором представлены самые частотные 20 слов каждого из произведений. Как видно, на графике все не упорядочено, давайте начнем с такого примера: books %&gt;% unnest_tokens(word, text) %&gt;% count(word, sort = TRUE) %&gt;% slice(1:20) %&gt;% ggplot(aes(n, word))+ geom_col() Если мы работаем с одним фасетом, то все проблемы может решить функция fct_reorder(), которая упорядочивает на основании некоторой переменной: books %&gt;% unnest_tokens(word, text) %&gt;% count(word, sort = TRUE) %&gt;% slice(1:20) %&gt;% mutate(word = fct_reorder(word, n)) %&gt;% ggplot(aes(n, word))+ geom_col() Однако, если мы применим это к нашим данным, то получится неупорядочено: books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% group_by(title) %&gt;% slice(1:20) %&gt;% ungroup() %&gt;% mutate(word = fct_reorder(word, n)) %&gt;% ggplot(aes(n, word))+ geom_col()+ facet_wrap(~title, scales = &quot;free&quot;) В пакете tidytext есть функция reorder_within(), которая позволяет упорядочить нужным образом: books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% group_by(title) %&gt;% slice(1:20) %&gt;% ungroup() %&gt;% mutate(word = reorder_within(x = word, by = n, within = title)) %&gt;% ggplot(aes(n, word))+ geom_col()+ facet_wrap(~title, scales = &quot;free&quot;) Чтобы избавиться от дополнительной подписи нужно использовать scale_y_reordered() или scale_x_reordered(): books %&gt;% unnest_tokens(word, text) %&gt;% count(title, word, sort = TRUE) %&gt;% group_by(title) %&gt;% slice(1:20) %&gt;% ungroup() %&gt;% mutate(word = reorder_within(x = word, by = n, within = title)) %&gt;% ggplot(aes(n, word))+ geom_col()+ facet_wrap(~title, scales = &quot;free&quot;)+ scale_y_reordered() Функция unnest_tokens() позволяет работать не только со словами, но и, напрмиер, с биграммами: books %&gt;% unnest_tokens(word, text, token = &quot;ngrams&quot;, n = 2) Поиск самых частотных слов — не едиснственная задача, которую можно решать при работе с текстом. Иногда имеет смысл узнать распределение слов в произведении. Давайте посмотрим как распределены в романе “Эмма” фамилии главных героев: books %&gt;% filter(title == &quot;Emma&quot;) %&gt;% unnest_tokens(word, text) %&gt;% mutate(narrative_time = 1:n()) %&gt;% filter(str_detect(word, &quot;knightley$|woodhouse$|churchill$|fairfax$&quot;)) %&gt;% ggplot()+ geom_vline(aes(xintercept = narrative_time))+ facet_wrap(~word, ncol = 1) Скачайте все произведения Гертруды Стайн из базы данных, уберите стопслова и визуализируйте топ 20 слов из каждого текста. Скачайте произведение Гертруды Стайн “Geography and Plays” и визуализируйте распределение в тексте слов time и living. 9.4 Пакет stopwords Выше мы упомянули, что в пакет tidytext встроен список английских стопслов. Стопслова для других язков можно раздобыть списки для других языков, используя пакет stopwords. Вместо имени языка, функция принимает ISO код языыка: library(stopwords) stopwords(&quot;ru&quot;) [1] &quot;и&quot; &quot;в&quot; &quot;во&quot; &quot;не&quot; &quot;что&quot; &quot;он&quot; &quot;на&quot; [8] &quot;я&quot; &quot;с&quot; &quot;со&quot; &quot;как&quot; &quot;а&quot; &quot;то&quot; &quot;все&quot; [15] &quot;она&quot; &quot;так&quot; &quot;его&quot; &quot;но&quot; &quot;да&quot; &quot;ты&quot; &quot;к&quot; [22] &quot;у&quot; &quot;же&quot; &quot;вы&quot; &quot;за&quot; &quot;бы&quot; &quot;по&quot; &quot;только&quot; [29] &quot;ее&quot; &quot;мне&quot; &quot;было&quot; &quot;вот&quot; &quot;от&quot; &quot;меня&quot; &quot;еще&quot; [36] &quot;нет&quot; &quot;о&quot; &quot;из&quot; &quot;ему&quot; &quot;теперь&quot; &quot;когда&quot; &quot;даже&quot; [43] &quot;ну&quot; &quot;вдруг&quot; &quot;ли&quot; &quot;если&quot; &quot;уже&quot; &quot;или&quot; &quot;ни&quot; [50] &quot;быть&quot; &quot;был&quot; &quot;него&quot; &quot;до&quot; &quot;вас&quot; &quot;нибудь&quot; &quot;опять&quot; [57] &quot;уж&quot; &quot;вам&quot; &quot;сказал&quot; &quot;ведь&quot; &quot;там&quot; &quot;потом&quot; &quot;себя&quot; [64] &quot;ничего&quot; &quot;ей&quot; &quot;может&quot; &quot;они&quot; &quot;тут&quot; &quot;где&quot; &quot;есть&quot; [71] &quot;надо&quot; &quot;ней&quot; &quot;для&quot; &quot;мы&quot; &quot;тебя&quot; &quot;их&quot; &quot;чем&quot; [78] &quot;была&quot; &quot;сам&quot; &quot;чтоб&quot; &quot;без&quot; &quot;будто&quot; &quot;человек&quot; &quot;чего&quot; [85] &quot;раз&quot; &quot;тоже&quot; &quot;себе&quot; &quot;под&quot; &quot;жизнь&quot; &quot;будет&quot; &quot;ж&quot; [92] &quot;тогда&quot; &quot;кто&quot; &quot;этот&quot; &quot;говорил&quot; &quot;того&quot; &quot;потому&quot; &quot;этого&quot; [99] &quot;какой&quot; &quot;совсем&quot; &quot;ним&quot; &quot;здесь&quot; &quot;этом&quot; &quot;один&quot; &quot;почти&quot; [106] &quot;мой&quot; &quot;тем&quot; &quot;чтобы&quot; &quot;нее&quot; &quot;кажется&quot; &quot;сейчас&quot; &quot;были&quot; [113] &quot;куда&quot; &quot;зачем&quot; &quot;сказать&quot; &quot;всех&quot; &quot;никогда&quot; &quot;сегодня&quot; &quot;можно&quot; [120] &quot;при&quot; &quot;наконец&quot; &quot;два&quot; &quot;об&quot; &quot;другой&quot; &quot;хоть&quot; &quot;после&quot; [127] &quot;над&quot; &quot;больше&quot; &quot;тот&quot; &quot;через&quot; &quot;эти&quot; &quot;нас&quot; &quot;про&quot; [134] &quot;всего&quot; &quot;них&quot; &quot;какая&quot; &quot;много&quot; &quot;разве&quot; &quot;сказала&quot; &quot;три&quot; [141] &quot;эту&quot; &quot;моя&quot; &quot;впрочем&quot; &quot;хорошо&quot; &quot;свою&quot; &quot;этой&quot; &quot;перед&quot; [148] &quot;иногда&quot; &quot;лучше&quot; &quot;чуть&quot; &quot;том&quot; &quot;нельзя&quot; &quot;такой&quot; &quot;им&quot; [155] &quot;более&quot; &quot;всегда&quot; &quot;конечно&quot; &quot;всю&quot; &quot;между&quot; Пакет предоставляет несколько источников списков: stopwords_getsources() [1] &quot;snowball&quot; &quot;stopwords-iso&quot; &quot;misc&quot; &quot;smart&quot; [5] &quot;marimo&quot; &quot;ancient&quot; &quot;nltk&quot; &quot;perseus&quot; Давайте посмотрем какие языки сейчас доступны: map(stopwords_getsources(), stopwords_getlanguages) [[1]] [1] &quot;da&quot; &quot;de&quot; &quot;en&quot; &quot;es&quot; &quot;fi&quot; &quot;fr&quot; &quot;hu&quot; &quot;ir&quot; &quot;it&quot; &quot;nl&quot; &quot;no&quot; &quot;pt&quot; &quot;ro&quot; &quot;ru&quot; &quot;sv&quot; [[2]] [1] &quot;af&quot; &quot;ar&quot; &quot;hy&quot; &quot;eu&quot; &quot;bn&quot; &quot;br&quot; &quot;bg&quot; &quot;ca&quot; &quot;zh&quot; &quot;hr&quot; &quot;cs&quot; &quot;da&quot; &quot;nl&quot; &quot;en&quot; &quot;eo&quot; [16] &quot;et&quot; &quot;fi&quot; &quot;fr&quot; &quot;gl&quot; &quot;de&quot; &quot;el&quot; &quot;ha&quot; &quot;he&quot; &quot;hi&quot; &quot;hu&quot; &quot;id&quot; &quot;ga&quot; &quot;it&quot; &quot;ja&quot; &quot;ko&quot; [31] &quot;ku&quot; &quot;la&quot; &quot;lt&quot; &quot;lv&quot; &quot;ms&quot; &quot;mr&quot; &quot;no&quot; &quot;fa&quot; &quot;pl&quot; &quot;pt&quot; &quot;ro&quot; &quot;ru&quot; &quot;sk&quot; &quot;sl&quot; &quot;so&quot; [46] &quot;st&quot; &quot;es&quot; &quot;sw&quot; &quot;sv&quot; &quot;th&quot; &quot;tl&quot; &quot;tr&quot; &quot;uk&quot; &quot;ur&quot; &quot;vi&quot; &quot;yo&quot; &quot;zu&quot; [[3]] [1] &quot;ar&quot; &quot;ca&quot; &quot;el&quot; &quot;gu&quot; &quot;zh&quot; [[4]] [1] &quot;en&quot; [[5]] [1] &quot;en&quot; &quot;de&quot; &quot;ar&quot; &quot;he&quot; &quot;zh_tw&quot; &quot;zh_cn&quot; &quot;ko&quot; &quot;ja&quot; [[6]] [1] &quot;grc&quot; &quot;la&quot; [[7]] [1] &quot;ar&quot; &quot;az&quot; &quot;da&quot; &quot;nl&quot; &quot;en&quot; &quot;fi&quot; &quot;fr&quot; &quot;de&quot; &quot;el&quot; &quot;hu&quot; &quot;id&quot; &quot;it&quot; &quot;kk&quot; &quot;ne&quot; &quot;no&quot; [16] &quot;pt&quot; &quot;ro&quot; &quot;ru&quot; &quot;sl&quot; &quot;es&quot; &quot;sv&quot; &quot;tg&quot; &quot;tr&quot; [[8]] [1] &quot;grc&quot; &quot;la&quot; Мы видим, что есть несколько источников для русского языка: length(stopwords(&quot;ru&quot;, source = &quot;snowball&quot;)) [1] 159 length(stopwords(&quot;ru&quot;, source = &quot;stopwords-iso&quot;)) [1] 559 "],["работа-со-временем-lubridate.html", "10 Работа со временем: lubridate 10.1 Создание даты 10.2 Извлечение компонентов даты 10.3 Операции с датами 10.4 Визуализация времени: данные Левада-центра", " 10 Работа со временем: lubridate library(tidyverse) Мы обсуждали, что переменные бывают разные. О них, возможно, следует думать как о шкале: Кажется, что время – просто обычная числовая переменная, на которой определены все обычные операции сложения вычитания и т. п. Однако стоит держать в голове несколько фактов: Не каждый год содержит 365 дней. Существуют високосные года. Не каждый день содержит 24 часа. Во многих странах используют переход на летнее и зимнее время. Не в каждой минуте 60 секунд. Существуют дополнительная секунда, которую добавляют чтобы компенсировать замедление во вращении земли (тогда после секунды 23:59:59 идет секунда 23:59:60). Все это мелочи учтены в пакете lubridate, созданном для работы со временем в R (https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf, туториал доступен здесь и по команде vignette(\"lubridate\")). Первые команды, которые нужно изучить: library(lubridate) Attaching package: &#39;lubridate&#39; The following objects are masked from &#39;package:base&#39;: date, intersect, setdiff, union today() [1] &quot;2021-05-29&quot; now() [1] &quot;2021-05-29 10:39:21 MSK&quot; Как видно, из этих функций в R можно работать как с датами, так и с временем. В качестве иллюстрации мы будем использовать датасет flights из пакета nycflights13, в котором содержатся данные полетов из Нью Йорка в 2013 года. library(nycflights13) flights 10.1 Создание даты Самый простой способ получить дату — это преобразовать строку в формат даты, для этого надо просто упорядочить y (year), m (month) и d (day) в команде: ymd(&quot;2020-01-21&quot;) [1] &quot;2020-01-21&quot; ymd(&quot;20-01-21&quot;) [1] &quot;2020-01-21&quot; ymd(&quot;20.01.21&quot;) [1] &quot;2020-01-21&quot; ymd(&quot;20/01/21&quot;) [1] &quot;2020-01-21&quot; ymd(&quot;200121&quot;) [1] &quot;2020-01-21&quot; mdy(&quot;January 21st, 2020&quot;) [1] &quot;2020-01-21&quot; dmy(&quot;21-Jan-2020&quot;) [1] &quot;2020-01-21&quot; Команды понимают не только английский (хоть и с трудом): dmy(&quot;21 янв 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) [1] &quot;2020-01-21&quot; dmy(&quot;21 янв. 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) [1] &quot;2020-01-21&quot; dmy(&quot;21 ян 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) [1] NA dmy(&quot;21 янва 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) [1] &quot;2020-01-21&quot; dmy(&quot;21 января 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) [1] NA dmy(&quot;21 январь 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) [1] &quot;2020-01-21&quot; dmy(&quot;21 Январь 2020&quot;, locale = &quot;ru_RU.UTF-8&quot;) [1] &quot;2020-01-21&quot; Аналогично сделаны команды состоящие из h, m, s: hms(&quot;20:01:02&quot;) [1] &quot;20H 1M 2S&quot; hm(&quot;20.01&quot;) [1] &quot;20H 1M 0S&quot; ms(&quot;23:59&quot;) [1] &quot;23M 59S&quot; Также существует команда make_datetime(), которая позволяет сделать дату из нескольких переменных: flights %&gt;% mutate(departure = make_datetime(year, month, day, hour, minute)) %&gt;% select(departure) 10.2 Извлечение компонентов даты Для извлечения компонентов даты используются функции year(), month(), week() (номер недели в году), mday() (day of the month), wday() (номер дня в неделе), yday() (номер дня в году), hour(), minute() и second(): date_example &lt;- flights$time_hour[1] date_example [1] &quot;2013-01-01 05:00:00 EST&quot; year(date_example) [1] 2013 month(date_example) [1] 1 month(date_example, label = TRUE) [1] Jan 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec month(date_example, label = TRUE, abbr = FALSE) [1] January 12 Levels: January &lt; February &lt; March &lt; April &lt; May &lt; June &lt; ... &lt; December month(date_example, label = TRUE, locale = &quot;ru_RU.UTF-8&quot;) [1] янв 12 Levels: янв &lt; фев &lt; мар &lt; апр &lt; мая &lt; июн &lt; июл &lt; авг &lt; сен &lt; ... &lt; дек week(date_example) [1] 1 mday(date_example) [1] 1 wday(date_example) [1] 3 wday(date_example, label = TRUE) [1] Tue Levels: Sun &lt; Mon &lt; Tue &lt; Wed &lt; Thu &lt; Fri &lt; Sat wday(date_example, label = TRUE, abbr = FALSE) [1] Tuesday 7 Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; ... &lt; Saturday wday(date_example, label = TRUE, locale = &quot;ru_RU.UTF-8&quot;) [1] Вт Levels: Вс &lt; Пн &lt; Вт &lt; Ср &lt; Чт &lt; Пт &lt; Сб yday(date_example) [1] 1 hour(date_example) [1] 5 minute(date_example) [1] 0 second(date_example) [1] 0 Так же есть функция leap_year(), которая сообщает информацию, является ли выбранный год високосным: leap_year(2019) [1] FALSE leap_year(2020) [1] TRUE Постройте график распределения полетов по дням недели из датасета flights пакета nycflights13. 10.3 Операции с датами Если взять две даты, то можно узнать разницу между ними и т. п.: ymd(&quot;2020-01-21&quot;) - ymd(&quot;2020-01-19&quot;) Time difference of 2 days ymd(&quot;2020-01-19&quot;) - ymd(&quot;2020-01-21&quot;) Time difference of -2 days Обратите внимание на результат работы этого выражения: hm(&quot;21:00&quot;) - hm(&quot;18:10&quot;) [1] &quot;3H -10M 0S&quot; Видимо, почему-то в таком использовании происходит поэлементная операция с часами, минутами, и секундами, так что в результате получаются отрицательные минуты. Однако, если использовать полные даты, то этого эффекта нет: ymd_hm(&quot;2020-01-21, 21:00&quot;) - ymd_hm(&quot;2020-01-21, 18:10&quot;) Time difference of 2.833333 hours ymd_hm(&quot;2020-01-21, 21:00&quot;) - hm(&quot;18:10&quot;) [1] &quot;2020-01-21 02:50:00 UTC&quot; Также существует функция difftime(), которая позволяет настраивать единицы, в которых выдается результат: difftime(ymd_hm(&quot;2020-01-21, 21:00&quot;), ymd_hm(&quot;2020-01-21, 18:10&quot;), units = &quot;mins&quot;) Time difference of 170 mins difftime(ymd_hm(&quot;2020-01-21, 21:00&quot;), ymd_hm(&quot;2020-01-21, 18:10&quot;), units = &quot;hours&quot;) Time difference of 2.833333 hours У меня есть шенгенская мультивиза на 90 дней. Я совершил несколько поездок в Европу и записал их в этот датасет. Определите, сколько дней я еще могу находиться в Евросоюзе? Однако простые даты, не являются временными отрезками, так что их нельзя складывать, вычитать, умножать и т. д. Для удобства операций в lubridate вводится несколько сущностей: periods — промежутки времени, которые игнорируют нерегулярности во времени, сразу прибавляя 1 к соответствующему разряду, вводятся функциями years(), months(), weeks(), days(), hours(), minutes(), seconds(), period() duration — промежутки времени, которые учитывают нерегулярности во времени, добавляя стандартную длительность единицы, вводятся функциями dyears(), dweeks(), ddays(), dhours(), dminutes(), dseconds(), duration() Рассмотрим несколько сложных случаев: високосный год ymd(&quot;2019-03-01&quot;)+years(1) [1] &quot;2020-03-01&quot; ymd(&quot;2019-03-01&quot;)+dyears(1) [1] &quot;2020-02-29 06:00:00 UTC&quot; переход на летнее время ymd_hms(&quot;2020-03-07 13:00:00&quot;, tz = &quot;America/New_York&quot;) + days(1) [1] &quot;2020-03-08 13:00:00 EDT&quot; ymd_hms(&quot;2020-03-07 13:00:00&quot;, tz = &quot;America/New_York&quot;) + ddays(1) [1] &quot;2020-03-08 14:00:00 EDT&quot; переход на зимнее время ymd_hms(&quot;2020-10-31 13:00:00&quot;, tz = &quot;America/New_York&quot;) + days(1) [1] &quot;2020-11-01 13:00:00 EST&quot; ymd_hms(&quot;2020-10-31 13:00:00&quot;, tz = &quot;America/New_York&quot;) + ddays(1) [1] &quot;2020-11-01 12:00:00 EST&quot; Последняя операция с датами, которую мы рассмотрим — округление: floor_date() — округление в меньшую сторону round_date() — математическое округление ceiling_date() — округление в большую сторону floor_date(ymd(&quot;2020-01-16&quot;), unit = &quot;month&quot;) [1] &quot;2020-01-01&quot; round_date(ymd(&quot;2020-01-16&quot;), unit = &quot;month&quot;) [1] &quot;2020-01-01&quot; round_date(ymd(&quot;2020-01-17&quot;), unit = &quot;month&quot;) [1] &quot;2020-02-01&quot; ceiling_date(ymd(&quot;2020-01-16&quot;), unit = &quot;month&quot;) [1] &quot;2020-02-01&quot; ceiling_date(ymd(&quot;2020-01-16&quot;), unit = &quot;year&quot;) [1] &quot;2021-01-01&quot; 10.4 Визуализация времени: данные Левада-центра Пакет tidyverse понимает переменные типа дата, и позволяет их фильтровать и визуализировать. Возьмем для примера датасет из проекта The Unwelcomed Мохамада А. Вэйкда (Mohamad A. Waked), содержащий информацию о месте и причинах смерти мигрантов и беженцев по всему миру с января 2014 года по июнь 2019 года. unwelcomed &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/death_of_migrants_and_refugees_from_the_Unwelcomed_project.csv&quot;) unwelcomed %&gt;% mutate(date = dmy(date)) %&gt;% ggplot(aes(date, total_death_missing, color = collapsed_cause))+ geom_point()+ scale_y_log10()+ labs(y = &quot;number of death/missing&quot;) unwelcomed %&gt;% mutate(date = dmy(date)) %&gt;% filter(date &lt; dmy(&quot;1-1-2016&quot;)) %&gt;% ggplot(aes(date, total_death_missing, color = collapsed_cause))+ geom_point()+ scale_y_log10()+ labs(y = &quot;number of death/missing&quot;) Однако ко переменным со врменем не всегда относятся аккуратно. Рассмотрим график с сайта Левада-центра — российской негосударственной исследовательской организации, которая проводит социологические и маркетинговые исследования (график взят отсюда): На первый взгляд, в этом графике нет ничего странного, однако если присмотреться к динамической версии на сайте Левада-центра, можно обнаружить, что на идущие подряд измерения расположены на одинаковом расстоянии друг от друга, например, 05.2014, 07.2014, 11.2014. Вот здесь можно скачать данные, по которым строился этот график. Вот как он выглядит, если считать временную переменную как время levada &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/2019.01_levada_countries.csv&quot;) levada %&gt;% mutate(date = str_c(&quot;1-&quot;, date), date = dmy(date)) %&gt;% filter(towards == &quot;USA&quot;) %&gt;% pivot_longer(names_to = &quot;answer&quot;, values_to = &quot;number&quot;, good:bad) %&gt;% ggplot(aes(date, number, color = answer))+ geom_line()+ labs(x = &quot;&quot;, y = &quot;&quot;, caption = &quot;данные Левада-центра&quot;)+ scale_y_continuous(limits = c(0, 100))+ theme(legend.position = c(0.1, 0.9), legend.title = element_blank()) На графике теперь видно, насколько регулярно проводились опросы: в начале 90-ых опросы проводились реже, потом часто, потом в районе 2010 года был перерыв. График Левада-центра можно оправдать тем, что они представляют данные от замера к замеру, так что по оси x находится как бы категориальная переменная со значениями замер 05.2014, замер 07.2014, замер 11.2014 и т. д. Однако это совсем неочевидно из графика. Используя весь датасет Левада-центра, постройте следующий график. "],["работа-с-геоданными-leaflet.html", "11 Работа с геоданными: leaflet 11.1 Векторная и растровая графика 11.2 Картографические примитивы 11.3 leaflet", " 11 Работа с геоданными: leaflet library(&quot;tidyverse&quot;) 11.1 Векторная и растровая графика Перед тем как обсуждать карты, следует сначала обсудить разницу между векторной и растровой графикой. Растровые изображения представляют собой набор упорядоченных пикселей, про каждый из которых храниться информация о цвете. Векторное изображение нельзя бесконечно увеличивать — в какой-то момент станут видны пиксели, которые в каком-то смысле являются пределом увелечения. Наиболее популярные форматы растровых изображений: JPEG, GIF, PNG, BMP, TIFF и другие. В векторных изображениях инормация храниться как собрани точек, линий и полигонов в некоторой системе координат, что позволяет бесконечно увеличивать такие изображения не теряя в качестве. Наиболее популярные форматы векторных изображений: PDF, SVG, EPS и другие. Современные технологии позволяют соединять растровые и векторные изображения, а также трансформировать их друг в друга. Картографические данные могут попадать в разные типы: точки (столицы всех стран), линии (улицы в каком-нибудь городе), полигоны (границы стран и меньших регионов) обычно имеют некоторую геопривязку (для простоты давайте считать такими, все, что имеет широту и долготу), так что могут быть представлены векторно, однако существует достаточно много информации, которую невозможно представить никак подругому, кроме как векторно: спутниковые снимки, существующие физические/политические/климатические/исторические и т. п. карты, выдача картографических сервисов, таких как Google Maps. Кроме того, занимаясь любыми типами визуализации следует помнить о разнице статической визаулизации, которую после создания нельзя изменить, и динамической визуализации, которая позволяет пользователям изменять себя (увеличиваться и уменьшаться, кликать на собрание точек и видеть их значения и т. п.). В данной главе, в отличие от предыдущих мы сосредоточимся на пакете для динамичского картографирования leaflet. Достаточно много тем останется за пределами этой главы: изменение проекции, манипуляции с географическими данными, работа с растровыми изображениями и другие (см., например, (Lovelace, Nowosad, and Muenchow 2019), доступная здесь). 11.2 Картографические примитивы В картографии существуют свои элементарные единицы: Эти единицы поддерживают популярные пакеты для манипуляции с георграфическими объектами: sp, sf и другие. В данном разделе мы не будем учиться операциям с этими объектами (объединение, вычитание и т. п., подробности смотрите в документации к пакету sp или в уже упомянавшейся книжке (Lovelace, Nowosad, and Muenchow 2019)). 11.3 leaflet Для начала включим библиотеку: library(&quot;leaflet&quot;) Здесь доступен cheatsheet, посвященный пакету leaflet. 11.3.1 .csv файлы Источником географических данных могут быть обычные привычные нам csv файлы. Например, вот здесь, хранится датасет из проекта The Unwelcomed Мохамада А. Вэйкда (Mohamad A. Waked), содержащий информацию о месте и причинах смерти мигрантов и беженцев по всему миру с января 2014 года по июнь 2019 года. unwelcomed &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/death_of_migrants_and_refugees_from_the_Unwelcomed_project.csv&quot;) id — идентификационный номер; date — дата происшедшего; total_death_missing — количество погибших/пропавших; location — место происшедшего; lat — широта; lon — долгота; collapsed_region — обобщенная информация о регионе; region — информация о регионе; collapsed_cause — обобщенная информация о причине смерти; cause_of_death — информация о причине смерти. Информация о широте и долготе иногда записывают в градусах, минутах и секундах, а иногда в десятичной записи, в R обычно используется десятичная запись. В интернете легко найти конвертеры из одного формата в другой и обратно. Самый простой способ нанести на карту координаты, это использовать комбинацию функций leaflet() %&gt;% addCircles(): unwelcomed %&gt;% leaflet() %&gt;% addCircles(lng = ~lon, # обратите внимание на особый синтаксис с тильдой lat = ~lat) Чтобы точки не “висели в воздухе” можно добавить подложку: unwelcomed %&gt;% leaflet() %&gt;% addTiles() %&gt;% addCircles(lng = ~lon, lat = ~lat) Функция addCircles() имеет массу аргументов, которая отвечает за отображение: radius color opacity fill fillColor label popup К сожалению, в пакете leaflet нет такого удобного автоматического раскрашивания по некоторой переменной, поэтому для решения такой задачи нужно сначала создать свою функцию раскрашивания. Это делается при помощи функций colorNumeric(), colorFactor(), colorBin() или colorQuantile(). pal_cat &lt;- colorFactor(&quot;Set3&quot;, domain = unwelcomed$collapsed_cause) pal_cat(unwelcomed$collapsed_cause[1]) [1] &quot;#D9D9D9&quot; Теперь в переменную pal_cat записана функция, которая возварщает цвета в зависимости от значения. В качестве первого аргумента в фукнций colorNumeric(), colorFactor(), colorBin() или colorQuantile() отправляется палитра, которую пользователь может задать сам или использовать уже имеющуюся (их можно посмотреть при помощи команды RColorBrewer::display.brewer.all()): RColorBrewer::display.brewer.all() Теперь мы готовы сделать нашу первую осмысленную карту unwelcomed %&gt;% filter(str_detect(date, &quot;2014&quot;)) %&gt;% leaflet() %&gt;% addTiles() %&gt;% addCircles(lng = ~lon, lat = ~lat, label = ~total_death_missing, # пусть возникает подпись с количеством color = ~pal_cat(collapsed_cause), # это обобщенная причина opacity = 0.9, popup = ~cause_of_death) %&gt;% # а это конкретная причина, появляется при клике мышкой addLegend(pal = pal_cat, values = ~collapsed_cause, title = &quot;&quot;) Вообще цветовая схема не очень сочетается с подложкой, так что можно поменять подложку при помощи функции addProviderTiles() (галлерею подложек можно посмотреть вот здесь): unwelcomed %&gt;% filter(str_detect(date, &quot;2014&quot;)) %&gt;% leaflet() %&gt;% addProviderTiles(&quot;Stamen.TonerLite&quot;) %&gt;% addCircles(lng = ~lon, lat = ~lat, label = ~total_death_missing, # пусть возникает подпись с количеством color = ~pal_cat(collapsed_cause), # это обобщенная причина opacity = 0.9, popup = ~cause_of_death) %&gt;% # а это конкретная причина, появляется при клике мышкой addLegend(pal = pal_cat, values = ~collapsed_cause, title = &quot;&quot;) Существует проект Карта ДТП, в котором собран датасет c дорожными происшествиями в России за некоторый временной промежуток. Визуализируйте все столкновения из датасета. Что можно увидеть на получившейся карте? 📋 список подсказок ➡ 👁 Все забыто… Как скачать датасет? ➡ Надо использовать функцию read_csv() из пакета tidyverse. 👁 Карта получилась, но есть какие-то точки на Чукотке, которые не стой стороны… ➡ Да, это стандартная проблема с Чукоткой. Прибавьте к значениям долготы 360. 👁 А как исправить значения на Чукотке? ➡ Ну нужно использовать функцию mutate(), а в ней ifelse(). Если значения меньше нуля — прибавляем 360, если больше — оставляем как есть. 11.3.2 Комбинация карт: leafsync Карты, как и все объекты в R тоже можно записать в переменную: unwelcomed %&gt;% filter(str_detect(date, &quot;2014&quot;)) %&gt;% leaflet() %&gt;% addProviderTiles(&quot;Stamen.TonerLite&quot;) %&gt;% addCircles(lng = ~lon, lat = ~lat, label = ~total_death_missing, # пусть возникает подпись с количеством color = ~pal_cat(collapsed_cause), # это обобщенная причина opacity = 0.9, popup = ~cause_of_death) %&gt;% # а это конкретная причина, появляется при клике мышкой addLegend(pal = pal_cat, values = ~collapsed_cause, title = &quot;2014&quot;) -&gt; m_2014 Теперь если вызвать переменную m_2014, появится карта, которую мы сделали. Но, что если мы хотим отобразить рядом карты 2014 года и 2015 года? Как сделать фасетизацию? К сожалению, функции для фасетизации в пакете не предусмотрена, но мы можем сделать ее самостоятельно. Для начала создадим вторую карту: unwelcomed %&gt;% filter(str_detect(date, &quot;2015&quot;)) %&gt;% leaflet() %&gt;% addProviderTiles(&quot;Stamen.TonerLite&quot;) %&gt;% addCircles(lng = ~lon, lat = ~lat, label = ~total_death_missing, # пусть возникает подпись с количеством color = ~pal_cat(collapsed_cause), # это обобщенная причина opacity = 0.9, popup = ~cause_of_death) %&gt;% # а это конкретная причина, появляется при клике мышкой addLegend(pal = pal_cat, values = ~collapsed_cause, title = &quot;2015&quot;) -&gt; m_2015 Включим библиотеку: library(&quot;leafsync&quot;) И теперь соединим две карты воедино: sync(m_2014, m_2015) 11.3.3 Работа с .geojson В данном разделе мы будем анализировать датасет, содержащий данные по всем странам мира. countries &lt;- jsonlite::read_json(&quot;https://github.com/agricolamz/DS_for_DH/raw/master/data/countries.geojson&quot;) Обратите внимание, как уже говорилось в разделе @ref{lists}, так как jsonlite конфликтует с одной из функций из tidyverse, я не загружаю библиотеку полностью при помощи команды library(jsonlite), а обращаюсь к функциям пакета при помощи выражения jsonlite::...(). В загруженном датасете достаточно много переменных, мы попробуем проанализировать количество населения и уровень доходов. countries$features %&gt;% map(&quot;properties&quot;) %&gt;% tibble(name = map_chr(., &quot;name&quot;), pop_est = map_chr(., &quot;pop_est&quot;), income = map_chr(., &quot;income_grp&quot;)) %&gt;% select(-1) %&gt;% mutate(pop_est = as.double(pop_est), income = as.factor(income)) -&gt; country_features country_features Еще одно преимущество формата .geojson заключается в том, что его позволяет просматривать github (см. пример). Самый простой способ визуализировать .geojson это используя функцию addGeoJSON(), которая в качестве аргумента принимает .geojson файл. leaflet() %&gt;% addGeoJSON(geojson = countries) Проблема этого подхода заключается в том, что файл .geojson содержит в себе форматирование, поэтому если пользователь хочет поменять отображение объектов, необходимо добавить список style к каждому узлу. Во-первых, нужно добавить список style в корень файла .geojson. В результате, это изменит отображение всех списков: countries$style = list( weight = 1, color = &quot;#555555&quot;, opacity = 1, fillOpacity = 0.8) leaflet() %&gt;% addGeoJSON(geojson = countries) Во-вторых, следует создать палитры для раскрашивания. Это делается при помощи функций colorNumeric(), colorFactor(), colorBin() или colorQuantile(). pal_num &lt;- colorNumeric(&quot;Greens&quot;, domain = c(min(country_features$pop_est), max(country_features$pop_est))) pal_cat &lt;- colorFactor(&quot;RdYlBu&quot;, domain = country_features$income) Созданные переменные pal_num() и pal_cat() сами являются функциями и возвращают раскраску в зависимости от значения: pal_num(country_features$pop_est[1]) [1] &quot;#F7FCF5&quot; pal_cat(country_features$income[1]) [1] &quot;#FDAE61&quot; В-третьих, нужно создать векторы с новыми цветами: country_features %&gt;% mutate(pop_est_color = pal_num(pop_est), income_color = pal_cat(income)) -&gt; country_features country_features В-четвертых, нужно присвоить каждому узлу свой список style: map(seq_along(countries$features), function(x){ countries$features[[x]]$properties$style &lt;- list(fillColor = country_features$income_color[x]) countries$features[[x]] }) -&gt; countries$features И последний, пятый шаг, это нарисовать получивший .geojson: leaflet() %&gt;% addGeoJSON(geojson = countries) %&gt;% addLegend(pal = pal_cat, values = country_features$income, title = &quot;Income&quot;) Повторите шаги 4 и 5 для числовой переменной (количество населения) из датасета. Ссылки на литературу "],["работа-со-списками.html", "12 Работа со списками 12.1 Что такое списки? 12.2 Пакет purrr", " 12 Работа со списками library(tidyverse) 12.1 Что такое списки? Мы обсуждали в разделе @ref{list} тип данных список, и все особенности их синтаксиса: x &lt;- list(m = &quot;a&quot;, n = c(2, 4), o = c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;)) x $m [1] &quot;a&quot; $n [1] 2 4 $o [1] &quot;blue&quot; &quot;green&quot; &quot;red&quot; x$m [1] &quot;a&quot; x[1] $m [1] &quot;a&quot; x[[2]] [1] 2 4 x[[2]][2] [1] 4 Списки вне R обычно хранят в файлах типа .json (по-английски говорят с ударением на первый слог, а вот по-русски прижился вариант с ударением на второй слог: джейсо́н) или .xml. 12.1.1 Превращение JSON в список и обратно Самое важное, что нужно знать, про .json, это то, что там могут хранится: пары ключ и значение, заключенные в фигурные скобки {\"ключ\":\"значение\"} упорядочные множества значений, заключенные в квадратные скобки [\"значение_1\",\"значение_2\",...] некоторые другие типы данных Чтение и запись .json файлов осуществляется при помощи пакета jsonlite (не входит в tidyverse). Для примера скачаем датасет 30 героев Игры престолов, который Дж. Р. Р. Мартин достал с ресурса An API of Ice And Fire. got_chars &lt;- jsonlite::read_json(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/got_chars.json&quot;) got_chars[1] [[1]] [[1]]$url [1] &quot;https://www.anapioficeandfire.com/api/characters/1022&quot; [[1]]$id [1] 1022 [[1]]$name [1] &quot;Theon Greyjoy&quot; [[1]]$gender [1] &quot;Male&quot; [[1]]$culture [1] &quot;Ironborn&quot; [[1]]$born [1] &quot;In 278 AC or 279 AC, at Pyke&quot; [[1]]$died [1] &quot;&quot; [[1]]$alive [1] TRUE [[1]]$titles [[1]]$titles[[1]] [1] &quot;Prince of Winterfell&quot; [[1]]$titles[[2]] [1] &quot;Captain of Sea Bitch&quot; [[1]]$titles[[3]] [1] &quot;Lord of the Iron Islands (by law of the green lands)&quot; [[1]]$aliases [[1]]$aliases[[1]] [1] &quot;Prince of Fools&quot; [[1]]$aliases[[2]] [1] &quot;Theon Turncloak&quot; [[1]]$aliases[[3]] [1] &quot;Reek&quot; [[1]]$aliases[[4]] [1] &quot;Theon Kinslayer&quot; [[1]]$father [1] &quot;&quot; [[1]]$mother [1] &quot;&quot; [[1]]$spouse [1] &quot;&quot; [[1]]$allegiances [1] &quot;House Greyjoy of Pyke&quot; [[1]]$books [[1]]$books[[1]] [1] &quot;A Game of Thrones&quot; [[1]]$books[[2]] [1] &quot;A Storm of Swords&quot; [[1]]$books[[3]] [1] &quot;A Feast for Crows&quot; [[1]]$povBooks [[1]]$povBooks[[1]] [1] &quot;A Clash of Kings&quot; [[1]]$povBooks[[2]] [1] &quot;A Dance with Dragons&quot; [[1]]$tvSeries [[1]]$tvSeries[[1]] [1] &quot;Season 1&quot; [[1]]$tvSeries[[2]] [1] &quot;Season 2&quot; [[1]]$tvSeries[[3]] [1] &quot;Season 3&quot; [[1]]$tvSeries[[4]] [1] &quot;Season 4&quot; [[1]]$tvSeries[[5]] [1] &quot;Season 5&quot; [[1]]$tvSeries[[6]] [1] &quot;Season 6&quot; [[1]]$playedBy [1] &quot;Alfie Allen&quot; Так как jsonlite конфликтует в одной функции с tidyverse, я не загружаю библиотеку полностью при помощи команды library(jsonlite), а обращаюсь к функциям пакета при помощи выражения jsonlite::...(). Пакет jsonlite позволяет записывать .json файлы при помощи функции write_json(): jsonlite::write_json(got_chars, &quot;got_chars.json&quot;, auto_unbox = TRUE) # аргумент auto_unbox позволяет сохранять структуру, которую мы видим в R 12.1.2 Превращение .xml в список и обратно Самое важное, что нужно знать, про .xml, это то, что этот формат представляет собой набор некоторых сущностей, которые кодируются при помощи двух тегов: открывающего &lt;...&gt; и закрывающего &lt;/...&gt;. &lt;blablabla&gt;Hello, world!&lt;/blablabla&gt; Набор сущностей может быть любым, а главное, нет фиксированного набора сущностей — пользователи могут сочинять свои стандарты, используя .xml. Кроме того, у сущностей, могут быть свои атрибуты, которые перечисляются в открывающем теге: &lt;ingredient amount=&quot;3&quot; unit=&quot;стакан&quot;&gt;Мука&lt;/ingredient&gt; &lt;ingredient amount=&quot;0.25&quot; unit=&quot;грамм&quot;&gt;Дрожжи&lt;/ingredient&gt; &lt;ingredient amount=&quot;1.5&quot; unit=&quot;стакан&quot;&gt;Тёплая вода&lt;/ingredient&gt; Чтение и запись .xml файла осущетсвляется при помощи функций read_xml() и write_xml() из пакета xml2: library(&quot;xml2&quot;) xml_example &lt;- read_xml(&#39;&lt;body&gt; &lt;ingredient amount=&quot;3&quot; unit=&quot;стакан&quot;&gt;Мука&lt;/ingredient&gt; &lt;ingredient amount=&quot;0.25&quot; unit=&quot;грамм&quot;&gt;Дрожжи&lt;/ingredient&gt; &lt;ingredient amount=&quot;1.5&quot; unit=&quot;стакан&quot;&gt;Тёплая вода&lt;/ingredient&gt; &lt;/body&gt;&#39;) xml_example {xml_document} &lt;body&gt; [1] &lt;ingredient amount=&quot;3&quot; unit=&quot;стакан&quot;&gt;Мука&lt;/ingredient&gt; [2] &lt;ingredient amount=&quot;0.25&quot; unit=&quot;грамм&quot;&gt;Дрожжи&lt;/ingredient&gt; [3] &lt;ingredient amount=&quot;1.5&quot; unit=&quot;стакан&quot;&gt;Тёплая вода&lt;/ingredient&gt; write_xml(xml_example, &quot;path/to/the/file.xml&quot;) Чтобы избавиться от тегов и превратить прочитанное в список используется команда xml_example &lt;- as_list(xml_example) xml_example $body $body$ingredient $body$ingredient[[1]] [1] &quot;Мука&quot; attr(,&quot;amount&quot;) [1] &quot;3&quot; attr(,&quot;unit&quot;) [1] &quot;стакан&quot; $body$ingredient $body$ingredient[[1]] [1] &quot;Дрожжи&quot; attr(,&quot;amount&quot;) [1] &quot;0.25&quot; attr(,&quot;unit&quot;) [1] &quot;грамм&quot; $body$ingredient $body$ingredient[[1]] [1] &quot;Тёплая вода&quot; attr(,&quot;amount&quot;) [1] &quot;1.5&quot; attr(,&quot;unit&quot;) [1] &quot;стакан&quot; Теперь полученная переменная уже является списком: xml_example$body[[2]] [[1]] [1] &quot;Дрожжи&quot; attr(,&quot;amount&quot;) [1] &quot;0.25&quot; attr(,&quot;unit&quot;) [1] &quot;грамм&quot; Здесь также нужно отметить, некоторое важное отличие .xml и .json, которое видно в рассматриваемом примере: атрибуты, которые прописываются в открывающем теге, передаются и в список в R. Функция attributes() возвращает список атрибутов и их значений: xml_example$body[[2]] %&gt;% attributes() $amount [1] &quot;0.25&quot; $unit [1] &quot;грамм&quot; Если нужен конкретный аттрибут, то нужно использовать функцию attr(): xml_example$body[[2]] %&gt;% attr(&quot;amount&quot;) [1] &quot;0.25&quot; Также на данном примере видна самая большая проблема при работе с .xml: в нашем списке есть три узла под названием ingredient, так что хоть эти узлы и имеют имя, к ним все равно нужно обращаться по индексу. 12.1.3 Просмотр списков в R Просмоторщик списков встроен в RStudio. Его можно увидеть, если ткнуть в объект в R или написать команду View(got_chars). Альтернативой может стать функция jsonedit() из пакета listviewer. Кроме того, что-то можно попробовать выяснить, используя функцию str(). str(got_chars[1]) List of 1 $ :List of 18 ..$ url : chr &quot;https://www.anapioficeandfire.com/api/characters/1022&quot; ..$ id : int 1022 ..$ name : chr &quot;Theon Greyjoy&quot; ..$ gender : chr &quot;Male&quot; ..$ culture : chr &quot;Ironborn&quot; ..$ born : chr &quot;In 278 AC or 279 AC, at Pyke&quot; ..$ died : chr &quot;&quot; ..$ alive : logi TRUE ..$ titles :List of 3 .. ..$ : chr &quot;Prince of Winterfell&quot; .. ..$ : chr &quot;Captain of Sea Bitch&quot; .. ..$ : chr &quot;Lord of the Iron Islands (by law of the green lands)&quot; ..$ aliases :List of 4 .. ..$ : chr &quot;Prince of Fools&quot; .. ..$ : chr &quot;Theon Turncloak&quot; .. ..$ : chr &quot;Reek&quot; .. ..$ : chr &quot;Theon Kinslayer&quot; ..$ father : chr &quot;&quot; ..$ mother : chr &quot;&quot; ..$ spouse : chr &quot;&quot; ..$ allegiances: chr &quot;House Greyjoy of Pyke&quot; ..$ books :List of 3 .. ..$ : chr &quot;A Game of Thrones&quot; .. ..$ : chr &quot;A Storm of Swords&quot; .. ..$ : chr &quot;A Feast for Crows&quot; ..$ povBooks :List of 2 .. ..$ : chr &quot;A Clash of Kings&quot; .. ..$ : chr &quot;A Dance with Dragons&quot; ..$ tvSeries :List of 6 .. ..$ : chr &quot;Season 1&quot; .. ..$ : chr &quot;Season 2&quot; .. ..$ : chr &quot;Season 3&quot; .. ..$ : chr &quot;Season 4&quot; .. ..$ : chr &quot;Season 5&quot; .. ..$ : chr &quot;Season 6&quot; ..$ playedBy : chr &quot;Alfie Allen&quot; str(got_chars[1], max.level = 2) List of 1 $ :List of 18 ..$ url : chr &quot;https://www.anapioficeandfire.com/api/characters/1022&quot; ..$ id : int 1022 ..$ name : chr &quot;Theon Greyjoy&quot; ..$ gender : chr &quot;Male&quot; ..$ culture : chr &quot;Ironborn&quot; ..$ born : chr &quot;In 278 AC or 279 AC, at Pyke&quot; ..$ died : chr &quot;&quot; ..$ alive : logi TRUE ..$ titles :List of 3 ..$ aliases :List of 4 ..$ father : chr &quot;&quot; ..$ mother : chr &quot;&quot; ..$ spouse : chr &quot;&quot; ..$ allegiances: chr &quot;House Greyjoy of Pyke&quot; ..$ books :List of 3 ..$ povBooks :List of 2 ..$ tvSeries :List of 6 ..$ playedBy : chr &quot;Alfie Allen&quot; str(xml_example) List of 1 $ body:List of 3 ..$ ingredient:List of 1 .. ..$ : chr &quot;Мука&quot; .. ..- attr(*, &quot;amount&quot;)= chr &quot;3&quot; .. ..- attr(*, &quot;unit&quot;)= chr &quot;стакан&quot; ..$ ingredient:List of 1 .. ..$ : chr &quot;Дрожжи&quot; .. ..- attr(*, &quot;amount&quot;)= chr &quot;0.25&quot; .. ..- attr(*, &quot;unit&quot;)= chr &quot;грамм&quot; ..$ ingredient:List of 1 .. ..$ : chr &quot;Тёплая вода&quot; .. ..- attr(*, &quot;amount&quot;)= chr &quot;1.5&quot; .. ..- attr(*, &quot;unit&quot;)= chr &quot;стакан&quot; 12.2 Пакет purrr В tidyverse встроен пакет purrr, который среди прочего позволяет работать со списками. Существует cheat sheet по purrr. 12.2.1 Функция map() и map...() Можно выводить значения в списке на основе имени: got_chars %&gt;% map(&quot;name&quot;) [[1]] [1] &quot;Theon Greyjoy&quot; [[2]] [1] &quot;Tyrion Lannister&quot; [[3]] [1] &quot;Victarion Greyjoy&quot; [[4]] [1] &quot;Will&quot; [[5]] [1] &quot;Areo Hotah&quot; [[6]] [1] &quot;Chett&quot; [[7]] [1] &quot;Cressen&quot; [[8]] [1] &quot;Arianne Martell&quot; [[9]] [1] &quot;Daenerys Targaryen&quot; [[10]] [1] &quot;Davos Seaworth&quot; [[11]] [1] &quot;Arya Stark&quot; [[12]] [1] &quot;Arys Oakheart&quot; [[13]] [1] &quot;Asha Greyjoy&quot; [[14]] [1] &quot;Barristan Selmy&quot; [[15]] [1] &quot;Varamyr&quot; [[16]] [1] &quot;Brandon Stark&quot; [[17]] [1] &quot;Brienne of Tarth&quot; [[18]] [1] &quot;Catelyn Stark&quot; [[19]] [1] &quot;Cersei Lannister&quot; [[20]] [1] &quot;Eddard Stark&quot; [[21]] [1] &quot;Jaime Lannister&quot; [[22]] [1] &quot;Jon Connington&quot; [[23]] [1] &quot;Jon Snow&quot; [[24]] [1] &quot;Aeron Greyjoy&quot; [[25]] [1] &quot;Kevan Lannister&quot; [[26]] [1] &quot;Melisandre&quot; [[27]] [1] &quot;Merrett Frey&quot; [[28]] [1] &quot;Quentyn Martell&quot; [[29]] [1] &quot;Samwell Tarly&quot; [[30]] [1] &quot;Sansa Stark&quot; Можно выводить значения в списке на основе индекса: got_chars %&gt;% map(3) [[1]] [1] &quot;Theon Greyjoy&quot; [[2]] [1] &quot;Tyrion Lannister&quot; [[3]] [1] &quot;Victarion Greyjoy&quot; [[4]] [1] &quot;Will&quot; [[5]] [1] &quot;Areo Hotah&quot; [[6]] [1] &quot;Chett&quot; [[7]] [1] &quot;Cressen&quot; [[8]] [1] &quot;Arianne Martell&quot; [[9]] [1] &quot;Daenerys Targaryen&quot; [[10]] [1] &quot;Davos Seaworth&quot; [[11]] [1] &quot;Arya Stark&quot; [[12]] [1] &quot;Arys Oakheart&quot; [[13]] [1] &quot;Asha Greyjoy&quot; [[14]] [1] &quot;Barristan Selmy&quot; [[15]] [1] &quot;Varamyr&quot; [[16]] [1] &quot;Brandon Stark&quot; [[17]] [1] &quot;Brienne of Tarth&quot; [[18]] [1] &quot;Catelyn Stark&quot; [[19]] [1] &quot;Cersei Lannister&quot; [[20]] [1] &quot;Eddard Stark&quot; [[21]] [1] &quot;Jaime Lannister&quot; [[22]] [1] &quot;Jon Connington&quot; [[23]] [1] &quot;Jon Snow&quot; [[24]] [1] &quot;Aeron Greyjoy&quot; [[25]] [1] &quot;Kevan Lannister&quot; [[26]] [1] &quot;Melisandre&quot; [[27]] [1] &quot;Merrett Frey&quot; [[28]] [1] &quot;Quentyn Martell&quot; [[29]] [1] &quot;Samwell Tarly&quot; [[30]] [1] &quot;Sansa Stark&quot; Достаточно полезно знать о функции unlist(), которая “убивает” все сложную структуру: got_chars %&gt;% map(&quot;name&quot;) %&gt;% unlist() [1] &quot;Theon Greyjoy&quot; &quot;Tyrion Lannister&quot; &quot;Victarion Greyjoy&quot; [4] &quot;Will&quot; &quot;Areo Hotah&quot; &quot;Chett&quot; [7] &quot;Cressen&quot; &quot;Arianne Martell&quot; &quot;Daenerys Targaryen&quot; [10] &quot;Davos Seaworth&quot; &quot;Arya Stark&quot; &quot;Arys Oakheart&quot; [13] &quot;Asha Greyjoy&quot; &quot;Barristan Selmy&quot; &quot;Varamyr&quot; [16] &quot;Brandon Stark&quot; &quot;Brienne of Tarth&quot; &quot;Catelyn Stark&quot; [19] &quot;Cersei Lannister&quot; &quot;Eddard Stark&quot; &quot;Jaime Lannister&quot; [22] &quot;Jon Connington&quot; &quot;Jon Snow&quot; &quot;Aeron Greyjoy&quot; [25] &quot;Kevan Lannister&quot; &quot;Melisandre&quot; &quot;Merrett Frey&quot; [28] &quot;Quentyn Martell&quot; &quot;Samwell Tarly&quot; &quot;Sansa Stark&quot; Для этого есть и отдельные функции, которые позволяют превратить все в вектор заданного типа: got_chars %&gt;% map_chr(&quot;name&quot;) [1] &quot;Theon Greyjoy&quot; &quot;Tyrion Lannister&quot; &quot;Victarion Greyjoy&quot; [4] &quot;Will&quot; &quot;Areo Hotah&quot; &quot;Chett&quot; [7] &quot;Cressen&quot; &quot;Arianne Martell&quot; &quot;Daenerys Targaryen&quot; [10] &quot;Davos Seaworth&quot; &quot;Arya Stark&quot; &quot;Arys Oakheart&quot; [13] &quot;Asha Greyjoy&quot; &quot;Barristan Selmy&quot; &quot;Varamyr&quot; [16] &quot;Brandon Stark&quot; &quot;Brienne of Tarth&quot; &quot;Catelyn Stark&quot; [19] &quot;Cersei Lannister&quot; &quot;Eddard Stark&quot; &quot;Jaime Lannister&quot; [22] &quot;Jon Connington&quot; &quot;Jon Snow&quot; &quot;Aeron Greyjoy&quot; [25] &quot;Kevan Lannister&quot; &quot;Melisandre&quot; &quot;Merrett Frey&quot; [28] &quot;Quentyn Martell&quot; &quot;Samwell Tarly&quot; &quot;Sansa Stark&quot; got_chars %&gt;% map_int(&quot;id&quot;) [1] 1022 1052 1074 1109 1166 1267 1295 130 1303 1319 148 149 150 168 2066 [16] 208 216 232 238 339 529 576 583 60 605 743 751 844 954 957 got_chars %&gt;% map_lgl(&quot;alive&quot;) [1] TRUE TRUE TRUE FALSE TRUE FALSE FALSE TRUE TRUE TRUE TRUE FALSE [13] TRUE TRUE FALSE TRUE TRUE FALSE TRUE FALSE TRUE TRUE TRUE TRUE [25] FALSE TRUE FALSE FALSE TRUE TRUE Можно даже создать новый датафрейм: got_chars %&gt;% tibble(name = map_chr(., &quot;name&quot;), # точка обозначает, в какой аргумент должно все пайпиться id = map_dbl(., &quot;id&quot;), alive = map_lgl(., &quot;alive&quot;)) У этого метода есть один недостаток: если среди значений есть значени null, то функции map_...() их пропускают. В результате получаются векторы разной длины и датафрейм не получается. Чтобы избежать этой проблемы все функции map_...() имеют аргумент .null, в который можно записать значение, которое появится в пустых ячейках, например, .null = NA. Также существует способ создание датафреймов на основе вектора значений при помощи функции enframe(): got_chars %&gt;% map_chr(&quot;name&quot;) %&gt;% enframe() Скачайте частотный словарь русского языка [Шаров, Ляшевская 2011], разбейте столбец lemma на буквы при помощи функции str_split(dict$lemma, \"\"), а на основе полученного списка постройте график, на котором изображено, сколько раз встретилась какая буква: Также можно использовать комбинацию функции map() и attr_getter() чтобы доставать все значения аттрибутов: xml_example$body %&gt;% map(attr_getter(&quot;amount&quot;)) $ingredient [1] &quot;3&quot; $ingredient [1] &quot;0.25&quot; $ingredient [1] &quot;1.5&quot; 12.2.2 Фильтрация списков Если в списке есть логические выражения, их можно использовать как фильтры. Например, вот так мы оставим только живых героев: got_chars %&gt;% keep(&quot;alive&quot;) %&gt;% map_chr(&quot;name&quot;) [1] &quot;Theon Greyjoy&quot; &quot;Tyrion Lannister&quot; &quot;Victarion Greyjoy&quot; [4] &quot;Areo Hotah&quot; &quot;Arianne Martell&quot; &quot;Daenerys Targaryen&quot; [7] &quot;Davos Seaworth&quot; &quot;Arya Stark&quot; &quot;Asha Greyjoy&quot; [10] &quot;Barristan Selmy&quot; &quot;Brandon Stark&quot; &quot;Brienne of Tarth&quot; [13] &quot;Cersei Lannister&quot; &quot;Jaime Lannister&quot; &quot;Jon Connington&quot; [16] &quot;Jon Snow&quot; &quot;Aeron Greyjoy&quot; &quot;Melisandre&quot; [19] &quot;Samwell Tarly&quot; &quot;Sansa Stark&quot; А так – только мертвых: got_chars %&gt;% discard(&quot;alive&quot;) %&gt;% map_chr(&quot;name&quot;) [1] &quot;Will&quot; &quot;Chett&quot; &quot;Cressen&quot; &quot;Arys Oakheart&quot; [5] &quot;Varamyr&quot; &quot;Catelyn Stark&quot; &quot;Eddard Stark&quot; &quot;Kevan Lannister&quot; [9] &quot;Merrett Frey&quot; &quot;Quentyn Martell&quot; Также есть особый фильтр head_while() и tail_while(), который выделяет единицы (с начала и конца) до первого FALSE. got_chars %&gt;% head_while(&quot;alive&quot;) %&gt;% map_chr(&quot;name&quot;) [1] &quot;Theon Greyjoy&quot; &quot;Tyrion Lannister&quot; &quot;Victarion Greyjoy&quot; got_chars %&gt;% tail_while(&quot;alive&quot;) %&gt;% map_chr(&quot;name&quot;) [1] &quot;Samwell Tarly&quot; &quot;Sansa Stark&quot; Если все еще не понятно, взгляните на нашу таблицу: got_chars %&gt;% tibble(name = map_chr(., &quot;name&quot;), # точка обозначает, в какой аргумент должно все пайпиться alive = map_lgl(., &quot;alive&quot;)) 12.2.3 Операции со списками Рассмотрим простой пример: my_l &lt;- list(a = 1:3, b = c(&quot;a&quot;, &quot;b&quot;), c = list(&quot;z&quot;, c(8, 9))) my_l $a [1] 1 2 3 $b [1] &quot;a&quot; &quot;b&quot; $c $c[[1]] [1] &quot;z&quot; $c[[2]] [1] 8 9 Как уже говорилось выше, функция unlist() линеаризует списки, превращая их в векторы: my_l %&gt;% unlist() a1 a2 a3 b1 b2 c1 c2 c3 &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; &quot;z&quot; &quot;8&quot; &quot;9&quot; Получился поименнованный вектор, если этого недостаточно, можно уничтожить и имена при помощи функции unname(): my_l %&gt;% unlist() %&gt;% unname() [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; &quot;b&quot; &quot;z&quot; &quot;8&quot; &quot;9&quot; Функция flatten позволяет уничтожить лишь один, верхний,, уровень иерархии: my_l %&gt;% flatten() [[1]] [1] 1 [[2]] [1] 2 [[3]] [1] 3 [[4]] [1] &quot;a&quot; [[5]] [1] &quot;b&quot; [[6]] [1] &quot;z&quot; [[7]] [1] 8 9 Как видно из этого примера, первый элемент списка my_l превратился в три первых элемента списка, а вот подсписок c = list(\"z\", c(8, 9)) превратился в элемент z и вектор c(8, 9). Существуют также функции append() и prepend(), которые позволяют добавлять новый посписок после (или до) старого: list(c(1, 2), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) %&gt;% append(list(new = c(TRUE, FALSE))) [[1]] [1] 1 2 [[2]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; $new [1] TRUE FALSE list(c(1, 2), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) %&gt;% prepend(list(new = c(TRUE, FALSE))) $new [1] TRUE FALSE [[2]] [1] 1 2 [[3]] [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Существует также функции cross() и cross2(), которые позволяют получить уникальные комбинации объектов из двух списков: list(c(&quot;a&quot;, &quot;b&quot;), 1:3) %&gt;% cross() %&gt;% str() List of 6 $ :List of 2 ..$ : chr &quot;a&quot; ..$ : int 1 $ :List of 2 ..$ : chr &quot;b&quot; ..$ : int 1 $ :List of 2 ..$ : chr &quot;a&quot; ..$ : int 2 $ :List of 2 ..$ : chr &quot;b&quot; ..$ : int 2 $ :List of 2 ..$ : chr &quot;a&quot; ..$ : int 3 $ :List of 2 ..$ : chr &quot;b&quot; ..$ : int 3 list(&quot;a&quot;, &quot;b&quot;) %&gt;% cross2(1:3) %&gt;% str() List of 6 $ :List of 2 ..$ : chr &quot;a&quot; ..$ : int 1 $ :List of 2 ..$ : chr &quot;b&quot; ..$ : int 1 $ :List of 2 ..$ : chr &quot;a&quot; ..$ : int 2 $ :List of 2 ..$ : chr &quot;b&quot; ..$ : int 2 $ :List of 2 ..$ : chr &quot;a&quot; ..$ : int 3 $ :List of 2 ..$ : chr &quot;b&quot; ..$ : int 3 Скачайте пьесу “Ревизор”, размеченную в TEI формате и постройте представленный ниже график, на котором изображено количество реплик для каждого персонажа. Превратив данные в список, лучше начинать работать с переменной revizor$TEI$text$body: Вот cheatsheet по теории вероятности. "],["описательная-статистика-распределения.html", "13 Описательная статистика, распределения 13.1 Описательная статистика 13.2 От частотности к вероятности", " 13 Описательная статистика, распределения library(tidyverse) Мы обсуждали разные типы переменных: В данном занятии мы сосредоточимся на категориальных и числовых переменных. 13.1 Описательная статистика Описательная статистика — это общий термин, в который включают понятия позволяющие оценить тренд в данных. 13.1.1 Категориальные переменные Для категориальных переменных описательных статистик не так много: количество частоты энтропия Возьмем для примера датасет starwars. Мы легко можем посчитать количество существо разных расс: starwars %&gt;% count(species, sort = TRUE) Мы также легко можем посчитать долю существо разных расс: starwars %&gt;% count(species, sort = TRUE) %&gt;% mutate(ratio = n/sum(n)) Долю легко перевести в проценты: starwars %&gt;% count(species, sort = TRUE) %&gt;% mutate(ratio = n/sum(n)*100) Мы также легко можем посчитать энтропию. В том виде, как ее сформулировал Клод Шеннон, формула выглядит так: \\[H = -\\sum_{i=1}^n p_i\\times\\log_2(p_i),\\ где\\] \\(H\\) — энтропия \\(p_i\\) — доля \\(i\\)-того независимого исхода из всех независимых исходов starwars %&gt;% count(species, sort = TRUE) %&gt;% mutate(ratio = n/sum(n)) %&gt;% summarise(entropy = -sum(ratio*log2(ratio))) Что показывает эта мера? Рассмотрим следующий тиббл: tibble(x = c(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;a&quot;), group = rep(c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;), each = 6), id = rep(1:6, 3)) %&gt;% pivot_wider(names_from = group, values_from = x) Давайте посчитаем энтропию для каждой группы: tibble(x = c(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;a&quot;), group = rep(c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;), each = 6)) %&gt;% count(group, x, sort = TRUE) %&gt;% group_by(group) %&gt;% mutate(ratio = n/sum(n)) %&gt;% summarise(entropy = -sum(ratio*log2(ratio))) Как видно, чем более разнообразна группа, тем выше энтропия. Посмотрим еще на такой тибл: tibble(x = c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;с&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;с&quot;, &quot;a&quot;), group = rep(c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;), each = 6), id = rep(1:6, 3)) %&gt;% pivot_wider(names_from = group, values_from = x) tibble(x = c(&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;с&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;с&quot;, &quot;a&quot;), group = rep(c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;), each = 6)) %&gt;% count(group, x, sort = TRUE) %&gt;% group_by(group) %&gt;% mutate(ratio = n/sum(n)) %&gt;% summarise(entropy = -sum(ratio*log2(ratio))) Как видно, чем “однороднее” группы, тем выше энтропия. Влияет ли порядок следования элементов в векторе на значение энтропии? да нет Посчитайте значение энтропии для переменных clarity, color и cut из датасета diamonds. У какой переменной значение энтропии наибольшее? clarity color cut 13.1.2 Числовые переменные Для числовых значений описательные статистики в целом предсказуемые: diamonds %&gt;% summarise(mean = mean(price), median = median(price), quantile_0.5 = quantile(price, 0.5), # квантиль quantile_0.25 = quantile(price, 0.25), quantile_0.1 = quantile(price, 0.1), min = min(price), max = max(price), var = var(price), # дисперсия sd = sd(price)) # cреднеквадратическое отклонение Смещенная оценка дисперсии выборки \\(X = {x_1, x_2, ..., x_n}\\): \\[\\sigma^2 = \\frac{1}{n}\\sum_{i = 1}^n(x_i - \\mu)^2,\\ где\\] \\(x_i\\) — i-тый элемент выборки X \\(\\mu\\) — среднее Несмещенная оценка дисперсии выборки \\(X = {x_1, x_2, ..., x_n}\\): \\[\\sigma^2 = \\frac{1}{n-1}\\sum_{i = 1}^n(x_i - \\mu)^2\\] Вот ссылка на видео, в котором объясняется, почему первая оценка смещенная. 13.2 От частотности к вероятности 13.2.1 Категориальная переменная Возьмем какой-нибудь простой случай двух взаимоисключающих исходов. Какая доля имен героев из датасета starwars начинается на букву B? Ответ округлите до 3 знаков после запятой. Мы получили такой результат на основании 9 успехов из 87 наблюдений. Но, что если они там еще чего-то наснимают? Какова вероятность, что в новом фильме будет герой на “B,” если предположить, что создатели стараются держать равновесие? 0.103? Но если там будет 13 новых героев, то полученная нами доля не будет иметь смысла, ведь 13*0.103 = 1.339. Для ответа на такие вопросы обычно используют биномиальное распределение. \\[P(k | n, p) = \\frac{n!}{k!(n-k)!} \\times p^k \\times (1-p)^{n-k} = {n \\choose k} \\times p^k \\times (1-p)^{n-k}\\] \\[ 0 \\leq p \\leq 1; n, k &gt; 0,\\ где\\] n — общее число наблюдений k — число успехов p — предполагаемая исследователем вероятность успеха Таким образом, если мы считаем вероятность 0.103 верной для данного процесса, то тогда вероятность не увидеть новых героев на букву “B” вероятнее, чем увидеть 3 или 5: Теперь мы сделали шаг в сторону вероятностной модели: все что нужно знать, что случаи двух взаимоисключающих исходов следует моделировать при помощи биномиального распределения. 13.2.2 Числовая переменная С числовой переменной все устроено похожим образом: дотплот, гистограмма, функция плотности. starwars %&gt;% ggplot(aes(height))+ geom_dotplot(method=&quot;histodot&quot;) `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. starwars %&gt;% ggplot(aes(height))+ geom_histogram(alpha = 0.5)+ geom_dotplot(method=&quot;histodot&quot;) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. starwars %&gt;% ggplot(aes(height))+ geom_histogram(alpha = 0.5, binwidth = 20)+ geom_dotplot(method=&quot;histodot&quot;) `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. starwars %&gt;% ggplot(aes(height))+ geom_histogram(alpha = 0.5, binwidth = 30)+ geom_dotplot(method=&quot;histodot&quot;) `stat_bindot()` using `bins = 30`. Pick better value with `binwidth`. starwars %&gt;% ggplot(aes(height, y =..density..))+ geom_histogram(alpha = 0.5, binwidth = 30)+ geom_density() Мы можем предположить, что генеральная совокупность можно описать нормальным распределением. \\[P(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\times e^{-\\frac{\\left(x-\\mu\\right)^2}{2\\sigma^2}}\\] \\[\\mu \\in \\mathbb{R}; \\sigma^2 &gt; 0,\\ где\\] \\(\\mu\\) — среднее \\(\\sigma^2\\) — среднеквадратическое отклонение 13.2.3 Распределения В R встроено какое-то количество известных распределений. Все они представлены четырьмя функциями: d... (функция плотности, probability density function), p... (функция распределения, cumulative distribution function) — [интеграл площади под кривой или сумма всех значений] от начала до указанной квантили q... (обратная функции распределения, inverse cumulative distribution function) — значение p-той квантили распределения и r... (рандомные числа из заданного распределения). Рассмотрим все это на примере нормального распределения. tibble(x = 1:100, PDF = dnorm(x = x, mean = 50, sd = 10)) %&gt;% ggplot(aes(x, PDF))+ geom_point()+ labs(title = &quot;PDF нормального распределения (μ = 50, σ = 10)&quot;) tibble(x = 1:100, CDF = pnorm(x, mean = 50, sd = 10)) %&gt;% ggplot(aes(x, CDF))+ geom_point()+ labs(title = &quot;CDF нормального распределения (μ = 50, σ = 10)&quot;) tibble(quantiles = seq(0, 1, by = 0.01), value = qnorm(quantiles, mean = 50, sd = 10)) %&gt;% ggplot(aes(quantiles, value))+ geom_point()+ labs(title = &quot;inverse CDF нормального распределения (μ = 50, σ = 10)&quot;) tibble(sample = rnorm(100, mean = 50, sd = 10)) %&gt;% ggplot(aes(sample))+ geom_histogram()+ labs(title = &quot;выборка нормально распределенных чисел (μ = 50, σ = 10)&quot;) Если не использовать set.seed(), то результат работы рандомизатора нельзя будет повторить. Аналогично можно использовать функции dbinom(), pbinom(), qbinom() и rbinom() для биномиального распределения, а также ..t() для распределения Стьюдента, ...chisq() для распределения хи-квадрат и т. п. Биномиальное и нормальное распределения не единственные распределения, которые придумали люди: вот ресурс, на котором сделана попытка собрать все распределения и визуализировать связи между ними; вот приложение, позволяющие исследовать разные распределения. Рассмотрим задачу, которую обсуждали выше с именами героев из датасета strawars. Посчитайте значение функции плотности в точке 3 для биномиального распределения с вероятностью успеха 0.103. (округление до 3 знаков после запятой). 13.2.4 Давайте посчитаем вероятности Какова вероятность, что мы в новом фильме будет 3 и более новых героев на “B?” Это можно вычислить при помощи функции dbinom(), pbinom(): sum(dbinom(3:13, size = 13, prob = 0.103)) [1] 0.1429756 1-pbinom(2, size = 13, prob = 0.103) [1] 0.1429756 Если предположить, что рост героев Звездных войн постоянен и описывается нормальным распределением со средним 174 и стандартным откланением 30, какова вероятность что в новом фильме встретиться герой ростом между 200 и 230? `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. integrate(function(x){dnorm(x, mean = 174, sd = 30)}, lower = 200, upper = 230) 0.1620883 with absolute error &lt; 1.8e-15 pnorm(230, mean = 174, sd = 30) - pnorm(200, mean = 174, sd = 30) [1] 0.1620883 "],["проверка-статистических-гипотез.html", "14 Проверка статистических гипотез 14.1 О статистике 14.2 Проверка нулевой гипотезы 14.3 Классификация статистических тестов 14.4 Одновыборочные тесты 14.5 Двухвыборочные тесты 14.6 Послесловие 14.7 Рассказы Чехова и Зощенко 14.8 Obamacare", " 14 Проверка статистических гипотез 14.1 О статистике Статистика позволяет оценить какие-то стохастические процессы, которые происходят в мире. Центральное понятие статистики — генеральная совокупность, множество всех элементов какой-либо группы, параметр которой мы хотим оценить: все жители РФ при оценке роста; все возможные тексты писателя (реальные и потенциальные) при оценке частоты встречаемости каких-либо элементов; все возможные курсы валют при попытке оценить курс валюты завтра; все страны при попытке оценить количество уникальных имен в странах мира и т. д. Весь статистический анализ строится на основе предположений о свойствах генеральной совокупности и некоторой выборки из генеральной совкупности. Так если мы не можем взять всю генеральную совокупность и оценить ее параметр θ (средний рост, доля встречаемости гласных в текстах писателя и т. д.), то мы берем случайную выборку из генеральной совокупности и оцениваем параметр выборки θ̂ и делаем предположения о том, как параметр может быть устроен в генеральной совокупности. Если выборка, которой мы располагаем содержит в себе генеральную совокупность, то нужда оценить некоторый параметр казалось бы отпадает (в таком случае задача переходит в область теории вероятностей): Какая доля слов “не” в корпусе текстов Пушкина? Однако бывают задачи, которые даже обладая генеральной совокупностью, можно переформулировать в статистические: Какая доля слов “не” будет в свежеобнаруженном тексте Пушкина длины \\(n\\)? Исследователь каждый год ездит на остров Суматра и обнаруживает каждый год несколько неизвестных науке видов ящериц. С каждый годом он обнаруживает неизвестные науке виды ящериц все реже и реже. Можем ли мы оценить сколько ящериц неизвестного вида исследователь найдет в этом году? Существует несколько школ статистического анализа: фриквентистская и байесовская. Мы будем работать в рамках фриквентистской. 14.2 Проверка нулевой гипотезы Теперь мы обсудим стандартный трюк, который получил большую популярность в XX веке, и сейчас повсеместно продолжает использоваться. Этот трюк, к сожалению, помогает лишь показать, что что-то отличается, так что мы немножко переиначим наши задачи. Представим себе, что я исследую героев Звездных войн. Я верю, что герои с именем на “B” встречаются в Звездных войнах с вероятностью 0.103. В новом фильме из 13 новых персонажей 4 имеют имя на “B,” т. е. мы наблюдаем долю 0.31. Является ли разница межда наблюдениями 0.31 и ожиданиями 0.103 статистически значимой? Создадим две гипотезы: \\(H_0\\) — (нулевая гипотеза) разница не является статистически значимой, т. е. наблюдаемые данные могут происходят из ожидаемого распределения. \\(H_1\\) — (альтернативная гипотеза) разница является статистически значимой, т. е. наблюдаемые данные не могут происходят из ожидаемого распределения. Нулевая гипотеза — это гипотеза, которую каждый исследователь хочет отвергнуть, и принять альтернативную. После применения статистического критерия (каждый критерий зависит от конкретного статистического теста, а выбор теста зависит от типа данных) исследователь считает вероятность наблюдать такой или более экстремальный результат, если верна нулевая гипотеза (p-value, p-уровень значимости): sum(dbinom(4:13, size = 13, prob = 0.103)) [1] 0.03758494 Это же можно сделать при помощи следующей функции: binom.test(x = 4, n = 13, p = 0.103, alternative = &quot;greater&quot;) Exact binomial test data: 4 and 13 number of successes = 4, number of trials = 13, p-value = 0.03758 alternative hypothesis: true probability of success is greater than 0.103 95 percent confidence interval: 0.1126658 1.0000000 sample estimates: probability of success 0.3076923 Дальше в разных науках принимают некоторое критическое значение (в большинстве случаев это 0.05), и если p-value меньше данного заветного значения, считается, что тогда разница является статистически значимой. If all else fails, use “significant at a p&gt;0.05 level” and hope no one notices (https://xkcd.com/1478/) 14.3 Классификация статистических тестов 14.3.1 Количество выборок Одновыборочные тесты (one-sample tests) Двухвыборочные тесты (two-sample tests) многовыборочные тесты (multiple-sample tests) 14.3.2 Направление односторонние двусторонние 14.3.3 Парные vs. непарные непарные — если наблюдения в одной группе независимы друг от друга (мужчины vs. женщины, пожилые vs. молодые? и т. д.) парные — если наблюдения имеют соответствия между собой (настроение до пары R и после, измерение температуры обычным и инфракрасным термометром, и т. п.) 14.3.4 Параметрические vs. непараметрические Некоторые тесты работают с предположениями об устройстве данных. В нашем случае данные предположения: нормальность распределения. 14.3.5 Классификация тестов распределение тип группы # групп тест категориальные с заданным значением 1 биномиальный тест, χ² категориальные независимые 2 χ², тест Фишера, G-test (LL-score) категориальные зависимые 2 критерий Мак-Нимара нормальное с заданным значением 1 одновыборочный t-test нормальное независимые 2 t-test для независимых выборок нормальное зависимые 2 парный t-test не нормальное с заданным значением 1 критерий Уилкоксона не нормальное независимые 2 критерий Манна-Уитни не нормальное зависимые 2 критерий Уилкоксона 14.4 Одновыборочные тесты 14.4.1 Биномиальный тест Мы уже обсудили биномиальный тест выше. В частотном словаре [Ляшевская Шаров 2009], созданном на базе корпуса объемом 92 млн. словоупотреблений, существительное кенгуру имеет абсолютную частотность 0.0000021, а предлог к — 0.005389 (его вариант ко в расчет не берется). В некотором тексте длиной 61981 слов существительное кенгуру встречается 58 раз, а предлог к — 254. Можем ли мы считать, что это обычный ничем не примечательный результат? # кенгуру binom.test(x = 58, n = 61981, p = 0.0000021) Exact binomial test data: 58 and 61981 number of successes = 58, number of trials = 61981, p-value &lt; 2.2e-16 alternative hypothesis: true probability of success is not equal to 2.1e-06 95 percent confidence interval: 0.0007106442 0.0012095348 sample estimates: probability of success 0.0009357706 # к binom.test(x = 254, n = 61981, p = 0.005389) Exact binomial test data: 254 and 61981 number of successes = 254, number of trials = 61981, p-value = 5.862e-06 alternative hypothesis: true probability of success is not equal to 0.005389 95 percent confidence interval: 0.003610363 0.004632987 sample estimates: probability of success 0.00409803 Мы посчитали количество букв а в рассказе А. П. Чехова и получили 58 букв из рассказа длинной 699 букв (пробелы и латинские буквы выкинуты). Является ли этот результат неожиданным, если мы ожидали долю 0.08. Приведите значение p-value с точностью до 2 знаком после запятой. 14.4.2 Одновыборочный t-тест Из статьи С. Степановой 2011 мы знаем, что носители русского языка в среднем говорят 5.31 слога в секунду со стандартным отклонением 1,93 (мужчины 5.46 слога в секунду со средним отклонением 2.02, женщины 5.23 слога в секунду со средним отклонением 1.84, дети 3.86 слога в секунду со средним отклонением 1.67). Мы опросили 30 носителей деревни N и выяснили, что средняя равна 7, а стандартное отклонение равно 2. Является ли данная разницастатистически значимой? set.seed(42) data &lt;- rnorm(n = 30, mean = 7, sd = 2) tibble(data) %&gt;% ggplot(aes(data))+ geom_dotplot()+ geom_vline(xintercept = mean(data), size = 2, linetype = 2)+ geom_vline(xintercept = 5.31, size = 2, linetype = 2, color = &quot;red&quot;)+ annotate(geom = &quot;text&quot;, x = 3, color = &quot;red&quot;, y = 0.75, label = &quot;среднее согласно\\n[Степанова 2011]&quot;, size = 5) t.test(data, mu = 5.31) One Sample t-test data: data t = 3.9871, df = 29, p-value = 0.0004143 alternative hypothesis: true mean is not equal to 5.31 95 percent confidence interval: 6.199903 8.074444 sample estimates: mean of x 7.137174 Создайте 30 нормально распределенных наблюдений со средним 6 и стандартным отклонением 2, используя set.seed(42) и сравните полученные данные с результатами Степановой. Является ли разница статистически значимой? Приведите значение p-value с точностью до 2 знаком после запятой. t-тест имеет несколько предположений относительно структуры данных: нормальность распределения данных гомоскедостичность (гомогенность) дисперсии 14.4.3 Тест Уилкоксона Если данные не нормально распределено, обычно используют критерий Уилкоксона set.seed(42) data &lt;- rlnorm(n = 30, mean = 1.8, sd = 0.1) tibble(data) %&gt;% ggplot(aes(data))+ geom_dotplot()+ geom_vline(xintercept = mean(data), size = 2, linetype = 2)+ geom_vline(xintercept = 5.31, size = 2, linetype = 2, color = &quot;red&quot;)+ annotate(geom = &quot;text&quot;, x = 4.9, color = &quot;red&quot;, y = 0.75, label = &quot;среднее согласно\\n[Степанова 2011]&quot;, size = 5) wilcox.test(data, mu = 5.31) Wilcoxon signed rank exact test data: data V = 436, p-value = 3.239e-06 alternative hypothesis: true location is not equal to 5.31 14.5 Двухвыборочные тесты 14.5.1 Двухвыборочный t-тест Логика двухвыборочного теста такая же как одновыборочного: set.seed(42) sample_1 &lt;- rnorm(25, mean = 40, sd = 5) sample_2 &lt;- rnorm(25, mean = 50, sd = 4.5) tibble(sample_1, sample_2) %&gt;% pivot_longer(names_to = &quot;dataset&quot;, values_to = &quot;values&quot;, sample_1:sample_2) %&gt;% group_by(dataset) %&gt;% mutate(mean = mean(values)) %&gt;% ggplot(aes(values, fill = dataset))+ geom_dotplot(show.legend = FALSE)+ geom_vline(aes(xintercept = mean, color = dataset), size = 2, linetype = 2, show.legend = FALSE) t.test(sample_1, sample_2) Welch Two Sample t-test data: sample_1 and sample_2 t = -5.0632, df = 41.295, p-value = 9.005e-06 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: -11.046695 -4.748026 sample estimates: mean of x mean of y 40.93768 48.83504 В работе (Coretta 2017, https://goo.gl/NrfgJm) рассматривается отношения между длительностью гласного и придыхание согласного. Автор собрал данные 5 носителей исландского. Дальше он извлек длительность гласного, после которого были придыхательные и непридыхательные. Скачайте данные и Проверьте, правда ли, что гласные перед аспирированныем согласными статистикали значимо короче гласных после которых непридыхательные для носителя. В ответе приведите t-статистику c точностью до трех знаков после запятой. 14.5.2 Двухвыборочный парный t-тест set.seed(42) sample_1 &lt;- rnorm(25, mean = 40, sd = 5) sample_2 &lt;- sample_1 - rnorm(25, mean = 5) tibble(sample_1, sample_2) %&gt;% pivot_longer(names_to = &quot;dataset&quot;, values_to = &quot;values&quot;, sample_1:sample_2) %&gt;% group_by(dataset) %&gt;% mutate(mean = mean(values)) %&gt;% ggplot(aes(values, fill = dataset))+ geom_dotplot(show.legend = FALSE)+ geom_vline(aes(xintercept = mean, color = dataset), size = 2, linetype = 2, show.legend = FALSE) t.test(sample_1, sample_2, paired = TRUE) Paired t-test data: sample_1 and sample_2 t = 25.034, df = 24, p-value &lt; 2.2e-16 alternative hypothesis: true difference in means is not equal to 0 95 percent confidence interval: 4.350251 5.131990 sample estimates: mean of the differences 4.74112 14.5.3 Критерий Манна-Уитни Если данные не распределены нормально, тогда используется критерий Манна-Уитни (по английски его тоже называют Wilcoxon test). set.seed(42) data_1 &lt;- rlnorm(n = 30, mean = 1.8, sd = 0.1) data_2 &lt;- rlnorm(n = 30, mean = 1.6, sd = 0.1) tibble(data_1, data_2) %&gt;% pivot_longer(names_to = &quot;dataset&quot;, values_to = &quot;values&quot;, data_1:data_2) %&gt;% group_by(dataset) %&gt;% mutate(mean = mean(values)) %&gt;% ggplot(aes(values, fill = dataset))+ geom_dotplot(show.legend = FALSE)+ geom_vline(aes(xintercept = mean, color = dataset), size = 2, linetype = 2, show.legend = FALSE) wilcox.test(data_1, data_2) Wilcoxon rank sum exact test data: data_1 and data_2 W = 818, p-value = 2.419e-09 alternative hypothesis: true location shift is not equal to 0 14.5.4 Критерий χ², тест Фишера Если мы хотим сравнить распределение категориальных переменных, то обычно строят таблицы сопряженности и используют критерий χ². Например, из интервью с носителями одной деревни произвольным образом выбрали по пол часа и посчитали кол-во реализаций диалектных форм vs. недиалектных. В результате получилось что у женщин было 107 диалектных форм vs. 93 недиалектные, а у мужчин — 74 vs. 45. Значима ли зафиксированная разница? dialect_forms &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/dialect_forms_fake.csv&quot;) dialect_forms %&gt;% ggplot(aes(gender, fill = form))+ geom_bar() table(dialect_forms) gender form female male dialect 107 74 standard 93 45 prop.table(table(dialect_forms)) gender form female male dialect 0.3354232 0.2319749 standard 0.2915361 0.1410658 chisq.test(table(dialect_forms)) Pearson&#39;s Chi-squared test with Yates&#39; continuity correction data: table(dialect_forms) X-squared = 1.9525, df = 1, p-value = 0.1623 Критерий χ² считают относительно наблюдаемых \\(f_o\\) и ожидаемых \\(f_e\\) значений: \\[\\chi^2 = \\sum\\frac{\\left(f_0-f_e\\right)^2}{f_e}\\] Считается, что критерий χ² не стоит применять, если хотя бы одно из ожидаемых значений меньше 5. Давайте посмотрим на ожидаемые наблюдения: chisq.test(table(dialect_forms))$expected gender form female male dialect 113.47962 67.52038 standard 86.52038 51.47962 chisq.test(table(dialect_forms))$observed gender form female male dialect 107 74 standard 93 45 Если одно из ожидаемых значений меньше 5, то следует использовать тест Фишера: fisher.test(table(dialect_forms)) Fisher&#39;s Exact Test for Count Data data: table(dialect_forms) p-value = 0.1608 alternative hypothesis: true odds ratio is not equal to 1 95 percent confidence interval: 0.4279225 1.1396897 sample estimates: odds ratio 0.7004421 Вообще таблицы сопряженности бывают разные, да и тестов куда больше см. (Lydersen, Fagerland, and Laake 2009) 14.5.5 Критерий Мак Немара Во время диалектологической экспедиции от 20 информантов (10 мужчин, 10 женщин) были записаны списки слов. Получилось, что 13 информантов использовали в речи велярный фрикативный ɣ, а 22 — велярный стоп ɡ. Через 5 лет работали с теми же информантами и соотношение немного поменялось: 7 ɣ против 28 ɡ. Является ли получившаяся разница статистически значимой? repeated_dialect_forms &lt;- read_csv(&quot;https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/dialect_forms_repeated_fake.csv&quot;) table(repeated_dialect_forms) time feature after before fricative 7 13 stop 28 22 prop.table(table(repeated_dialect_forms)) time feature after before fricative 0.1000000 0.1857143 stop 0.4000000 0.3142857 repeated_dialect_forms %&gt;% ggplot(aes(time, fill = feature))+ geom_bar() mcnemar.test(table(repeated_dialect_forms)) McNemar&#39;s Chi-squared test with continuity correction data: table(repeated_dialect_forms) McNemar&#39;s chi-squared = 4.7805, df = 1, p-value = 0.02878 14.6 Послесловие P-value очень много ругают за то, что его очень часто понимают неправильно (Gigerenzer 2004), (Goodman 2008) за то, что само по себе p-value &lt; 0.05 слабый довод (Sterne and Smith 2001), (Nuzzo and others 2014), (Wasserstein and Lazar 2016) Q: Why do so many colleges and grad schools teach p = 0.05? A: Because that’s still what the scientific community and journal editors use. Q: Why do so many people still use p = 0.05? A: Because that’s what they were taught in college or grad school (Wasserstein and Lazar 2016) В связи с этим, сейчас можно наблюдать большое обсуждение p-value vs. доверительные интервалы все нарастающую популярность Байесовской статистики 14.7 Рассказы Чехова и Зощенко 14.7.1 Рассказы Чехова и Зощенко собраны в tidy формате. Постройте график. Узнайте долю, которую составляют слова c леммой деньги от всех слов рассказа и проведите статистический тесты, сравнивающие [доли слов с леммой деньги] с знечением 0.000512 из частотного словаря русского языка [Шаров, Ляшевская 2011]. Приведите значение p-value для Чехова, округленное до 3 знаков после запятой: Приведите значение t-статистики для Чехова, округленное до 3 знаков после запятой: Приведите значение p-value для Зощенко, округленное до 3 знаков после запятой: Приведите значение t-статистики для Зощенко, округленное до 3 знаков после запятой: 14.7.2 Рассказы Чехова и Зощенко собраны в tidy формате. Постройте график. Проведите статистический тест, проверяющий, действительно ли Зощенко писал более короткие рассказы чем Чехов. Приведите значение p-value, округленное до 3 знаков после запятой Приведите абсолютное (т. е. неотрицательное) значение t-статистики, округленное до 3 знаков после запятой: 14.7.3 Посчитайте энтропию каждого рассказа, визуализируйте разницу между авторами и проведите статистический тест, который показывает, что энтропия в рассказах Зощенко выше. `summarise()` has grouped output by &#39;author&#39;, &#39;titles&#39;. You can override using the `.groups` argument. Приведите название рассказа с минимальной энтропией Крест Надул Библиография Вывеска Приведите название рассказа с максимальной энтропией Великосветская История Черная магия Вор Монастырь Приведите значение p-value, округленное до 3 знаков после запятой Приведите значение t-статистики, округленное до 3 знаков после запятой: 14.7.4 Визуализируйте количество слов и энтропию каждого автора. Какие выводы можно сделать на основании полученого графика? `summarise()` has grouped output by &#39;author&#39;, &#39;titles&#39;. You can override using the `.groups` argument. 14.8 Obamacare В 2010 Б. Обама подписал закон о доступном здравоохранении. В датасет записаны данные о доле незастрахованных людей (в процентах) в каждом штате в 2010 и в 2015 годах (исходные данные на kaggle). Нарисуйте график (я использовал geom_linerange(aes(ymin = …, ymax = …))) и проведите статистический тест, показывающий что произошло изменение. Приведите среднее значение разниц между годами Приведите значение p-value, округленное до 3 знаков после запятой Приведите значение t-статистики, округленное до 3 знаков после запятой: Ссылки на литературу "],["корреляция-и-регрессия.html", "15 Корреляция и регрессия 15.1 Дисперсия и стандартное отклонение 15.2 z-преобразование 15.3 Ковариация 15.4 Корреляция 15.5 Регрессионный анализ", " 15 Корреляция и регрессия 15.1 Дисперсия и стандартное отклонение Дисперсия — мера разброса значений наблюдений относительно среднего. \\[\\sigma^2_X = \\frac{\\sum_{i = 1}^n(x_i - \\bar{x})^2}{n - 1},\\] где \\(x_1, ..., x_n\\) — наблюдения; \\(\\bar{x}\\) — среднее всех наблюдений; \\(X\\) — вектор всех наблюдений; \\(n\\) — количество наблюдений. Представим, что у нас есть следующие данные: Тогда дисперсия — это сумма квадратов расстояний от каждой точки до среднего выборки (пунктирная линия) разделенное на количество наблюдений - 1 (по духу эта мера — обычное среднее, но если вас инетересует разница смещенной и несмещенной оценки дисперсии, см. видео). Для того чтобы было понятнее, что такое дисперсия, давайте рассмотрим несколько расспределений с одним и тем же средним, но разными дисперсиями: В R дисперсию можно посчитать при помощи функции var()24. set.seed(42) x &lt;- rnorm(20, mean = 50, sd = 10) var(x) [1] 172.2993 Проверим, что функция выдает то же, что мы записали в формуле. var(x) == sum((x - mean(x))^2)/(length(x)-1) [1] TRUE Так как дисперсия является квадратом отклонения, то часто вместо нее используют более интерпретируемое стандартное отклонение \\(\\sigma\\) — корень из дисперсии. В R ее можно посчитать при помощи функции sd(): sd(x) [1] 13.12628 sd(x) == sqrt(var(x)) [1] TRUE Посчитайте дисперсию переменной sleep_total в датасете msleep, встроенный в tidyverse. Ответ округлите до двух знаков после запятой. Посчитайте стандартное отклонение переменной sleep_total в датасете msleep, встроенный в tidyverse. Ответ округлите до двух знаков после запятой. 15.2 z-преобразование z-преобразование (еще используют термин нормализация) — это способ представления данных в виде расстояний от среднего, измеряемых в стандартных отклонениях. Для того чтобы его получить, нужно из каждого наблюдения вычесть среднее и результат разделить на стандартное отклонение. \\[x_i = \\frac{x_i - \\bar{x}}{\\sigma_X}\\] Если все наблюдения z-преобразовать, то получиться распределение с средним в 0 и стандартным отклонением 1 (или очень близко к ним). Само по себе \\(z\\)-преобразование ничего особенного нам про данные не говорит. Однако это преобразование позволяет привести к “общему знаменателю” разные переменные. Т. е. это преобразование ничего нам не говорит про конкретный набор данных, но позволяет сравнивать разные наборы данных. В R z-преобразование можно сделать при помощи функции scale(). Эта функция вовзращает матрицу, поэтому я использую индекс [,1], чтобы результат был вектором. set.seed(42) x &lt;- rnorm(20, mean = 50, sd = 10) scale(x)[,1] [1] 0.8982271 -0.5764146 0.1304317 0.3359234 0.1617734 -0.2270593 [7] 1.0053127 -0.2183246 1.3914857 -0.1939880 0.8478787 1.5958251 [13] -1.2042865 -0.3586002 -0.2477787 0.3382758 -0.3627629 -2.1699785 [19] -2.0054319 0.8594918 Проверим, что функция выдает то же, что мы записали в формуле. scale(x)[,1] == (x-mean(x))/sd(x) [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [16] TRUE TRUE TRUE TRUE TRUE Однаждый я заполучил градусник со шкалой Фаренгейта и целый год измерял температуру в Москве при помощи градусников с шкалой Фарингейта и Цельсия. В датасет записаны средние значения для каждого месяца. Постройте график нормализованных и ненормализованных измерений. Что можно сказать про измерения, сделанные разными термометрами? 15.3 Ковариация Ковариация — эта мера ассоциации двух переменных. \\[cov(X, Y) = \\frac{\\sum_{i = 1}^n(x_i - \\bar{x})(y_i-\\bar{y})}{n - 1},\\] где \\((x_1, y_1), ..., (x_n, y_n)\\) — пары наблюдений; \\(\\bar{x}, \\bar{y}\\) — средние наблюдений; \\(X, Y\\) — векторы всех наблюдений; \\(n\\) — количество наблюдений. Представим, что у нас есть следующие данные: Тогда, согласно формуле, для каждой точки вычисляется следующая площадь (пуктирными линиями обозначены средние): Если значения \\(x_i\\) и \\(y_i\\) какой-то точки либо оба больше, либо оба меньше средних \\(\\bar{x}\\) и \\(\\bar{y}\\), то получившееся произведение будет иметь знак +, если же наоборот — знак -. На графике это показано цветом. Таким образом, если много красных прямоугольников, то значение суммы будет положительное и обозначать положительную связь (чем больше \\(x\\), тем больше \\(y\\)), а если будет много синий прямоугольников, то значение суммы отрицательное и обозначать положительную связь (чем больше \\(x\\), тем меньше \\(y\\)). Непосредственно значение ковариации не очень информативно, так как может достаточно сильно варьироваться от датасета к датасету. В R ковариацию можно посчитать при помощи функции cov(). set.seed(42) x &lt;- rnorm(10, mean = 50, sd = 10) y &lt;- x + rnorm(10, sd = 10) cov(x, y) [1] 18.72204 cov(x, -y*2) [1] -37.44407 Как видно, простое умножение на два удвоило значение ковариации, что показывает, что непосредственно ковариацию использовать для сравнения разных датасетов не стоит. Проверим, что функция выдает то же, что мы записали в формуле. cov(x, y) == sum((x-mean(x))*(y - mean(y)))/(length(x)-1) [1] TRUE 15.4 Корреляция Корреляция — это мера ассоциации/связи двух числовых переменных. Помните, что бытовое применение этого термина к категориальным переменным (например, корреляция цвета глаз и успеваемость на занятиях по R) не имеет смысла с точки зрения статистики. 15.4.1 Корреляция Пирсона Коэффициент корреляции Пирсона — базовый коэффициент ассоциации переменных, однако стоит помнить, что он дает неправильную оценку, если связь между переменными нелинейна. \\[\\rho_{X,Y} = \\frac{cov(X, Y)}{\\sigma_X\\times\\sigma_Y} = \\frac{1}{n-1}\\times\\sum_{i = 1}^n\\left(\\frac{x_i-\\bar{x}}{\\sigma_X}\\times\\frac{y_i-\\bar{y}}{\\sigma_Y}\\right),\\] где \\((x_1, y_1), ..., (x_n, y_n)\\) — пары наблюдений; \\(\\bar{x}, \\bar{y}\\) — средние наблюдений; \\(X, Y\\) — векторы всех наблюдений; \\(n\\) — количество наблюдений. Последнее уравнение показывает, что коэффициент корреляции Пирсона можно представить как среднее (с поправкой, поэтому \\(n-1\\), а не \\(n\\)) произведение \\(z\\)-нормализованных значений двух переменных. Эта нормализация приводит к тому, что значения корреляции имеют те же свойства знака коэффициента что и ковариация: если коэффициент положительный (т. е. много красных прямоугольников) — связь между переменными положительная (чем больше \\(x\\), тем больше \\(y\\)), если коэффициент отрицательный (т. е. много синих прямоугольников) — связь между переменными отрицательная (чем больше \\(x\\), тем меньше \\(y\\)); значение корреляции имееет независимое от типа данных интеретация: если модуль коэффициента близок к 1 или ему равен — связь между переменными сильная, если модуль коэффициента близок к 0 или ему равен — связь между переменными слабая. Для того чтобы было понятнее, что такое корреляция, давайте рассмотрим несколько расспределений с разными значениями корреляции: Как видно из этого графика, чем ближе модуль корреляции к 1, тем боллее компактно расположены точки друг к другу, чем ближе к 0, тем более рассеяны значения. Достаточно легко научиться приблизительно оценивать коэфициент корреляции на глаз, поиграв 2–5 минут в игру “Угадай корреляцию” здесь или здесь. В R коэффициент корреляции Пирсона можно посчитать при помощи функции cor(). set.seed(42) x &lt;- rnorm(15, mean = 50, sd = 10) y &lt;- x + rnorm(15, sd = 10) cor(x, y) [1] 0.6659041 Проверим, что функция выдает то же, что мы записали в формуле. cor(x, y) == cov(x, y)/(sd(x)*sd(y)) [1] TRUE cor(x, y) == sum(scale(x)*scale(y))/(length(x)-1) [1] TRUE Посчитайте на основе датасета с температурой корреляцию между разными измерениями в шкалах Фарингейта и Цельсия? Результаты округлите до трех знаков после запятой. 15.4.2 Ранговые корреляции Спирмана и Кендалла Коэффициент корреляции Пирсона к сожалению, чувствителен к значениям наблюдений. Если связь между переменными нелинейна, то оценка будет получаться смещенной. Рассмотрим, например, словарь [Ляшевской, Шарова 2011]: freqdict &lt;- read_tsv(&quot;https://github.com/agricolamz/DS_for_DH/raw/master/data/freq_dict_2011.csv&quot;) freqdict %&gt;% arrange(desc(freq_ipm)) %&gt;% mutate(id = 1:n()) %&gt;% slice(1:100) -&gt; filered_freqdict filered_freqdict %&gt;% ggplot(aes(id, freq_ipm, label = lemma))+ geom_point()+ ggrepel::geom_text_repel()+ scale_y_log10() В целом корреляция между рангом и частотой должна быть высокая, однако связь между этими переменными нелинейна, так что коэффициент корреляции Пирсона не такой уж и высокий: cor(filered_freqdict$freq_ipm, filered_freqdict$id) [1] -0.6307876 Для решения той проблемы обычно используют ранговые коэффециенты коррляции Спирмана и Кендала, которые принимают во внимание ранг значения, а не его непосредственное значение. cor(filered_freqdict$freq_ipm, filered_freqdict$id, method = &quot;spearman&quot;) [1] -1 cor(filered_freqdict$freq_ipm, filered_freqdict$id, method = &quot;kendall&quot;) [1] -1 Давайте сравним с предыдущими наблюдениями и их логаотфмамиы: cor(x, y) == cor(log(x), log(y)) [1] FALSE cor(x, y, method = &quot;spearman&quot;) == cor(log(x), log(y), method = &quot;spearman&quot;) [1] TRUE cor(x, y, method = &quot;kendall&quot;) == cor(log(x), log(y), method = &quot;kendall&quot;) [1] TRUE 15.5 Регрессионный анализ 15.5.1 Основы Суть регрессионного анализа в моделировании связи между двумя и более переменными при помощи прямой на плоскости. Формула прямой зависит от двух параметров: свободного члена (intercept) и углового коэффициента (slope). Укажите значение свободного члена для красной прямой. -2 -1 0 1 2 3 4 Укажите значение свободного члена для зеленой прямой. -2 -1 0 1 2 3 4 Укажите значение свободного члена для синей прямой. -2 -1 0 1 2 3 4 Укажите значение углового коэффициента для красной прямой. -2 -1 0 1 2 3 4 Укажите значение углового коэффициента для зеленой прямой. -2 -1 0 1 2 3 4 Укажите значение углового коэффициента для синей прямой. -2 -1 0 1 2 3 4 Когда мы пытаемся научиться предсказывать данные одной переменной \\(Y\\) при помощи другой переменной \\(X\\), мы получаем похожую формулу: \\[y_i = \\hat\\beta_0 + \\hat\\beta_1 \\times x_i + \\epsilon_i,\\] где \\(x_i\\) — \\(i\\)-ый элемент вектора значений \\(X\\); \\(y_i\\) — \\(i\\)-ый элемент вектора значений \\(Y\\); \\(\\hat\\beta_0\\) — оценка случайного члена (intercept); \\(\\hat\\beta_1\\) — оценка углового коэффициента (slope); \\(\\epsilon_i\\) — \\(i\\)-ый остаток, разница между оценкой модели (\\(\\hat\\beta_0 + \\hat\\beta_1 \\times x_i\\)) и реальным значением \\(y_i\\); весь вектор остатков иногда называют случайным шумом (на графике выделены красным). Задача регрессии — оценить параметры \\(\\hat\\beta_0\\) и \\(\\hat\\beta_1\\), если нам известны все значения \\(x_i\\) и \\(y_i\\) и мы пытаемся минимизировать значния \\(\\epsilon_i\\). В данном конкретном случае, задачу можно решить аналитически и получить следующие формулы: \\[\\hat\\beta_1 = \\frac{(\\sum_{i=1}^n x_i\\times y_i)-n\\times\\bar x \\times \\bar y}{\\sum_{i = 1}^n(x_i-\\bar x)^2}\\] \\[\\hat\\beta_0 = \\bar y - \\hat\\beta_1\\times\\bar x\\] 15.5.2 Первая регрессия Давайте попробуем смоделировать количество слов и в рассказах М. Зощенко в зависимости от длины рассказа: zo &lt;- read_tsv(&quot;https://github.com/agricolamz/DS_for_DH/raw/master/data/tidy_zoshenko.csv&quot;) zo %&gt;% filter(word == &quot;и&quot;) %&gt;% distinct() %&gt;% ggplot(aes(n_words, n))+ geom_point()+ labs(x = &quot;количество слов в рассказе&quot;, y = &quot;количество и&quot;) Мы видим, несколько одиночных точек, давайте избавимся от них и добавим регрессионную линию при помощи функции geom_smooth(): zo %&gt;% filter(word == &quot;и&quot;, n_words &lt; 1500) %&gt;% distinct() -&gt; zo_filtered zo_filtered %&gt;% ggplot(aes(n_words, n))+ geom_point()+ geom_smooth(method = &quot;lm&quot;, se = FALSE)+ labs(x = &quot;количество слов в рассказе&quot;, y = &quot;количество и&quot;) Чтобы получить формулу этой линии нужно запустить функцию, которая оценивает линейную регрессию: fit &lt;- lm(n~n_words, data = zo_filtered) fit Call: lm(formula = n ~ n_words, data = zo_filtered) Coefficients: (Intercept) n_words -1.47184 0.04405 Вот мы и получили коэффициенты, теперь мы видим, что наша модель считает следующее: \\[n = -1.47184 + 0.04405 \\times n\\_words\\] Более подробную информцию можно посмотреть, если запустить модель в функцию summary(): summary(fit) Call: lm(formula = n ~ n_words, data = zo_filtered) Residuals: Min 1Q Median 3Q Max -19.6830 -4.3835 0.8986 4.6486 19.6413 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -1.471840 2.467149 -0.597 0.553 n_words 0.044049 0.003666 12.015 &lt;2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 7.945 on 64 degrees of freedom Multiple R-squared: 0.6928, Adjusted R-squared: 0.688 F-statistic: 144.4 on 1 and 64 DF, p-value: &lt; 2.2e-16 В разделе Coefficients содержится информацию про наши коэффициенты: Estimate – полученная оценка коэффициентов; Std. Error – стандартная ошибка среднего; t value – \\(t\\)-статистика, полученная при проведении одновыборочного \\(t\\)-теста, сравнивающего данный коэфициент с 0; Pr(&gt;|t|) – полученное \\(p\\)-значение; Multiple R-squared и Adjusted R-squared — одна из оценок модели, показывает связь между переменными. Без поправок совпадает с квадратом коэффициента корреляции Пирсона: cor(zo_filtered$n_words, zo_filtered$n)^2 [1] 0.6928376 F-statistic — \\(F\\)-статистика полученная при проведении теста, проверяющего, не являются ли хотя бы один из коэффицинтов статистически значимо отличается от нуля. Совпадает с результатами дисперсионного анализа (ANOVA). Теперь мы можем даже предсказывать значения, которые мы еще не видели. Например, сколько будет и в рассказе Зощенко длиной 1000 слов? predict(fit, tibble(n_words = 1000)) 1 42.57715 Постройте ленейную ргерессию на основании рассказов А. Чехова, предсказывая количество и на основании количства слов. При моделировании используйте только рассказы длиной меньше 2500 слов. Укажите свободный член получившейся модели, округлив его до 3 знаков после запятой. Укажите угловой коффициент получившейся модели, округлив его до 3 знаков после запятой. Укажите предсказания модели для рассказа длиной 1000 слов, округлив получнное значение до 3 знаков после запятой. 15.5.3 Категориальные переменные Что если мы хотим включить в наш анализ категориальные переменные? Давайте рассмотрим простой пример с рассказами Чехова и Зощенко, которые мы рассматривали в прошлом разделе. Мы будем анализировать логарифм доли слов деньги: chekhov &lt;- read_tsv(&quot;https://github.com/agricolamz/DS_for_DH/raw/master/data/tidy_chekhov.tsv&quot;) zoshenko &lt;- read_tsv(&quot;https://github.com/agricolamz/DS_for_DH/raw/master/data/tidy_zoshenko.csv&quot;) chekhov$author &lt;- &quot;Чехов&quot; zoshenko$author &lt;- &quot;Зощенко&quot; chekhov %&gt;% bind_rows(zoshenko) %&gt;% filter(str_detect(word, &quot;деньг&quot;)) %&gt;% group_by(author, titles, n_words) %&gt;% summarise(n = sum(n)) %&gt;% mutate(log_ratio = log(n/n_words)) -&gt; checkov_zoshenko Визуализация выглядит так: Красной точкой обозначены средние значения, так что мы видим, что между двумя писателями есть разница, но является ли она статистически значимой? В прошлом разделе, мы рассмотрели, что в таком случае можно сделать t-test: t.test(log_ratio~author, data = checkov_zoshenko, var.equal =TRUE) # здесь я мухлюю, отключая поправку Уэлча Two Sample t-test data: log_ratio by author t = 5.6871, df = 125, p-value = 8.665e-08 alternative hypothesis: true difference in means between group Зощенко and group Чехов is not equal to 0 95 percent confidence interval: 0.8606107 1.7793181 sample estimates: mean in group Зощенко mean in group Чехов -5.021262 -6.341226 Разница между группами является статистически значимой (t(125) = 5.6871, p-value = 8.665e-08). Для того, чтобы запустить регрессию на категориальных данных категориальная переменная автоматически разбивается на группу бинарных dummy-переменных: tibble(author = c(&quot;Чехов&quot;, &quot;Зощенко&quot;), dummy_chekhov = c(1, 0), dummy_zoshenko = c(0, 1)) Дальше для регрессионного анализа выкидывают одну из переменных, так как иначе модель не сойдется (dummy-переменных всегда n-1, где n — количество категорий в переменной). tibble(author = c(&quot;Чехов&quot;, &quot;Зощенко&quot;), dummy_chekhov = c(1, 0)) Если переменная dummy_chekhov принимает значение 1, значит речь о рассказе Чехова, а если принимает значение 0, то о рассказе Зощенко. Если вставить нашу переменную в регрессионную формулу получится следующее: \\[y_i = \\hat\\beta_0 + \\hat\\beta_1 \\times \\text{dummy_chekhov} + \\epsilon_i,\\] Так как dummy_chekhov принимает либо значение 1, либо значение 0, то получается, что модель предсказывает лишь два значения: \\[y_i = \\left\\{\\begin{array}{ll}\\hat\\beta_0 + \\hat\\beta_1 \\times 1 + \\epsilon_i = \\hat\\beta_0 + \\hat\\beta_1 + \\epsilon_i\\text{, если рассказ Чехова}\\\\ \\hat\\beta_0 + \\hat\\beta_1 \\times 0 + \\epsilon_i = \\hat\\beta_0 + \\epsilon_i\\text{, если рассказ Зощенко} \\end{array}\\right.\\] Таким образом, получается, что свободный член \\(\\beta_0\\) и угловой коэффициент \\(\\beta_1\\) в регресси с категориальной переменной получает другую интерпретацию. Одно из значений переменной кодируется при помощи \\(\\beta_0\\), а сумма коэффициентов \\(\\beta_0+\\beta_1\\) дают другое значение переменной. Так что \\(\\beta_1\\) — это разница между оценками двух значений переменной. Давайте теперь запустим регрессию на этих же данных: fit2 &lt;- lm(log_ratio~author, data = checkov_zoshenko) summary(fit2) Call: lm(formula = log_ratio ~ author, data = checkov_zoshenko) Residuals: Min 1Q Median 3Q Max -2.8652 -0.6105 -0.0607 0.6546 3.2398 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -5.0213 0.2120 -23.680 &lt; 2e-16 *** authorЧехов -1.3200 0.2321 -5.687 8.67e-08 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.9717 on 125 degrees of freedom Multiple R-squared: 0.2056, Adjusted R-squared: 0.1992 F-statistic: 32.34 on 1 and 125 DF, p-value: 8.665e-08 Во-первых стоит обратить внимание на то, что R сам преобразовал нашу категориальную переменную в dummy-переменную authorЧехов. Во-вторых, можно заметить, что значения t-статистики и p-value совпадают с результатами полученными нами в t-тесте выше. Статистическти значимый коэффициент при аргументе authorЧехов следует интерпретировать как разницу средних между логарифмом долей в рассказах Чехова и Зощенко. В работе (Coretta 2017, https://goo.gl/NrfgJm) рассматривается отношения между длительностью гласного и придыхание согласного. Автор собрал данные 5 носителей исландского. Дальше он извлек длительность гласного, после которого были придыхательные и непридыхательные. Скачайте данные и постройте регрессионную модель, предсказывающую длительность гласного на основе . 15.5.4 Множественная регрессия Множественная регрессия позволяет проанализировать связь между зависимой и несколькими зависимыми переменными. Формула множественной регрессии не сильно отличается от формулы обычной линейной регрессии: \\[y_i = \\hat\\beta_0 + \\hat\\beta_1 \\times x_{1i}+ \\dots+ \\hat\\beta_n \\times x_{ni} + \\epsilon_i,\\] \\(x_{ki}\\) — \\(i\\)-ый элемент векторов значений \\(X_1, \\dots, X_n\\); \\(y_i\\) — \\(i\\)-ый элемент вектора значений \\(Y\\); \\(\\hat\\beta_0\\) — оценка случайного члена (intercept); \\(\\hat\\beta_k\\) — коэфциент при переменной \\(X_{k}\\); \\(\\epsilon_i\\) — \\(i\\)-ый остаток, разница между оценкой модели (\\(\\hat\\beta_0 + \\hat\\beta_1 \\times x_i\\)) и реальным значением \\(y_i\\); весь вектор остатков иногда называют случайным шумом. В такой регресии предикторы могут быть как числовыми, так и категориальными (со всеми вытекающими последствиями, которые мы обсудили в предудщем разделе). Такую регрессию чаще всего сложно визуализировать, так как в одну регрессионную линию вкладываются сразу несколько переменных. Попробуем предсказать длину лепестка на основе длины чашелистик и вида ириса: iris %&gt;% ggplot(aes(Sepal.Length, Petal.Length, color = Species))+ geom_point() Запустим регрессию: fit3 &lt;- lm(Petal.Length ~ Sepal.Length+ Species, data = iris) summary(fit3) Call: lm(formula = Petal.Length ~ Sepal.Length + Species, data = iris) Residuals: Min 1Q Median 3Q Max -0.76390 -0.17875 0.00716 0.17461 0.79954 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -1.70234 0.23013 -7.397 1.01e-11 *** Sepal.Length 0.63211 0.04527 13.962 &lt; 2e-16 *** Speciesversicolor 2.21014 0.07047 31.362 &lt; 2e-16 *** Speciesvirginica 3.09000 0.09123 33.870 &lt; 2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.2826 on 146 degrees of freedom Multiple R-squared: 0.9749, Adjusted R-squared: 0.9744 F-statistic: 1890 on 3 and 146 DF, p-value: &lt; 2.2e-16 Все предикторы статистически значимы. Давайте посмотрим предсказания модели для всех наблюдений: iris %&gt;% mutate(prediction = predict(fit3)) %&gt;% ggplot(aes(Sepal.Length, prediction, color = Species))+ geom_point() Всегда имеет смысл визуализировать, что нам говорит наша модель. Если использовать пакет ggeffects (или предшествовавший ему пакет effects), это можно сделать не сильно задумываясь, как это делать: library(ggeffects) plot(ggpredict(fit3, terms = c(&quot;Sepal.Length&quot;, &quot;Species&quot;))) Как видно из графиков, наша модель имеет одинаковые угловые коэффициенты (slope) для каждого из видов ириса и разные свободные члены (intercept). summary(fit3) Call: lm(formula = Petal.Length ~ Sepal.Length + Species, data = iris) Residuals: Min 1Q Median 3Q Max -0.76390 -0.17875 0.00716 0.17461 0.79954 Coefficients: Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -1.70234 0.23013 -7.397 1.01e-11 *** Sepal.Length 0.63211 0.04527 13.962 &lt; 2e-16 *** Speciesversicolor 2.21014 0.07047 31.362 &lt; 2e-16 *** Speciesvirginica 3.09000 0.09123 33.870 &lt; 2e-16 *** --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Residual standard error: 0.2826 on 146 degrees of freedom Multiple R-squared: 0.9749, Adjusted R-squared: 0.9744 F-statistic: 1890 on 3 and 146 DF, p-value: &lt; 2.2e-16 \\[y_i = \\left\\{\\begin{array}{ll} -1.70234 + 0.63211 \\times \\text{Sepal.Length} + \\epsilon_i\\text{, если вид setosa}\\\\ -1.70234 + 2.2101 + 0.63211 \\times \\text{Sepal.Length} + \\epsilon_i\\text{, если вид versicolor} \\\\ -1.70234 + 3.09 + 0.63211 \\times \\text{Sepal.Length} + \\epsilon_i\\text{, если вид virginica} \\end{array}\\right.\\] 15.5.5 Сравнение моделей Как нам решить, какая модель лучше? Ведь теперь можно добавить сколько угодно предикторов? Давайте создадим новую модель без предиктора Species: fit4 &lt;- lm(Petal.Length ~ Sepal.Length, data = iris) можно сравнивать статистическую значимость предикторов можно сравнивать \\(R^2\\) summary(fit3)$adj.r.squared [1] 0.9743786 summary(fit4)$adj.r.squared [1] 0.7583327 чаще всего используют так называемые информационные критерии, самый популярный – AIC (Akaike information criterion). Сами по себе значение этого критерия не имеет значения – только в сравнении моделей, построенных на похожих данных. Чем меньше значение, тем модель лучше. AIC(fit3, fit4) 15.5.6 Послесловие сущетсвуют ограничения на применение линейной регресии связь между предсказываемой переменной и предикторами должна быть линейной остатки должны быть нормально распределены (оценивайте визуально) дисперсия остатков вокруг регрессионной линии должно быть постоянно (гомоскидастично) предикторы не должны коррелировать друг с другом все наблюдения в регрессии должны быть независимы друг от друга Вот так вот выглядят остатки нашей модели на основе датасета iris. Смотрите пост, в котором обсуждается, как интерпретировать график остатков. plot(fit3, which=c(1, 2)) сущетсвуют трюки, позволяющие автоматически отбирать модели (см. функцию step()) существует достаточно большое семейство регрессий, который зависят от типа независимой (предсказываемой) переменной или ее распределения логистическая (если предсказываемая переменная имеет два возможных исхода) мультиномиальная (если предсказываемая переменная имеет больше двух возможных дискретных исхода) нелиненые регресии (если связь между переменными нелинейна) регрессия со смешанными эффектами (если внутри данных есть группировки, т. е. наблюдения не независимы) и другие. Как и в других функциях, вычисляющих описательную статистику (mean(), median(), max(), min() и др.), функция var() (и все остальные функции, которые мы будем обсуждать sd(), cov()) возвращают NA, если в векторе есть пропущенные значения. Чтобы изменить это поведение, нужно добавить аргумент na.rm = TRUE.↩︎ "],["работа-статистического-детектива.html", "16 Работа статистического детектива 16.1 Введение 16.2 Возможно ли такое среднее? 16.3 Пакет statcheck 16.4 Пакет digitize", " 16 Работа статистического детектива library(&quot;tidyverse&quot;) 16.1 Введение До сих пор мы лишь использовали разные статистические тесты, чтобы ответить на разные исследовательские вопросы, которые могут возникнуть. Однако часто в статистические выкладки никто не вчитывается и принимает их как данность, надеясь что софт все правильно посчитал. Здесь есть две опасности: во-первых, бывают недобросовестные исследователи; во-вторых, люди часто ошибаются во время применения и представления результатов статистического анализа (и видимо, это случается чаще). Мы рассмотрим несколько методов, которые позволят проверять некоторые простые случаи, что может быть полезно при критическом чтении (например, во время ревью статей ученых и дата журналистов) в случаях, когда к данным нет доступа. Данный раздел вдохнавлен лекцией Кристин Сайнани. 16.2 Возможно ли такое среднее? Представим себе, что кто-то провел эксперимент с биномиальными данными, например, посчитал количество не в рассказе А. П. Чехова длинной 322 слова “Жизнь прекрасна!” и обнаружил среднее 0.095. Возможно ли это? Давайте посмотри на все возможные результаты: tibble(ratio = round(1:322/322, 3)) %&gt;% ggplot()+ geom_vline(aes(xintercept = ratio), color = &quot;lightblue&quot;)+ geom_vline(xintercept = 0.095, color = &quot;red&quot;) Так ничего не видно, давайте сконцентрируемся на промежуке от 0.085 до 0.1, в котором лежит завяленное значение 0.095, и добавим подписи: tibble(ratio = round(1:322/322, 3)) %&gt;% ggplot()+ geom_vline(aes(xintercept = ratio), color = &quot;lightblue&quot;)+ geom_vline(xintercept = 0.095, color = &quot;red&quot;)+ geom_label(aes(x = ratio, label = ratio), y = 0.5)+ xlim(0.085, 0.1) Мы видим, что красные линии повторяются регулярно с интервалом 0.03 и что синяя линия явно не вписывается в этот паттерн. Может быть было использовано другое округление? tibble(ratio = round(1:322/322, 5)) %&gt;% ggplot()+ geom_vline(aes(xintercept = ratio), color = &quot;lightblue&quot;)+ geom_vline(xintercept = 0.095, color = &quot;red&quot;)+ geom_label(aes(x = ratio, label = ratio), y = 0.5)+ xlim(0.085, 0.1) Если бы числа округлялись вверх, на месте 0.09317 мы бы увидели 0.094. Если бы числа округлялись вниз, на месте 0.09627 мы бы увидели 0.096. Так что доля не в рассказе длинной 322 никак не может быть 0.095. Может быть автор ошибся с количеством слов? 200:400*0.095 [1] 19.000 19.095 19.190 19.285 19.380 19.475 19.570 19.665 19.760 19.855 [11] 19.950 20.045 20.140 20.235 20.330 20.425 20.520 20.615 20.710 20.805 [21] 20.900 20.995 21.090 21.185 21.280 21.375 21.470 21.565 21.660 21.755 [31] 21.850 21.945 22.040 22.135 22.230 22.325 22.420 22.515 22.610 22.705 [41] 22.800 22.895 22.990 23.085 23.180 23.275 23.370 23.465 23.560 23.655 [51] 23.750 23.845 23.940 24.035 24.130 24.225 24.320 24.415 24.510 24.605 [61] 24.700 24.795 24.890 24.985 25.080 25.175 25.270 25.365 25.460 25.555 [71] 25.650 25.745 25.840 25.935 26.030 26.125 26.220 26.315 26.410 26.505 [81] 26.600 26.695 26.790 26.885 26.980 27.075 27.170 27.265 27.360 27.455 [91] 27.550 27.645 27.740 27.835 27.930 28.025 28.120 28.215 28.310 28.405 [101] 28.500 28.595 28.690 28.785 28.880 28.975 29.070 29.165 29.260 29.355 [111] 29.450 29.545 29.640 29.735 29.830 29.925 30.020 30.115 30.210 30.305 [121] 30.400 30.495 30.590 30.685 30.780 30.875 30.970 31.065 31.160 31.255 [131] 31.350 31.445 31.540 31.635 31.730 31.825 31.920 32.015 32.110 32.205 [141] 32.300 32.395 32.490 32.585 32.680 32.775 32.870 32.965 33.060 33.155 [151] 33.250 33.345 33.440 33.535 33.630 33.725 33.820 33.915 34.010 34.105 [161] 34.200 34.295 34.390 34.485 34.580 34.675 34.770 34.865 34.960 35.055 [171] 35.150 35.245 35.340 35.435 35.530 35.625 35.720 35.815 35.910 36.005 [181] 36.100 36.195 36.290 36.385 36.480 36.575 36.670 36.765 36.860 36.955 [191] 37.050 37.145 37.240 37.335 37.430 37.525 37.620 37.715 37.810 37.905 [201] 38.000 Среди полученных числе целые числа есть только в значениях 200 и 400. Так что, если автор и ошибся в количестве слов, то слишком масштабно. Еще автор мог ошибиться и там, и там. Этот процесс можно немного автоматизировать: round(200:400*0.095) == 200:400*0.095 [1] TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE Эта идея лежит в основе Granularity-Related Inconsistent Means test (GRIM). Я не нашел его реализации на R, но вот есть он-лайн приложение. 16.3 Пакет statcheck Пакет statcheck написан для извлечения и проверки результатов статистических тестов, которые приводятся в статьях. Рассмотрим пример двустороннего и одностороннего t-тестов: t.test(data = mtcars, qsec ~ am) Welch Two Sample t-test data: qsec by am t = 1.2878, df = 25.534, p-value = 0.2093 alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 95 percent confidence interval: -0.4918522 2.1381679 sample estimates: mean in group 0 mean in group 1 18.18316 17.36000 t.test(data = mtcars, qsec ~ am, alternative = &quot;greater&quot;) Welch Two Sample t-test data: qsec by am t = 1.2878, df = 25.534, p-value = 0.1047 alternative hypothesis: true difference in means between group 0 and group 1 is greater than 0 95 percent confidence interval: -0.2677649 Inf sample estimates: mean in group 0 mean in group 1 18.18316 17.36000 Запустим в функцию statcheck() три варианта: результат двустороннего теста; результат одностороннего теста; совсем неправильный результат. library(&quot;statcheck&quot;) s &lt;- statcheck(c(&quot;t(25.534) = 1.2878, p = 0.21&quot;, &quot;t(25.534) = 1.2878, p = 0.10&quot;, &quot;t(22.716) = 3.7671, p &lt; 0.01&quot;)) | | | 0% | |======================= | 33% | |=============================================== | 67% | |======================================================================| 100% s Теперь в переменной s находится датафрейм со следующими переменными: Source Statistic df1 df2 Test.Comparison Value Reported.Comparison Reported.P.Value Computed Raw Error DecisionError OneTail OneTailedInTxt APAfactor Функция statcheck() работает со следующими статистиками: \\(t\\)-статистика, \\(F\\)-статистика (мы ее видели в регрессии), коэффициент корреляции, хи-квадрат и \\(z\\)-score (используется в z-тесте). В мануале к пакету описаны много дополнительных функций, которые позволяют не копировать текст из статьи, а автоматически извлекать данные для проверки из .pdf или .html. 16.4 Пакет digitize Иногда нам может случится, что данные представлены визуально: set.seed(42) tibble(x = rnorm(20, mean = 40, sd = 10), y = x + rnorm(20, mean = 0, sd = 5)) %&gt;% ggplot(aes(x, y))+ geom_point()+ annotate(geom = &quot;text&quot;, x = 20, y = 60, label = &quot;r = 0.92&quot;, size = 8) Как бы нам проверить корреляцию Пирсона, которая представлена на графике? Для этого мы воспользуемся пакетом digitize (однако аналогичные операции можно сделать и онлайн). На первом шаге нужно определить границы. При помощи функции ReadAndCal() сначала отметьте минимальное значение по оси x, затем максимальное значение по оси х, затем отметьте минимальное значение по оси y, затем максимальное значение по оси y: library(digitize) calibration &lt;- ReadAndCal(&#39;images/test_correlaton.png&#39;) После того, как вы отметите границы появятся синие крестики: Следующий шаг — это отметить наблюдения. Это делается при помощи функции DigitData() (нажмите на кнопку Finish наверху или клавишу Esc): data.points &lt;- DigitData(col = &#39;red&#39;) Теперь на графике появились не только синие крестики, но и красные точки: После этого используйте функцию Calibrate(), чтобы откалибрировать полученные точки: df &lt;- Calibrate(data.points, calibration, 15, # минимум по оси x 60, # максимум по оси x 20, # минимум по оси y 60) # максимум по оси y Давайте проверим, как точки соотносятся с оригиналом: df$type &lt;- &quot;obtained&quot; set.seed(42) tibble(x = rnorm(20, mean = 40, sd = 10), y = x + rnorm(20, mean = 0, sd = 5), type = &quot;original&quot;) %&gt;% bind_rows(df) %&gt;% ggplot(aes(x, y, color = type))+ geom_point() Результат достаточно близкий, давайте теперь проверим коэффициент корреляции: cor(df$x, df$y) [1] 0.9522989 И вот мы выяснили, что коэффициент корреляции Пирсона на этих данных равен 0.95, что отличается от заявленных 0.92. У этого метода, конечно, есть очевидные недостатки: при большом количестве точек метод становится слишком трудоемким; сам процесс тыкания плохо верефицируем, исследователь может случайно ткнуть два раза на одну точку или отметить два раза группу точек, потому что ему показалось, что раньше он эту группу не отмечал; даже при маленьком количестве точек мы не можем заметить случаи, когда значения совпадают или слишком похожи. Т. е. в оригинальных данных может быть две точки, а детектив поставит лишь одну; если Ваше изображение повернуто, то результаты может получиться неправильный. "],["tasks.html", "17 Задания 17.1 Начало работы в R 17.2 Создание векторов 17.3 Приведение типов 17.4 Векторизация 17.5 Индексирование векторов 17.6 Матрицы 17.7 Списки 17.8 Датафрейм 17.9 Условные конструкции 17.10 Создание функций 17.11 Семейство функций apply() 17.12 magrittr::%&gt;% 17.13 Сортировка строк: dplyr::arrange() 17.14 Уникальные значения: dplyr::distinct() 17.15 Создание колонок: dplyr::mutate() и dplyr::transmute() 17.16 Агрегация: dplyr::group_by() %&gt;% summarise() 17.17 Операции с несколькими колонками: across() 17.18 Соединение датафреймов: *_join {#task_join} 17.19 Tidy data", " 17 Задания 17.1 Начало работы в R Разделите 9801 на 9. [1] 1089 Посчитайте логарифм от 8912162342 по основанию 6. [1] 12 Теперь натуральный логарифм 10 и умножьте его на 5. [1] 11.51293 С помощью функции sin() посчитайте \\(\\sin (\\pi), \\sin \\left(\\frac{\\pi}{2}\\right), \\sin \\left(\\frac{\\pi}{6}\\right)\\). Значение \\(\\pi\\) - зашитая в R константа (pi). [1] 1.224647e-16 [1] 1 [1] 0.5 17.2 Создание векторов Создайте вектор из значений 2, 30 и 4000. [1] 2 30 4000 Создайте вектор от 1 до 20. [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Создайте вектор от 20 до 1. [1] 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Функция sum() возвращает сумму элементов вектора на входе. Посчитайте сумму первых 100 натуральных чисел (т.е. всех целых чисел от 1 до 100). [1] 5050 Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз! [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15 [26] 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Создайте вектор значений 5, 4, 3, 2, 2, 3, 4, 5: [1] 5 4 3 2 2 3 4 5 Создайте вектор 2, 4, 6, … , 18, 20. [1] 2 4 6 8 10 12 14 16 18 20 Создайте вектор 0.1, 0.2, 0.3, …, 0.9, 1. [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 2020 год — високосный. Следующий високосный год через 4 года — это будет 2024 год. Составьте календарь всех високосных годов XXI века, начиная с 2020 года. 2100 год относится к XXI веку, а не к XXII. [1] 2020 2024 2028 2032 2036 2040 2044 2048 2052 2056 2060 2064 2068 2072 2076 [16] 2080 2084 2088 2092 2096 2100 Создайте вектор, состоящий из 20 повторений “Хэй!” [1] &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; [11] &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; Как я и говорил, многие функции, работающие с одним значением на входе, так же прекрасно работают и с целыми векторами. Попробуйте посчитать квадратный корень чисел от 1 до 10 с помощью функции sqrt() и сохраните результат в векторе roots. [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 [9] 3.000000 3.162278 Давайте убедимся, что это действительно квадратные корни. Для этого возведите все значения вектора roots в квадрат! [1] 1 2 3 4 5 6 7 8 9 10 Если все верно, то того же самого можно добиться поэлементным умножением вектора roots на себя. [1] 1 2 3 4 5 6 7 8 9 10 *Создайте вектор из одной единицы, двух двоек, трех троек, …. , девяти девяток. [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 9 9 [39] 9 9 9 9 9 9 9 17.3 Приведение типов Сделайте вектор vec1, в котором соедините 3, а также значения \"Мой\" и \"вектор\". [1] &quot;3&quot; &quot;Мой&quot; &quot;вектор&quot; Попробуйте вычесть TRUE из 10. [1] 9 Соедините значение 10 и TRUE в вектор vec2. [1] 10 1 Соедините вектор vec2 и значение \"r\": [1] &quot;10&quot; &quot;1&quot; &quot;r&quot; Соедините значения 10, TRUE, \"r\" в вектор. [1] &quot;10&quot; &quot;TRUE&quot; &quot;r&quot; 17.4 Векторизация Создайте вектор p, состоящий из значений 4, 5, 6, 7, и вектор q, состоящий из 0, 1, 2, 3. [1] 4 5 6 7 [1] 0 1 2 3 Посчитайте поэлементную сумму векторов p и q: [1] 4 6 8 10 Посчитайте поэлементную разницу p и q: [1] 4 4 4 4 Поделите каждый элемент вектора p на соответствующий ему элемент вектора q: О, да, Вам нужно делить на 0! [1] Inf 5.000000 3.000000 2.333333 Возведите каждый элемент вектора p в степень соответствующего ему элемента вектора q: [1] 1 5 36 343 Умножьте каждое значение вектора p на 10. [1] 40 50 60 70 Создайте вектор квадратов чисел от 1 до 10: [1] 1 4 9 16 25 36 49 64 81 100 Создайте вектор 0, 2, 0, 4, … , 18, 0, 20. [1] 0 2 0 4 0 6 0 8 0 10 0 12 0 14 0 16 0 18 0 20 Создайте вектор 1, 0, 3, 0, 5, …, 17, 0, 19, 0. [1] 1 0 3 0 5 0 7 0 9 0 11 0 13 0 15 0 17 0 19 0 *Создайте вектор, в котором будут содержаться первые 20 степеней двойки. [1] 2 4 8 16 32 64 128 256 512 [10] 1024 2048 4096 8192 16384 32768 65536 131072 262144 [19] 524288 1048576 *Создайте вектор из чисел 1, 10, 100, 1000, 10000: [1] 1 10 100 1000 10000 *Посчитать сумму последовательности \\(\\frac{1}{1 \\cdot 2}+\\frac{1}{2 \\cdot 3}+\\frac{1}{3 \\cdot 4}+\\ldots+\\frac{1}{50 \\cdot 51}\\). [1] 0.9803922 *Посчитать сумму последовательности \\(\\frac{1}{2^{0}}+\\frac{1}{2^{1}}+\\frac{1}{2^{2}}+\\frac{1}{2^{3}}+\\ldots \\frac{1}{2^{20}}\\). [1] 1.999999 *Посчитать сумму последовательности \\(1+\\frac{4}{3}+\\frac{7}{9}+\\frac{10}{27}+\\frac{13}{81}+\\ldots+\\frac{28}{19683}\\). [1] 3.749174 *Сколько чисел из последовательности \\(1+\\frac{4}{3}+\\frac{7}{9}+\\frac{10}{27}+\\frac{13}{81}+\\ldots+\\frac{28}{19683}\\) больше чем 0.5? [1] 3 17.5 Индексирование векторов Создайте вектор troiki со значениями 3, 6, 9, …, 24, 27. [1] 3 6 9 12 15 18 21 24 27 Извлеките 2, 5 и 7 значения вектора troiki. [1] 6 15 21 Извлеките предпоследнее значение вектора troiki. [1] 24 Извлеките все значения вектора troiki кроме предпоследнего: [1] 3 6 9 12 15 18 21 27 Создайте вектор vec3: vec3 &lt;- c(3, 5, 2, 1, 8, 4, 9, 10, 3, 15, 1, 11) Найдите второй элемент вектора vec3. [1] 5 Верните второй и пятый элемент вектора vec3. [1] 5 8 Попробуйте извлечь сотое значение вектора vec3: [1] NA Верните все элементы вектора vec3 кроме второго элемента. [1] 3 2 1 8 4 9 10 3 15 1 11 Верните все элементы вектора vec3 кроме второго и пятого элемента. [1] 3 2 1 4 9 10 3 15 1 11 Найдите последний элемент вектора vec3. [1] 11 Верните все значения вектора vec3 кроме первого и последнего. [1] 5 2 1 8 4 9 10 3 15 1 Найдите все значения вектора vec3, которые больше 4. [1] 5 8 9 10 15 11 Найдите все значения вектора vec3, которые больше 4, но меньше 10. Если хотите сделать это в одну строчку, то вам помогут логические операторы! [1] 5 8 9 Найдите все значения вектора vec3, которые меньше 4 или больше 10. [1] 3 2 1 3 15 1 11 Возведите в квадрат каждое значение вектора vec3. [1] 9 25 4 1 64 16 81 100 9 225 1 121 *Возведите в квадрат каждое значение вектора на нечетной позиции и извлеките корень из каждого значения на четной позиции вектора vec3. Извлечение корня - это то же самое, что и возведение в степень 0.5. [1] 9.000000 2.236068 4.000000 1.000000 64.000000 2.000000 81.000000 [8] 3.162278 9.000000 3.872983 1.000000 3.316625 Создайте вектор 2, 4, 6, … , 18, 20 как минимум 2 новыми способами. Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше! [1] 2 4 6 8 10 12 14 16 18 20 ##Работа с пропущенными значениями {#task_na} Создайте вектор vec4 со значениями 300, 15, 8, 2, 0, 1, 110: vec4 &lt;- c(300, 15, 8, 20, 0, 1, 110) vec4 [1] 300 15 8 20 0 1 110 Замените все значения vec4, которые больше 20 на NA. Проверьте полученный вектор vec4: [1] NA 15 8 20 0 1 NA Посчитайте сумму vec4 с помощью функции sum(). Ответ NA не считается! [1] 44 17.6 Матрицы Создайте матрицу 4х4, состоящую из единиц. Назовите ее M1. [,1] [,2] [,3] [,4] [1,] 1 1 1 1 [2,] 1 1 1 1 [3,] 1 1 1 1 [4,] 1 1 1 1 Поменяйте все некрайние значения матрицы M1 (то есть значения на позициях [2,2], [2,3], [3,2] и [3,3]) на число 2. [,1] [,2] [,3] [,4] [1,] 1 1 1 1 [2,] 1 2 2 1 [3,] 1 2 2 1 [4,] 1 1 1 1 Выделите второй и третий столбик из матрицы M1. [,1] [,2] [1,] 1 1 [2,] 2 2 [3,] 2 2 [4,] 1 1 Сравните (==) вторую колонку и вторую строчку матрицы M1. [1] TRUE TRUE TRUE TRUE *Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную mult_tab. [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] 1 2 3 4 5 6 7 8 9 [2,] 2 4 6 8 10 12 14 16 18 [3,] 3 6 9 12 15 18 21 24 27 [4,] 4 8 12 16 20 24 28 32 36 [5,] 5 10 15 20 25 30 35 40 45 [6,] 6 12 18 24 30 36 42 48 54 [7,] 7 14 21 28 35 42 49 56 63 [8,] 8 16 24 32 40 48 56 64 72 [9,] 9 18 27 36 45 54 63 72 81 *Из матрицы mult_tab выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7. [,1] [,2] [,3] [,4] [,5] [1,] 18 24 30 36 42 [2,] 21 28 35 42 49 [3,] 24 32 40 48 56 *Создайте матрицу с логическими значениями, где TRUE, если в этом месте в таблице умножения (mult_tab) двузначное число и FALSE, если однозначное. Матрица - это почти вектор. К нему можно обращаться с единственным индексом. [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [2,] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE [3,] FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE [4,] FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [5,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [6,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [7,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [8,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [9,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE *Создайте матрицу mult_tab2, в которой все значения tab меньше 10 заменены на 0. [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] 0 0 0 0 0 0 0 0 0 [2,] 0 0 0 0 10 12 14 16 18 [3,] 0 0 0 12 15 18 21 24 27 [4,] 0 0 12 16 20 24 28 32 36 [5,] 0 10 15 20 25 30 35 40 45 [6,] 0 12 18 24 30 36 42 48 54 [7,] 0 14 21 28 35 42 49 56 63 [8,] 0 16 24 32 40 48 56 64 72 [9,] 0 18 27 36 45 54 63 72 81 17.7 Списки Дан список list1: list1 = list(numbers = 1:5, letters = letters, logic = TRUE) list1 $numbers [1] 1 2 3 4 5 $letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $logic [1] TRUE Найдите первый элемент списка list1. Ответ должен быть списком длиной один. $numbers [1] 1 2 3 4 5 Теперь найдите содержание первого элемента списка list1 двумя разными способами. Ответ должен быть вектором. [1] 1 2 3 4 5 [1] 1 2 3 4 5 Теперь возьмите первый элемент содержания первого элемента списка list1. Ответ должен быть вектором. [1] 1 Создайте список list2, содержащий в себе два списка list1. Один из них будет иметь имя pupa, а другой — lupa. $pupa $pupa$numbers [1] 1 2 3 4 5 $pupa$letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $pupa$logic [1] TRUE $lupa $lupa$numbers [1] 1 2 3 4 5 $lupa$letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $lupa$logic [1] TRUE *Извлеките первый элемент списка list2, из него — второй полэлемент, а из него — третье значение. [1] &quot;c&quot; 17.8 Датафрейм Запустите команду data(mtcars) чтобы загрузить встроенный датафрейм с информацией про автомобили. Каждая строчка датафрейма - модель автомобиля, каждая колонка - отдельная характеристика. Подробнее см. ?mtcars. data(mtcars) mtcars Изучите структуру датафрейма mtcars с помощью функции str(). &#39;data.frame&#39;: 32 obs. of 11 variables: $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... $ disp: num 160 160 108 258 360 ... $ hp : num 110 110 93 110 175 105 245 62 95 123 ... $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... $ wt : num 2.62 2.88 2.32 3.21 3.44 ... $ qsec: num 16.5 17 18.6 19.4 17 ... $ vs : num 0 0 1 1 0 1 0 1 1 1 ... $ am : num 1 1 1 0 0 0 0 0 0 0 ... $ gear: num 4 4 4 3 3 3 3 4 4 4 ... $ carb: num 4 4 1 1 2 1 4 2 2 4 ... Найдите значение третьей строчки четвертого столбца датафрейма mtcars. [1] 93 Извлеките первые шесть строчек и первые шесть столбцов датафрейма mtcars. Извлеките колонку wt датафрейма mtcars - массу автомобиля в тысячах фунтов. [1] 2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070 [13] 3.730 3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840 [25] 3.845 1.935 2.140 1.513 3.170 2.770 3.570 2.780 Извлеките колонки из mtcars в следующем порядке: hp, mpg, cyl. Посчитайте количество автомобилей с 4 цилиндрами (cyl) в датафрейме mtcars. [1] 11 Посчитайте долю автомобилей с 4 цилиндрами (cyl) в датафрейме mtcars. [1] 0.34375 Найдите все автомобили мощностью не менее 100 лошадиных сил (hp) в датафрейме mtcars. Найдите все автомобили мощностью не менее 100 лошадиных сил (hp) и 4 цилиндрами (cyl) в датафрейме mtcars. Посчитайте максимальную массу (wt) автомобиля в выборке, воспользовавшись функцией max(): [1] 5.424 Посчитайте максимальную массу (wt) автомобиля в выборке, воспользовавшись функцией min(): [1] 1.513 Найдите строчку датафрейма mtcars с самым легким автомобилем. Извлеките строчки датафрейма mtcars с автомобилями, масса которых ниже средней массы. Масса автомобиля указана в тысячах фунтов. Создайте колонку wt_kg с массой автомобиля в килограммах. Результат округлите до целых значений с помощью функции round(). 1 фунт = 0.45359237 кг. 17.9 Условные конструкции Создайте вектор vec5: vec5 &lt;- c(5, 20, 30, 0, 2, 9) Создайте новый строковый вектор, где на месте чисел больше 10 в vec5 будет стоять “большое число,” а на месте остальных чисел — “маленькое число.” [1] &quot;маленькое число&quot; &quot;большое число&quot; &quot;большое число&quot; &quot;маленькое число&quot; [5] &quot;маленькое число&quot; &quot;маленькое число&quot; Загрузите файл heroes_information.csv в переменную heroes. heroes &lt;- read.csv(&quot;data/heroes_information.csv&quot;, stringsAsFactors = FALSE, na.strings = c(&quot;-&quot;, &quot;-99&quot;)) Создайте новою колонку hair в heroes, в которой будет значение \"Bold\" для тех супергероев, у которых в колонке Hair.color стоит \"No Hair\", и значение \"Hairy\" во всех остальных случаях. Создайте новою колонку tall в heroes, в которой будет значение \"tall\" для тех супергероев, у которых в колонке Height стоит число больше 190, значение \"short\" для тех супергероев, у которых в колонке Height стоит число меньше 170, и значение \"middle\" во всех остальных случаях. 17.10 Создание функций Создайте функцию plus_one(), которая принимает число и возвращает это же число + 1. Проверьте функцию plus_one() на числе 41. plus_one(41) [1] 42 Создайте функцию circle_area, которая вычисляет площадь круга по радиусу согласно формуле \\(\\pi r^2\\). Посчитайте площадь круга с радиусом 5. [1] 78.53982 Создайте функцию cels2fahr(), которая будет превращать градусы по Цельсию в градусы по Фаренгейту. Проверьте на значениях -100, -40 и 0, что функция cels2fahr() работает корректно. cels2fahr(c(-100, -40, 0)) [1] -148 -40 32 Напишите функцию highlight(), которая принимает на входе строковый вектор, а возвращает тот же вектор, но дополненный значением \"***\" в начале и конце вектора. Лучше всего это рассмотреть на примере: highlight(c(&quot;Я&quot;, &quot;Бэтмен!&quot;)) [1] &quot;***&quot; &quot;Я&quot; &quot;Бэтмен!&quot; &quot;***&quot; Теперь сделайте функцию highlight более гибкой. Добавьте в нее параметр wrapper =, который по умолчанию равен \"***\". Значение параметра wrapper = и будет вставлено в начало и конец вектора. Проверьте написанную функцию на векторе c(\"Я\", \"Бэтмен!\"). highlight(c(&quot;Я&quot;, &quot;Бэтмен!&quot;)) [1] &quot;***&quot; &quot;Я&quot; &quot;Бэтмен!&quot; &quot;***&quot; highlight(c(&quot;Я&quot;, &quot;Бэтмен!&quot;), wrapper = &quot;__&quot;) [1] &quot;__&quot; &quot;Я&quot; &quot;Бэтмен!&quot; &quot;__&quot; Создайте функцию trim(), которая будет возвращать вектор без первого и последнего значения (вне зависимости от типа данных). Проверьте, что функция trim() работает корректно: trim(1:7) [1] 2 3 4 5 6 trim(letters) [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; [20] &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; Теперь добавьте в функцию trim() параметр n = со значением по умолчанию 1. Этот параметр будет обозначать сколько значений нужно отрезать слева и справа от вектора. Проверьте полученную функцию: trim(letters) [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; [20] &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; trim(letters, n = 2) [1] &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; [20] &quot;v&quot; &quot;w&quot; &quot;x&quot; Сделайте так, чтобы функция trim() работала корректно с n = 0, т.е. функция возвращала бы исходный вектор без изменений. trim(letters, n = 0) [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; *Теперь добавьте проверку на адекватность входных данных: функция trim() должна выдавать ошибку, если n = меньше нуля или если n = слишком большой и отрезает все значения вектора: *Проверьте полученную функцию trim(): trim(1:6, 3) Error in trim(1:6, 3): n слишком большой! trim(1:6, -1) Error in trim(1:6, -1): n не может быть меньше нуля! Создайте функцию na_n(), которая будет возвращать количество NA в векторе. Проверьте функцию na_n() на векторе: na_n(c(NA, 3:5, NA, 2, NA)) [1] 3 Напишите функцию factors(), которая будет возвращать все делители числа в виде числового вектора. Здесь может понадобиться оператор для получения остатка от деления: %%. Проверьте функцию factors() на простых и сложных числах: factors(3) [1] 1 3 factors(161) [1] 1 7 23 161 factors(1984) [1] 1 2 4 8 16 31 32 62 64 124 248 496 992 1984 *Напишите функцию is_prime(), которая проверяет, является ли число простым. Здесь может пригодиться функция any() - она возвращает TRUE, если в векторе есть хотя бы один TRUE. Проверьте какие года были для нас простыми, а какие нет: is_prime(2017) [1] TRUE is_prime(2019) [1] FALSE 2019/3 #2019 делится на 3 без остатка [1] 673 is_prime(2020) [1] FALSE is_prime(2021) [1] FALSE *Создайте функцию monotonic(), которая возвращает TRUE, если значения в векторе не убывают (то есть каждое следующее - больше или равно предыдущему) или не возврастают. Полезная функция для этого — diff() — возвращает разницу соседних значений. monotonic(1:7) [1] TRUE monotonic(c(1:5,5:1)) [1] FALSE monotonic(6:-1) [1] TRUE monotonic(c(1:5, rep(5, 10), 5:10)) [1] TRUE Бинарные операторы типа + или %in% тоже представляют собой функции. Более того, мы можем создавать свои бинарные операторы! В этом нет особой сложности — нужно все так же создавать функцию (для двух переменных), главное окружать их % и название обрамлять обратными штрихами `. Например, можно сделать свой бинарный оператор %notin%, который будет выдавать TRUE, если значения слева нет в векторе справа: `%notin%` &lt;- function(x, y) ! (x %in% y) 1:10 %notin% c(1, 4, 5) [1] FALSE TRUE TRUE FALSE FALSE TRUE TRUE TRUE TRUE TRUE *Создайте бинарный оператор %without%, который будет возвращать все значения вектора слева без значений вектора справа. c(&quot;а&quot;, &quot;и&quot;, &quot;б&quot;, &quot;сидели&quot;, &quot;на&quot;, &quot;трубе&quot;) %without% c(&quot;а&quot;, &quot;б&quot;) [1] &quot;и&quot; &quot;сидели&quot; &quot;на&quot; &quot;трубе&quot; *Создайте бинарный оператор %between%, который будет возвращать TRUE, если значение в векторе слева накходится в диапазоне значений вектора справа: 1:10 %between% c(1, 4, 5) [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE 17.11 Семейство функций apply() Создайте матрицу M2: M2 &lt;- matrix(c(20:11, 11:20), nrow = 5) M2 [,1] [,2] [,3] [,4] [1,] 20 15 11 16 [2,] 19 14 12 17 [3,] 18 13 13 18 [4,] 17 12 14 19 [5,] 16 11 15 20 Посчитайте максимальное значение матрицы M2 по каждой строчке. [1] 20 19 18 19 20 Посчитайте максимальное значение матрицы M2 по каждому столбцу. [1] 20 15 15 20 Посчитайте среднее значение матрицы M2 по каждой строке. [1] 15.5 15.5 15.5 15.5 15.5 Посчитайте среднее значение матрицы M2 по каждому столбцу. [1] 18 13 13 18 Создайте список list3: list3 &lt;- list( a = 1:5, b = 0:20, c = 4:24, d = 6:3, e = 6:25 ) Найдите максимальное значение каждого вектора списка list3. a b c d e 5 20 24 6 25 Посчитайте сумму каждого вектора списка list3. a b c d e 15 210 294 18 310 Посчитайте длину каждого вектора списка list3. a b c d e 5 21 21 4 20 Напишите функцию max_item(), которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент. Для этого вам может понадобиться функция which.max(), которая возвращает индекс максимального значения (первого, если их несколько). Проверьте функцию max_item() на списке list3. max_item(list3) [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Теперь мы сделаем сложный список list4: list4 &lt;- list(1:3, 3:40, list3) Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри. Результат должен быть списком с такой же структорой, как и изначальный список list4. Для этого может понадобиться функция rapply(): recursive lapply [[1]] [1] 3 [[2]] [1] 38 [[3]] [[3]]$a [1] 5 [[3]]$b [1] 21 [[3]]$c [1] 21 [[3]]$d [1] 4 [[3]]$e [1] 20 *Загрузите набор данных heroes и посчитайте, сколько NA в каждом из столбцов. Для этого удобно использовать ранее написанную функцию na_n(). X name Gender Eye.color Race Hair.color Height 0 0 29 172 304 172 217 Publisher Skin.color Alignment Weight hair tall 0 662 7 239 172 217 *Используя ранее написанную функцию is_prime(), напишите функцию prime_numbers(), которая будет возвращать все простые числа до выбранного числа. prime_numbers(200) [1] 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 [20] 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 [39] 173 179 181 191 193 197 199 17.12 magrittr::%&gt;% Перепишите следующие выражения, используя %&gt;%: sqrt(sum(1:10)) [1] 7.416198 [1] 7.416198 abs(min(-5:5)) [1] 5 [1] 5 c(&quot;Корень из&quot;, 2, &quot;равен&quot;, sqrt(2)) [1] &quot;Корень из&quot; &quot;2&quot; &quot;равен&quot; &quot;1.4142135623731&quot; [1] &quot;Корень из&quot; &quot;2&quot; &quot;равен&quot; &quot;1.4142135623731&quot; ##Выбор строк: dplyr::slice() и dplyr::filter() {#task_filt} Выберите только те строчки, в которых содержится информация о супергероях тяжелее 500 кг. Выберите только те строчки, в которых содержится информация о женщинах-супергероях тяжелее 500 кг. Выберите только те строчки, в которых содержится информация о супергероях человеческой расы (\"Human\") женского пола. Из этих супергероев возьмите первые 5. ##Выбор столбцов: dplyr::select() {#task_select} Выберете первые 4 столбца в powers. Выберите все столбцы от Reflexes до Empathy в тиббле powers: Выберите все столбцы тиббла powers кроме первого (hero_names): 17.13 Сортировка строк: dplyr::arrange() Выберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки по возрастанию Height. Выберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки по убыванию Height. Выберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки сначала по Gender, затем по убыванию Height. 17.14 Уникальные значения: dplyr::distinct() Извлеките уникальные значения столбца Eye color из тиббла heroes. Извлеките уникальные значения столбца Hair color из тиббла heroes. 17.15 Создание колонок: dplyr::mutate() и dplyr::transmute() Создайте колонку height_m с ростом супергероев в метрах, затем выберите только колонки name и height_m. Создайте новою колонку hair в heroes, в которой будет значение \"Bold\" для тех супергероев, у которых в колонке Hair.color стоит \"No Hair\", и значение \"Hairy\" во всех остальных случаях. Затем выберите только колонки name, Hair color, hair. 17.16 Агрегация: dplyr::group_by() %&gt;% summarise() Посчитайте количество супергероев по расам и отсортируйте по убыванию. Извлеките первые 5 строк. Посчитайте средний пост по полу. 17.17 Операции с несколькими колонками: across() Посчитайте количество NA в каждой колонке, группируя по полу (Gender). Посчитайте количество NA в каждой колонке, которая заканчивается на \"color\", группируя по полу (Gender). Создайте из тиббла heroes новый тиббл с колонками name, Height и Weight, где для каждого героя содержится значение \"выше среднего\", если его рост или вес выше среднего по колонке и \"ниже среднего\", если ниже или равен среднему. Создайте из тиббла heroes новый тиббл с колонками Gender, name, Height и Weight, где для каждого героя содержится значение \"выше среднего\", если его рост или вес выше среднего по колонке и \"ниже среднего\", если ниже или равен среднему внутри соответствующей группы по полу. 17.18 Соединение датафреймов: *_join {#task_join} Создайте тиббл web_creators, в котором будут супергерои, которые могут плести паутину, т.е. у них стоит TRUE в колонке Web Creation в тиббле powers. Найдите всех супергероев, которые присутствуют в heroes, но отсутствуют в powers. Ответом должен быть строковый вектор с именами супергероев. [1] &quot;Agent 13&quot; &quot;Alfred Pennyworth&quot; &quot;Arsenal&quot; [4] &quot;Batgirl III&quot; &quot;Batgirl V&quot; &quot;Beetle&quot; [7] &quot;Black Goliath&quot; &quot;Black Widow II&quot; &quot;Blaquesmith&quot; [10] &quot;Bolt&quot; &quot;Boomer&quot; &quot;Box&quot; [13] &quot;Box III&quot; &quot;Captain Mar-vell&quot; &quot;Cat II&quot; [16] &quot;Cecilia Reyes&quot; &quot;Clea&quot; &quot;Clock King&quot; [19] &quot;Colin Wagner&quot; &quot;Colossal Boy&quot; &quot;Corsair&quot; [22] &quot;Cypher&quot; &quot;Danny Cooper&quot; &quot;Darkside&quot; [25] &quot;ERG-1&quot; &quot;Fixer&quot; &quot;Franklin Storm&quot; [28] &quot;Giant-Man&quot; &quot;Giant-Man II&quot; &quot;Goliath&quot; [31] &quot;Goliath&quot; &quot;Goliath&quot; &quot;Guardian&quot; [34] &quot;Hawkwoman&quot; &quot;Hawkwoman II&quot; &quot;Hawkwoman III&quot; [37] &quot;Howard the Duck&quot; &quot;Jack Bauer&quot; &quot;Jesse Quick&quot; [40] &quot;Jessica Sanders&quot; &quot;Jigsaw&quot; &quot;Jyn Erso&quot; [43] &quot;Kid Flash II&quot; &quot;Kingpin&quot; &quot;Meteorite&quot; [46] &quot;Mister Zsasz&quot; &quot;Mogo&quot; &quot;Moloch&quot; [49] &quot;Morph&quot; &quot;Nite Owl II&quot; &quot;Omega Red&quot; [52] &quot;Paul Blart&quot; &quot;Penance&quot; &quot;Penance I&quot; [55] &quot;Plastic Lad&quot; &quot;Power Man&quot; &quot;Renata Soliz&quot; [58] &quot;Ronin&quot; &quot;Shrinking Violet&quot; &quot;Snake-Eyes&quot; [61] &quot;Spider-Carnage&quot; &quot;Spider-Woman II&quot; &quot;Stacy X&quot; [64] &quot;Thunderbird II&quot; &quot;Two-Face&quot; &quot;Vagabond&quot; [67] &quot;Vision II&quot; &quot;Vulcan&quot; &quot;Warbird&quot; [70] &quot;White Queen&quot; &quot;Wiz Kid&quot; &quot;Wondra&quot; [73] &quot;Wyatt Wingfoot&quot; &quot;Yellow Claw&quot; Найдите всех супергероев, которые присутствуют в powers, но отсутствуют в heroes. Ответом должен быть строковый вектор с именами супергероев. [1] &quot;3-D Man&quot; &quot;Bananaman&quot; &quot;Bizarro-Girl&quot; [4] &quot;Black Vulcan&quot; &quot;Blue Streak&quot; &quot;Bradley&quot; [7] &quot;Clayface&quot; &quot;Concrete&quot; &quot;Dementor&quot; [10] &quot;Doctor Poison&quot; &quot;Fire&quot; &quot;Hellgramite&quot; [13] &quot;Lara Croft&quot; &quot;Little Epic&quot; &quot;Lord Voldemort&quot; [16] &quot;Orion&quot; &quot;Peek-a-Boo&quot; &quot;Queen Hippolyta&quot; [19] &quot;Reactron&quot; &quot;SHDB&quot; &quot;Stretch Armstrong&quot; [22] &quot;TEST&quot; &quot;Tommy Clarke&quot; &quot;Tyrant&quot; 17.19 Tidy data Для начала создайте тиббл heroes_weight, скопировав код: heroes_weight &lt;- heroes %&gt;% filter(Publisher %in% c(&quot;DC Comics&quot;, &quot;Marvel Comics&quot;)) %&gt;% group_by(Gender, Publisher) %&gt;% summarise(weight_mean = mean(Weight, na.rm = TRUE)) %&gt;% drop_na() heroes_weight Функция drop_na() позволяет выбросить все строчки, в которых встречается NA. Превратите тиббл heroes_weight в широкий тиббл: Затем превратите его обратно в длинный тиббл: Сделайте powers длинным тибблом с тремя колонками: hero_names, power (названгие суперсилы) и has (наличие суперсилы у данного супергероя). Сделайте тиббл powers обратно широким, но с новой структурой: каждая строчка означает суперсилу, а каждая колонка - супергероя (за исключением первой колонки - названия суперсилы). "],["solutions.html", "18 Решения заданий 18.1 Приведение типов 18.2 Векторизация 18.3 Индексирование векторов 18.4 Матрицы 18.5 Списки 18.6 Датафрейм 18.7 Условные конструкции 18.8 Создание функций 18.9 Семейство функций apply() 18.10 magrittr::%&gt;% 18.11 Сортировка строк: dplyr::arrange() 18.12 Уникальные значения: dplyr::distinct() 18.13 Создание колонок: dplyr::mutate() и dplyr::transmute() 18.14 Агрегация: dplyr::group_by() %&gt;% summarise() 18.15 Операции с несколькими колонками: across() 18.16 Соединение датафреймов: *_join {#solution_join} 18.17 Tidy data", " 18 Решения заданий ##Начало работы в R {#solution_begin} Разделите 9801 на 9. 9801/9 [1] 1089 Посчитайте логарифм от 8912162342 по основанию 6. log(2176782336, 6) [1] 12 Теперь натуральный логарифм 10 и умножьте его на 5. log(10)*5 [1] 11.51293 С помощью функции sin() посчитайте \\(\\sin (\\pi), \\sin \\left(\\frac{\\pi}{2}\\right), \\sin \\left(\\frac{\\pi}{6}\\right)\\). Значение \\(\\pi\\) - зашитая в R константа (pi). sin(pi) [1] 1.224647e-16 sin(pi/2) [1] 1 sin(pi/6) [1] 0.5 ##Создание векторов {#solution_new_vecs} Создайте вектор из значений 2, 30 и 4000. c(2, 30, 4000) [1] 2 30 4000 Создайте вектор от 1 до 20. 1:20 [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Создайте вектор от 20 до 1. 20:1 [1] 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Функция sum() возвращает сумму элементов вектора на входе. Посчитайте сумму первых 100 натуральных чисел (т.е. всех целых чисел от 1 до 100). sum(1:100) [1] 5050 Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз! c(1:20, 19:1) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15 [26] 14 13 12 11 10 9 8 7 6 5 4 3 2 1 Создайте вектор значений 5, 4, 3, 2, 2, 3, 4, 5: c(5:2, 2:5) [1] 5 4 3 2 2 3 4 5 Создайте вектор 2, 4, 6, … , 18, 20. seq(2, 20, 2) [1] 2 4 6 8 10 12 14 16 18 20 Создайте вектор 0.1, 0.2, 0.3, …, 0.9, 1. seq(0, 1, 0.1) [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 2020 год — високосный. Следующий високосный год через 4 года — это будет 2024 год. Составьте календарь всех високосных годов XXI века, начиная с 2020 года. 2100 год относится к XXI веку, а не к XXII. seq(2020, 2100, 4) [1] 2020 2024 2028 2032 2036 2040 2044 2048 2052 2056 2060 2064 2068 2072 2076 [16] 2080 2084 2088 2092 2096 2100 Создайте вектор, состоящий из 20 повторений “Хэй!” rep(&quot;Хэй!&quot;, 20) [1] &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; [11] &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; &quot;Хэй!&quot; Как я и говорил, многие функции, работающие с одним значением на входе, так же прекрасно работают и с целыми векторами. Попробуйте посчитать квадратный корень чисел от 1 до 10 с помощью функции sqrt() и сохраните результат в векторе roots. roots &lt;- sqrt(1:10) roots [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 [9] 3.000000 3.162278 Давайте убедимся, что это действительно квадратные корни. Для этого возведите все значения вектора roots в квадрат! roots ^ 2 [1] 1 2 3 4 5 6 7 8 9 10 Если все верно, то того же самого можно добиться поэлементным умножением вектора roots на себя. roots * roots [1] 1 2 3 4 5 6 7 8 9 10 *Создайте вектор из одной единицы, двух двоек, трех троек, …. , девяти девяток. rep(1:9, 1:9) [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 9 9 [39] 9 9 9 9 9 9 9 18.1 Приведение типов Сделайте вектор vec1, в котором соедините 3, а также значения \"Мой\" и \"вектор\". vec1 &lt;- c(3, &quot;Мой&quot;, &quot;вектор&quot;) vec1 [1] &quot;3&quot; &quot;Мой&quot; &quot;вектор&quot; Попробуйте вычесть TRUE из 10. 10 - TRUE [1] 9 Соедините значение 10 и TRUE в вектор vec2. vec2 &lt;- c(10, TRUE) vec2 [1] 10 1 Соедините вектор vec2 и значение \"r\": c(vec2, &quot;r&quot;) [1] &quot;10&quot; &quot;1&quot; &quot;r&quot; Соедините значения 10, TRUE, \"r\" в вектор. c(10, TRUE, &quot;r&quot;) [1] &quot;10&quot; &quot;TRUE&quot; &quot;r&quot; 18.2 Векторизация Создайте вектор p, состоящий из значений 4, 5, 6, 7, и вектор q, состоящий из 0, 1, 2, 3. p &lt;- 4:7 p [1] 4 5 6 7 q &lt;- 0:3 q [1] 0 1 2 3 Посчитайте поэлементную сумму векторов p и q: p + q [1] 4 6 8 10 Посчитайте поэлементную разницу p и q: p - q [1] 4 4 4 4 Поделите каждый элемент вектора p на соответствующий ему элемент вектора q: О, да, Вам нужно делить на 0! p / q [1] Inf 5.000000 3.000000 2.333333 Возведите каждый элемент вектора p в степень соответствующего ему элемента вектора q: p ^ q [1] 1 5 36 343 Умножьте каждое значение вектора p на 10. p * 10 [1] 40 50 60 70 Создайте вектор квадратов чисел от 1 до 10: (1:10)^2 [1] 1 4 9 16 25 36 49 64 81 100 Создайте вектор 0, 2, 0, 4, … , 18, 0, 20. 1:20 * 0:1 [1] 0 2 0 4 0 6 0 8 0 10 0 12 0 14 0 16 0 18 0 20 Создайте вектор 1, 0, 3, 0, 5, …, 17, 0, 19, 0. 1:20 * 1:0 [1] 1 0 3 0 5 0 7 0 9 0 11 0 13 0 15 0 17 0 19 0 *Создайте вектор, в котором будут содержаться первые 20 степеней двойки. 2 ^ (1:20) [1] 2 4 8 16 32 64 128 256 512 [10] 1024 2048 4096 8192 16384 32768 65536 131072 262144 [19] 524288 1048576 *Создайте вектор из чисел 1, 10, 100, 1000, 10000: 10 ^ (0:4) [1] 1 10 100 1000 10000 *Посчитать сумму последовательности \\(\\frac{1}{1 \\cdot 2}+\\frac{1}{2 \\cdot 3}+\\frac{1}{3 \\cdot 4}+\\ldots+\\frac{1}{50 \\cdot 51}\\). sum(1 / (1:50 * 2:51)) [1] 0.9803922 *Посчитать сумму последовательности \\(\\frac{1}{2^{0}}+\\frac{1}{2^{1}}+\\frac{1}{2^{2}}+\\frac{1}{2^{3}}+\\ldots \\frac{1}{2^{20}}\\). sum(1 / 2 ^ (0:20)) [1] 1.999999 *Посчитать сумму последовательности \\(1+\\frac{4}{3}+\\frac{7}{9}+\\frac{10}{27}+\\frac{13}{81}+\\ldots+\\frac{28}{19683}\\). sum((3 * (1:10) - 2) / 3 ^ (0:9)) [1] 3.749174 *Сколько чисел из последовательности \\(1+\\frac{4}{3}+\\frac{7}{9}+\\frac{10}{27}+\\frac{13}{81}+\\ldots+\\frac{28}{19683}\\) больше чем 0.5? sum((3 * (1:10) - 2) / 3 ^ (0:9) &gt; 0.5) [1] 3 18.3 Индексирование векторов Создайте вектор troiki со значениями 3, 6, 9, …, 24, 27. troiki &lt;- seq(3, 27, 3) troiki [1] 3 6 9 12 15 18 21 24 27 Извлеките 2, 5 и 7 значения вектора troiki. troiki[c(2, 5, 7)] [1] 6 15 21 Извлеките предпоследнее значение вектора troiki. troiki[length(troiki) - 1] [1] 24 Извлеките все значения вектора troiki кроме предпоследнего: troiki[-(length(troiki) - 1)] [1] 3 6 9 12 15 18 21 27 Создайте вектор vec3: vec3 &lt;- c(3, 5, 2, 1, 8, 4, 9, 10, 3, 15, 1, 11) Найдите второй элемент вектора vec3. vec3[2] [1] 5 Верните второй и пятый элемент вектора vec3. vec3[c(2, 5)] [1] 5 8 Попробуйте извлечь сотое значение вектора vec3: vec3[100] [1] NA Верните все элементы вектора vec3 кроме второго элемента. vec3[-2] [1] 3 2 1 8 4 9 10 3 15 1 11 Верните все элементы вектора vec3 кроме второго и пятого элемента. vec3[c(-2, -5)] [1] 3 2 1 4 9 10 3 15 1 11 Найдите последний элемент вектора vec3. vec3[length(vec3)] [1] 11 Верните все значения вектора vec3 кроме первого и последнего. vec3[c(-1, -length(vec3))] [1] 5 2 1 8 4 9 10 3 15 1 Найдите все значения вектора vec3, которые больше 4. vec3[vec3 &gt; 4] [1] 5 8 9 10 15 11 Найдите все значения вектора vec3, которые больше 4, но меньше 10. Если хотите сделать это в одну строчку, то вам помогут логические операторы! vec3[vec3 &gt; 4 &amp; vec3 &lt; 10] [1] 5 8 9 Найдите все значения вектора vec3, которые меньше 4 или больше 10. vec3[vec3 &lt; 4 | vec3 &gt; 10] [1] 3 2 1 3 15 1 11 Возведите в квадрат каждое значение вектора vec3. vec3 ^ 2 [1] 9 25 4 1 64 16 81 100 9 225 1 121 *Возведите в квадрат каждое значение вектора на нечетной позиции и извлеките корень из каждого значения на четной позиции вектора vec3. Извлечение корня - это то же самое, что и возведение в степень 0.5. vec3 ^ c(2, 0.5) [1] 9.000000 2.236068 4.000000 1.000000 64.000000 2.000000 81.000000 [8] 3.162278 9.000000 3.872983 1.000000 3.316625 Создайте вектор 2, 4, 6, … , 18, 20 как минимум 2 новыми способами. Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше! (1:20)[c(FALSE,TRUE)] [1] 2 4 6 8 10 12 14 16 18 20 #(1:10)*2 ##Работа с пропущенными значениями {#solution_na} Создайте вектор vec4 со значениями 300, 15, 8, 2, 0, 1, 110: vec4 &lt;- c(300, 15, 8, 20, 0, 1, 110) vec4 [1] 300 15 8 20 0 1 110 Замените все значения vec4, которые больше 20 на NA. vec4[vec4 &gt; 20] &lt;- NA Проверьте полученный вектор vec4: vec4 [1] NA 15 8 20 0 1 NA Посчитайте сумму vec4 с помощью функции sum(). Ответ NA не считается! sum(vec4, na.rm = TRUE) [1] 44 18.4 Матрицы Создайте матрицу 4х4, состоящую из единиц. Назовите ее M1. M1 &lt;- matrix(rep(1, 16), ncol = 4) M1 [,1] [,2] [,3] [,4] [1,] 1 1 1 1 [2,] 1 1 1 1 [3,] 1 1 1 1 [4,] 1 1 1 1 Поменяйте все некрайние значения матрицы M1 (то есть значения на позициях [2,2], [2,3], [3,2] и [3,3]) на число 2. M1[2:3, 2:3] &lt;- 2 M1 [,1] [,2] [,3] [,4] [1,] 1 1 1 1 [2,] 1 2 2 1 [3,] 1 2 2 1 [4,] 1 1 1 1 Выделите второй и третий столбик из матрицы M1. M1[,2:3] [,1] [,2] [1,] 1 1 [2,] 2 2 [3,] 2 2 [4,] 1 1 Сравните (==) вторую колонку и вторую строчку матрицы M1. M1[,2] == M1[2,] [1] TRUE TRUE TRUE TRUE *Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную mult_tab. mult_tab &lt;- matrix(rep(1:9, rep(9,9))*(1:9), nrow = 9) mult_tab [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] 1 2 3 4 5 6 7 8 9 [2,] 2 4 6 8 10 12 14 16 18 [3,] 3 6 9 12 15 18 21 24 27 [4,] 4 8 12 16 20 24 28 32 36 [5,] 5 10 15 20 25 30 35 40 45 [6,] 6 12 18 24 30 36 42 48 54 [7,] 7 14 21 28 35 42 49 56 63 [8,] 8 16 24 32 40 48 56 64 72 [9,] 9 18 27 36 45 54 63 72 81 #Еще #outer(1:9, 1:9, &quot;*&quot;) #1:9 %o% 1:9 *Из матрицы mult_tab выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7. mult_tab[6:8, 3:7] [,1] [,2] [,3] [,4] [,5] [1,] 18 24 30 36 42 [2,] 21 28 35 42 49 [3,] 24 32 40 48 56 *Создайте матрицу с логическими значениями, где TRUE, если в этом месте в таблице умножения (mult_tab) двузначное число и FALSE, если однозначное. Матрица - это почти вектор. К нему можно обращаться с единственным индексом. mult_tab &gt;= 10 [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE [2,] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE [3,] FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE [4,] FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [5,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [6,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [7,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [8,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE [9,] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE *Создайте матрицу mult_tab2, в которой все значения tab меньше 10 заменены на 0. mult_tab2 &lt;- mult_tab mult_tab2[mult_tab &lt; 10] &lt;- 0 mult_tab2 [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [1,] 0 0 0 0 0 0 0 0 0 [2,] 0 0 0 0 10 12 14 16 18 [3,] 0 0 0 12 15 18 21 24 27 [4,] 0 0 12 16 20 24 28 32 36 [5,] 0 10 15 20 25 30 35 40 45 [6,] 0 12 18 24 30 36 42 48 54 [7,] 0 14 21 28 35 42 49 56 63 [8,] 0 16 24 32 40 48 56 64 72 [9,] 0 18 27 36 45 54 63 72 81 18.5 Списки Дан список list1: list1 = list(numbers = 1:5, letters = letters, logic = TRUE) list1 $numbers [1] 1 2 3 4 5 $letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $logic [1] TRUE Найдите первый элемент списка list1. Ответ должен быть списком длиной один. list1[1] $numbers [1] 1 2 3 4 5 Теперь найдите содержание первого элемента списка list1 двумя разными способами. Ответ должен быть вектором. list1[[1]] [1] 1 2 3 4 5 list1$numbers [1] 1 2 3 4 5 Теперь возьмите первый элемент содержания первого элемента списка list1. Ответ должен быть вектором. list1[[1]][1] [1] 1 Создайте список list2, содержащий в себе два списка list1. Один из них будет иметь имя pupa, а другой — lupa. list2 = list(pupa = list1, lupa = list1) list2 $pupa $pupa$numbers [1] 1 2 3 4 5 $pupa$letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $pupa$logic [1] TRUE $lupa $lupa$numbers [1] 1 2 3 4 5 $lupa$letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; $lupa$logic [1] TRUE *Извлеките первый элемент списка list2, из него — второй полэлемент, а из него — третье значение. list2[[1]][[2]][3] [1] &quot;c&quot; 18.6 Датафрейм Запустите команду data(mtcars) чтобы загрузить встроенный датафрейм с информацией про автомобили. Каждая строчка датафрейма - модель автомобиля, каждая колонка - отдельная характеристика. Подробнее см. ?mtcars. data(mtcars) mtcars Изучите структуру датафрейма mtcars с помощью функции str(). str(mtcars) &#39;data.frame&#39;: 32 obs. of 11 variables: $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... $ disp: num 160 160 108 258 360 ... $ hp : num 110 110 93 110 175 105 245 62 95 123 ... $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... $ wt : num 2.62 2.88 2.32 3.21 3.44 ... $ qsec: num 16.5 17 18.6 19.4 17 ... $ vs : num 0 0 1 1 0 1 0 1 1 1 ... $ am : num 1 1 1 0 0 0 0 0 0 0 ... $ gear: num 4 4 4 3 3 3 3 4 4 4 ... $ carb: num 4 4 1 1 2 1 4 2 2 4 ... Найдите значение третьей строчки четвертого столбца датафрейма mtcars. mtcars[3, 4] [1] 93 Извлеките первые шесть строчек и первые шесть столбцов датафрейма mtcars. mtcars[1:6, 1:6] Извлеките колонку wt датафрейма mtcars - массу автомобиля в тысячах фунтов. mtcars$wt [1] 2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070 [13] 3.730 3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840 [25] 3.845 1.935 2.140 1.513 3.170 2.770 3.570 2.780 Извлеките колонки из mtcars в следующем порядке: hp, mpg, cyl. mtcars[, c(&quot;hp&quot;, &quot;mpg&quot;, &quot;cyl&quot;)] Посчитайте количество автомобилей с 4 цилиндрами (cyl) в датафрейме mtcars. sum(mtcars$cyl == 4) [1] 11 Посчитайте долю автомобилей с 4 цилиндрами (cyl) в датафрейме mtcars. mean(mtcars$cyl == 4) [1] 0.34375 Найдите все автомобили мощностью не менее 100 лошадиных сил (hp) в датафрейме mtcars. mtcars[mtcars$hp &gt;= 100, ] Найдите все автомобили мощностью не менее 100 лошадиных сил (hp) и 4 цилиндрами (cyl) в датафрейме mtcars. mtcars[mtcars$hp &gt;= 100 &amp; mtcars$cyl == 4, ] Посчитайте максимальную массу (wt) автомобиля в выборке, воспользовавшись функцией max(): max(mtcars$wt) [1] 5.424 Посчитайте максимальную массу (wt) автомобиля в выборке, воспользовавшись функцией min(): min(mtcars$wt) [1] 1.513 Найдите строчку датафрейма mtcars с самым легким автомобилем. mtcars[mtcars$wt == min(mtcars$wt), ] Извлеките строчки датафрейма mtcars с автомобилями, масса которых ниже средней массы. mtcars[mtcars$wt &lt; mean(mtcars$wt), ] Масса автомобиля указана в тысячах фунтов. Создайте колонку wt_kg с массой автомобиля в килограммах. Результат округлите до целых значений с помощью функции round(). 1 фунт = 0.45359237 кг. mtcars$wt_kg &lt;- round(mtcars$wt * 1000 * 0.45359237) mtcars 18.7 Условные конструкции Создайте вектор vec5: vec5 &lt;- c(5, 20, 30, 0, 2, 9) Создайте новый строковый вектор, где на месте чисел больше 10 в vec5 будет стоять “большое число,” а на месте остальных чисел — “маленькое число.” ifelse(vec5 &gt; 10, &quot;большое число&quot;, &quot;маленькое число&quot;) [1] &quot;маленькое число&quot; &quot;большое число&quot; &quot;большое число&quot; &quot;маленькое число&quot; [5] &quot;маленькое число&quot; &quot;маленькое число&quot; Загрузите файл heroes_information.csv в переменную heroes. heroes &lt;- read.csv(&quot;data/heroes_information.csv&quot;, stringsAsFactors = FALSE, na.strings = c(&quot;-&quot;, &quot;-99&quot;)) Создайте новою колонку hair в heroes, в которой будет значение \"Bold\" для тех супергероев, у которых в колонке Hair.color стоит \"No Hair\", и значение \"Hairy\" во всех остальных случаях. heroes$hair &lt;- ifelse(heroes$Hair.color == &quot;No Hair&quot;, &quot;Bold&quot;, &quot;Hairy&quot;) head(heroes) Создайте новою колонку tall в heroes, в которой будет значение \"tall\" для тех супергероев, у которых в колонке Height стоит число больше 190, значение \"short\" для тех супергероев, у которых в колонке Height стоит число меньше 170, и значение \"middle\" во всех остальных случаях. # heroes$tall &lt;- dplyr::case_when( # heroes$Height &gt; 190 ~ &quot;tall&quot;, # heroes$Height &lt; 170 ~ &quot;short&quot;, # TRUE ~ &quot;middle&quot; # ) heroes$tall &lt;- ifelse(heroes$Height &gt; 190, &quot;tall&quot;, ifelse(heroes$Height &lt; 170, &quot;short&quot;, &quot;middle&quot;)) 18.8 Создание функций Создайте функцию plus_one(), которая принимает число и возвращает это же число + 1. plus_one &lt;- function(x) x + 1 Проверьте функцию plus_one() на числе 41. plus_one(41) [1] 42 Создайте функцию circle_area, которая вычисляет площадь круга по радиусу согласно формуле \\(\\pi r^2\\). circle_area &lt;- function(r) pi * r ^ 2 Посчитайте площадь круга с радиусом 5. circle_area(5) [1] 78.53982 Создайте функцию cels2fahr(), которая будет превращать градусы по Цельсию в градусы по Фаренгейту. cels2fahr &lt;- function(x) x * 9 / 5 + 32 Проверьте на значениях -100, -40 и 0, что функция cels2fahr() работает корректно. cels2fahr(c(-100, -40, 0)) [1] -148 -40 32 Напишите функцию highlight(), которая принимает на входе строковый вектор, а возвращает тот же вектор, но дополненный значением \"***\" в начале и конце вектора. Лучше всего это рассмотреть на примере: highlight &lt;- function(x) c(&quot;***&quot;, x, &quot;***&quot;) highlight(c(&quot;Я&quot;, &quot;Бэтмен!&quot;)) [1] &quot;***&quot; &quot;Я&quot; &quot;Бэтмен!&quot; &quot;***&quot; Теперь сделайте функцию highlight более гибкой. Добавьте в нее параметр wrapper =, который по умолчанию равен \"***\". Значение параметра wrapper = и будет вставлено в начало и конец вектора. highlight &lt;- function(x, wrapper = &quot;***&quot;) c(wrapper, x, wrapper) Проверьте написанную функцию на векторе c(\"Я\", \"Бэтмен!\"). highlight(c(&quot;Я&quot;, &quot;Бэтмен!&quot;)) [1] &quot;***&quot; &quot;Я&quot; &quot;Бэтмен!&quot; &quot;***&quot; highlight(c(&quot;Я&quot;, &quot;Бэтмен!&quot;), wrapper = &quot;__&quot;) [1] &quot;__&quot; &quot;Я&quot; &quot;Бэтмен!&quot; &quot;__&quot; Создайте функцию trim(), которая будет возвращать вектор без первого и последнего значения (вне зависимости от типа данных). trim &lt;- function(x) x[c(-1, -length(x))] Проверьте, что функция trim() работает корректно: trim(1:7) [1] 2 3 4 5 6 trim(letters) [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; [20] &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; Теперь добавьте в функцию trim() параметр n = со значением по умолчанию 1. Этот параметр будет обозначать сколько значений нужно отрезать слева и справа от вектора. trim &lt;- function(x, n = 1) x[c(-1:-n, (-length(x)+n-1):-length(x))] Проверьте полученную функцию: trim(letters) [1] &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; [20] &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; trim(letters, n = 2) [1] &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; [20] &quot;v&quot; &quot;w&quot; &quot;x&quot; Сделайте так, чтобы функция trim() работала корректно с n = 0, т.е. функция возвращала бы исходный вектор без изменений. trim &lt;- function(x, n = 1) { if (n == 0) return(x) x[c(-1:-n, (-length(x)+n-1):-length(x))] } trim(letters, n = 0) [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; *Теперь добавьте проверку на адекватность входных данных: функция trim() должна выдавать ошибку, если n = меньше нуля или если n = слишком большой и отрезает все значения вектора: trim &lt;- function(x, n = 1) { if (n &lt; 0) stop(&quot;n не может быть меньше нуля!&quot;) l &lt;- length(x) if (n &gt; ceiling(l/2) - 1) stop(&quot;n слишком большой!&quot;) if (n == 0) return(x) x[c(-1:-n, (-l+n-1):-l)] } *Проверьте полученную функцию trim(): trim(1:6, 3) Error in trim(1:6, 3): n слишком большой! trim(1:6, -1) Error in trim(1:6, -1): n не может быть меньше нуля! Создайте функцию na_n(), которая будет возвращать количество NA в векторе. na_n &lt;- function(x) sum(is.na(x)) Проверьте функцию na_n() на векторе: na_n(c(NA, 3:5, NA, 2, NA)) [1] 3 Напишите функцию factors(), которая будет возвращать все делители числа в виде числового вектора. Здесь может понадобиться оператор для получения остатка от деления: %%. factors &lt;- function(x) (1:x)[x %% (1:x) == 0] Проверьте функцию factors() на простых и сложных числах: factors(3) [1] 1 3 factors(161) [1] 1 7 23 161 factors(1984) [1] 1 2 4 8 16 31 32 62 64 124 248 496 992 1984 *Напишите функцию is_prime(), которая проверяет, является ли число простым. Здесь может пригодиться функция any() - она возвращает TRUE, если в векторе есть хотя бы один TRUE. is_prime &lt;- function(x) !any(x%%(2:(x-1)) == 0) #is_prime &lt;- function(x) length(factors(x)) == 2 #Используя уже написанную функцию factors() Проверьте какие года были для нас простыми, а какие нет: is_prime(2017) [1] TRUE is_prime(2019) [1] FALSE 2019/3 #2019 делится на 3 без остатка [1] 673 is_prime(2020) [1] FALSE is_prime(2021) [1] FALSE *Создайте функцию monotonic(), которая возвращает TRUE, если значения в векторе не убывают (то есть каждое следующее - больше или равно предыдущему) или не возврастают. Полезная функция для этого — diff() — возвращает разницу соседних значений. monotonic &lt;- function(x) all(diff(x)&gt;=0) | all(diff(x)&lt;=0) monotonic(1:7) [1] TRUE monotonic(c(1:5,5:1)) [1] FALSE monotonic(6:-1) [1] TRUE monotonic(c(1:5, rep(5, 10), 5:10)) [1] TRUE Бинарные операторы типа + или %in% тоже представляют собой функции. Более того, мы можем создавать свои бинарные операторы! В этом нет особой сложности — нужно все так же создавать функцию (для двух переменных), главное окружать их % и название обрамлять обратными штрихами `. Например, можно сделать свой бинарный оператор %notin%, который будет выдавать TRUE, если значения слева нет в векторе справа: `%notin%` &lt;- function(x, y) ! (x %in% y) 1:10 %notin% c(1, 4, 5) [1] FALSE TRUE TRUE FALSE FALSE TRUE TRUE TRUE TRUE TRUE *Создайте бинарный оператор %without%, который будет возвращать все значения вектора слева без значений вектора справа. `%without%` &lt;- function(x, y) x[!x %in% y] c(&quot;а&quot;, &quot;и&quot;, &quot;б&quot;, &quot;сидели&quot;, &quot;на&quot;, &quot;трубе&quot;) %without% c(&quot;а&quot;, &quot;б&quot;) [1] &quot;и&quot; &quot;сидели&quot; &quot;на&quot; &quot;трубе&quot; *Создайте бинарный оператор %between%, который будет возвращать TRUE, если значение в векторе слева накходится в диапазоне значений вектора справа: `%between%` &lt;- function(x, y) x &gt;= min(y) &amp; x &lt;= max(y) 1:10 %between% c(1, 4, 5) [1] TRUE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE 18.9 Семейство функций apply() Создайте матрицу M2: M2 &lt;- matrix(c(20:11, 11:20), nrow = 5) M2 [,1] [,2] [,3] [,4] [1,] 20 15 11 16 [2,] 19 14 12 17 [3,] 18 13 13 18 [4,] 17 12 14 19 [5,] 16 11 15 20 Посчитайте максимальное значение матрицы M2 по каждой строчке. apply(M2, 1, max) [1] 20 19 18 19 20 Посчитайте максимальное значение матрицы M2 по каждому столбцу. apply(M2, 2, max) [1] 20 15 15 20 Посчитайте среднее значение матрицы M2 по каждой строке. apply(M2, 1, mean) [1] 15.5 15.5 15.5 15.5 15.5 Посчитайте среднее значение матрицы M2 по каждому столбцу. apply(M2, 2, mean) [1] 18 13 13 18 Создайте список list3: list3 &lt;- list( a = 1:5, b = 0:20, c = 4:24, d = 6:3, e = 6:25 ) Найдите максимальное значение каждого вектора списка list3. sapply(list3, max) a b c d e 5 20 24 6 25 Посчитайте сумму каждого вектора списка list3. sapply(list3, sum) a b c d e 15 210 294 18 310 Посчитайте длину каждого вектора списка list3. sapply(list3, length) a b c d e 5 21 21 4 20 Напишите функцию max_item(), которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент. Для этого вам может понадобиться функция which.max(), которая возвращает индекс максимального значения (первого, если их несколько). max_item &lt;- function (x) x[[which.max(sapply(x, length))]] Проверьте функцию max_item() на списке list3. max_item(list3) [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Теперь мы сделаем сложный список list4: list4 &lt;- list(1:3, 3:40, list3) Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри. Результат должен быть списком с такой же структорой, как и изначальный список list4. Для этого может понадобиться функция rapply(): recursive lapply rapply(list4, length, how = &quot;list&quot;) [[1]] [1] 3 [[2]] [1] 38 [[3]] [[3]]$a [1] 5 [[3]]$b [1] 21 [[3]]$c [1] 21 [[3]]$d [1] 4 [[3]]$e [1] 20 *Загрузите набор данных heroes и посчитайте, сколько NA в каждом из столбцов. Для этого удобно использовать ранее написанную функцию na_n(). sapply(heroes, na_n) X name Gender Eye.color Race Hair.color Height 0 0 29 172 304 172 217 Publisher Skin.color Alignment Weight hair tall 0 662 7 239 172 217 *Используя ранее написанную функцию is_prime(), напишите функцию prime_numbers(), которая будет возвращать все простые числа до выбранного числа. is_prime &lt;- function(x) !any(x %% (2:(x - 1)) == 0) prime_numbers &lt;- function(x) (2:x)[sapply(2:x, is_prime)] prime_numbers(200) [1] 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 [20] 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 [39] 173 179 181 191 193 197 199 library(tidyverse) heroes &lt;- read_csv(&quot;data/heroes_information.csv&quot;, na = c(&quot;-&quot;, &quot;-99&quot;)) powers &lt;- read_csv(&quot;data/super_hero_powers.csv&quot;) 18.10 magrittr::%&gt;% Перепишите следующие выражения, используя %&gt;%: sqrt(sum(1:10)) [1] 7.416198 1:10 %&gt;% sum() %&gt;% sqrt() [1] 7.416198 abs(min(-5:5)) [1] 5 -5:5 %&gt;% min() %&gt;% abs() [1] 5 c(&quot;Корень из&quot;, 2, &quot;равен&quot;, sqrt(2)) [1] &quot;Корень из&quot; &quot;2&quot; &quot;равен&quot; &quot;1.4142135623731&quot; 2 %&gt;% c(&quot;Корень из&quot;, ., &quot;равен&quot;, sqrt(.)) [1] &quot;Корень из&quot; &quot;2&quot; &quot;равен&quot; &quot;1.4142135623731&quot; ##Выбор строк: dplyr::slice() и dplyr::filter() {#solution_filt} Выберите только те строчки, в которых содержится информация о супергероях тяжелее 500 кг. heroes %&gt;% filter(Weight &gt; 500) Выберите только те строчки, в которых содержится информация о женщинах-супергероях тяжелее 500 кг. heroes %&gt;% filter(Weight &gt; 500 &amp; Gender == &quot;Female&quot;) Выберите только те строчки, в которых содержится информация о супергероях человеческой расы (\"Human\") женского пола. Из этих супергероев возьмите первые 5. heroes %&gt;% filter(Race == &quot;Human&quot; &amp; Gender == &quot;Female&quot;) %&gt;% slice(1:5) ##Выбор столбцов: dplyr::select() {#solution_select} Выберете первые 4 столбца в powers. powers %&gt;% select(1:4) Выберите все столбцы от Reflexes до Empathy в тиббле powers: powers %&gt;% select(Reflexes:Empathy) Выберите все столбцы тиббла powers кроме первого (hero_names): powers %&gt;% select(!hero_names) 18.11 Сортировка строк: dplyr::arrange() Выберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки по возрастанию Height. heroes %&gt;% select(name, Gender, Height) %&gt;% arrange(Height) Выберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки по убыванию Height. heroes %&gt;% select(name, Gender, Height) %&gt;% arrange(desc(Height)) Выберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки сначала по Gender, затем по убыванию Height. heroes %&gt;% select(name, Gender, Height) %&gt;% arrange(Gender, desc(Height)) 18.12 Уникальные значения: dplyr::distinct() Извлеките уникальные значения столбца Eye color из тиббла heroes. heroes %&gt;% distinct(`Eye color`) Извлеките уникальные значения столбца Hair color из тиббла heroes. heroes %&gt;% distinct(`Hair color`) 18.13 Создание колонок: dplyr::mutate() и dplyr::transmute() Создайте колонку height_m с ростом супергероев в метрах, затем выберите только колонки name и height_m. heroes %&gt;% mutate(height_m = Height/100) %&gt;% select(name, height_m) Создайте новою колонку hair в heroes, в которой будет значение “Bold” для тех супергероев, у которых в колонке Hair.color стоит “No Hair,” и значение “Hairy” во всех остальных случаях. Затем выберите только колонки name, Hair color, hair. heroes %&gt;% mutate(hair = ifelse(`Hair color` == &quot;No Hair&quot;, &quot;Bold&quot;, &quot;Hairy&quot;)) %&gt;% select(name, `Hair color`, hair) 18.14 Агрегация: dplyr::group_by() %&gt;% summarise() Посчитайте количество супергероев по расам и отсортируйте по убыванию. Извлеките первые 5 строк. heroes %&gt;% count(Race, sort = TRUE) %&gt;% slice(1:5) Посчитайте средний пост по полу. heroes %&gt;% group_by(Gender) %&gt;% summarise(height_mean = mean(Height, na.rm = TRUE)) 18.15 Операции с несколькими колонками: across() Посчитайте количество NA в каждой колонке, группируя по полу (Gender). na_n &lt;- function(x) sum(is.na(x)) heroes %&gt;% group_by(Gender) %&gt;% summarise(across(everything(), na_n)) Посчитайте количество NA в каждой колонке, которая заканчивается на \"color\", группируя по полу (Gender). na_n &lt;- function(x) sum(is.na(x)) heroes %&gt;% group_by(Gender) %&gt;% summarise(across(ends_with(&quot;color&quot;), na_n)) Создайте из тиббла heroes новый тиббл с колонками name, Height и Weight, где для каждого героя содержится значение \"выше среднего\", если его рост или вес выше среднего по колонке и \"ниже среднего\", если ниже или равен среднему. higher_than_average &lt;- function(x) ifelse(x &gt; mean(x, na.rm = TRUE), &quot;выше среднего&quot;, &quot;ниже среднего&quot;) heroes %&gt;% transmute(name, across(c(Height, Weight), higher_than_average)) Создайте из тиббла heroes новый тиббл с колонками Gender, name, Height и Weight, где для каждого героя содержится значение \"выше среднего\", если его рост или вес выше среднего по колонке и \"ниже среднего\", если ниже или равен среднему внутри соответствующей группы по полу. heroes %&gt;% group_by(Gender) %&gt;% transmute(name, across(c(Height, Weight), higher_than_average)) 18.16 Соединение датафреймов: *_join {#solution_join} Создайте тиббл web_creators, в котором будут супергерои, которые могут плести паутину, т.е. у них стоит TRUE в колонке Web Creation в тиббле powers. powers_web &lt;- powers %&gt;% select(hero_names, `Web Creation`) web_creators &lt;- left_join(heroes, powers_web, by = c(&quot;name&quot; = &quot;hero_names&quot;)) %&gt;% filter(`Web Creation`) web_creators Найдите всех супергероев, которые присутствуют в heroes, но отсутствуют в powers. Ответом должен быть строковый вектор с именами супергероев. anti_join(heroes, powers, by = c(&quot;name&quot; = &quot;hero_names&quot;)) %&gt;% pull(name) [1] &quot;Agent 13&quot; &quot;Alfred Pennyworth&quot; &quot;Arsenal&quot; [4] &quot;Batgirl III&quot; &quot;Batgirl V&quot; &quot;Beetle&quot; [7] &quot;Black Goliath&quot; &quot;Black Widow II&quot; &quot;Blaquesmith&quot; [10] &quot;Bolt&quot; &quot;Boomer&quot; &quot;Box&quot; [13] &quot;Box III&quot; &quot;Captain Mar-vell&quot; &quot;Cat II&quot; [16] &quot;Cecilia Reyes&quot; &quot;Clea&quot; &quot;Clock King&quot; [19] &quot;Colin Wagner&quot; &quot;Colossal Boy&quot; &quot;Corsair&quot; [22] &quot;Cypher&quot; &quot;Danny Cooper&quot; &quot;Darkside&quot; [25] &quot;ERG-1&quot; &quot;Fixer&quot; &quot;Franklin Storm&quot; [28] &quot;Giant-Man&quot; &quot;Giant-Man II&quot; &quot;Goliath&quot; [31] &quot;Goliath&quot; &quot;Goliath&quot; &quot;Guardian&quot; [34] &quot;Hawkwoman&quot; &quot;Hawkwoman II&quot; &quot;Hawkwoman III&quot; [37] &quot;Howard the Duck&quot; &quot;Jack Bauer&quot; &quot;Jesse Quick&quot; [40] &quot;Jessica Sanders&quot; &quot;Jigsaw&quot; &quot;Jyn Erso&quot; [43] &quot;Kid Flash II&quot; &quot;Kingpin&quot; &quot;Meteorite&quot; [46] &quot;Mister Zsasz&quot; &quot;Mogo&quot; &quot;Moloch&quot; [49] &quot;Morph&quot; &quot;Nite Owl II&quot; &quot;Omega Red&quot; [52] &quot;Paul Blart&quot; &quot;Penance&quot; &quot;Penance I&quot; [55] &quot;Plastic Lad&quot; &quot;Power Man&quot; &quot;Renata Soliz&quot; [58] &quot;Ronin&quot; &quot;Shrinking Violet&quot; &quot;Snake-Eyes&quot; [61] &quot;Spider-Carnage&quot; &quot;Spider-Woman II&quot; &quot;Stacy X&quot; [64] &quot;Thunderbird II&quot; &quot;Two-Face&quot; &quot;Vagabond&quot; [67] &quot;Vision II&quot; &quot;Vulcan&quot; &quot;Warbird&quot; [70] &quot;White Queen&quot; &quot;Wiz Kid&quot; &quot;Wondra&quot; [73] &quot;Wyatt Wingfoot&quot; &quot;Yellow Claw&quot; Найдите всех супергероев, которые присутствуют в powers, но отсутствуют в heroes. Ответом должен быть строковый вектор с именами супергероев. anti_join(powers, heroes, by = c(&quot;hero_names&quot; = &quot;name&quot;)) %&gt;% pull(hero_names) [1] &quot;3-D Man&quot; &quot;Bananaman&quot; &quot;Bizarro-Girl&quot; [4] &quot;Black Vulcan&quot; &quot;Blue Streak&quot; &quot;Bradley&quot; [7] &quot;Clayface&quot; &quot;Concrete&quot; &quot;Dementor&quot; [10] &quot;Doctor Poison&quot; &quot;Fire&quot; &quot;Hellgramite&quot; [13] &quot;Lara Croft&quot; &quot;Little Epic&quot; &quot;Lord Voldemort&quot; [16] &quot;Orion&quot; &quot;Peek-a-Boo&quot; &quot;Queen Hippolyta&quot; [19] &quot;Reactron&quot; &quot;SHDB&quot; &quot;Stretch Armstrong&quot; [22] &quot;TEST&quot; &quot;Tommy Clarke&quot; &quot;Tyrant&quot; 18.17 Tidy data Для начала создайте тиббл heroes_weight, скопировав код: heroes_weight &lt;- heroes %&gt;% filter(Publisher %in% c(&quot;DC Comics&quot;, &quot;Marvel Comics&quot;)) %&gt;% group_by(Gender, Publisher) %&gt;% summarise(weight_mean = mean(Weight, na.rm = TRUE)) %&gt;% drop_na() heroes_weight Функция drop_na() позволяет выбросить все строчки, в которых встречается NA. Превратите тиббл heroes_weight в широкий тиббл: heroes_weight %&gt;% pivot_wider(names_from = &quot;Publisher&quot;, values_from = &quot;weight_mean&quot;) Затем превратите его обратно в длинный тиббл: heroes_weight %&gt;% pivot_wider(names_from = &quot;Publisher&quot;, values_from = &quot;weight_mean&quot;) %&gt;% pivot_longer(cols = !Gender, names_to = &quot;Publisher&quot;, values_to = &quot;weight_mean&quot;) Сделайте powers длинным тибблом с тремя колонками: hero_names, power (названгие суперсилы) и has (наличие суперсилы у данного супергероя). powers %&gt;% pivot_longer(cols = !hero_names, names_to = &quot;power&quot;, values_to = &quot;has&quot;) Сделайте тиббл powers обратно широким, но с новой структурой: каждая строчка означает суперсилу, а каждая колонка - супергероя (за исключением первой колонки - названия суперсилы). powers %&gt;% pivot_longer(cols = !hero_names, names_to = &quot;power&quot;, values_to = &quot;has&quot;) %&gt;% pivot_wider(names_from = hero_names, values_from = has) "],["ссылки-на-литературу.html", "Ссылки на литературу", " Ссылки на литературу "]]
